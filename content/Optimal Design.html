<!DOCTYPE html><html>
        <head>
        <title>2019 Fall 電腦輔助設計實習課程網頁</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <link href="https://fonts.googleapis.com/css?family=Quicksand:300,400,500,700,900" rel="stylesheet">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/fonts/icomoon/style.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/bootstrap.min.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/magnific-popup.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/jquery-ui.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/owl.carousel.min.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/owl.theme.default.min.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/bootstrap-datepicker.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/fonts/flaticon/font/flaticon.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/aos.css">
        <link rel="stylesheet" href="./../cmsimde/static/chimper/css/style.css">
        <link rel="shortcut icon" href="./../cmsimde/static/favicons.png">
        
        <style type='text/css'>
            .site-section {
            background-color: #FFFF;
            padding: 40px 40px;
            }
            body > div > div.dropdown.open {
                display: block;
            }
        </style>
    
        <!-- <script src="./../cmsimde/static/jquery.js"></script> -->
        <!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script> -->
        <script src="../cmsimde/static/chimper/js/jquery-3.3.1.min.js"></script>
        <link rel="stylesheet" href="./../cmsimde/static/tipuesearch/css/normalize.min.css">
        <script src="./../cmsimde/static/tipuesearch/tipuesearch_set.js"></script>
        <script src="tipuesearch_content.js"></script>
        <link rel="stylesheet" href="./../cmsimde/static/tipuesearch/css/tipuesearch.css">
        <script src="./../cmsimde/static/tipuesearch/tipuesearch.js"></script>
        <script>
            /* original tipuesearch
            $(document).ready(function() {
                 $('#tipue_search_input').tipuesearch();
            });
            */
            // customed doSearch
            function doSearch() {
                $('#tipue_search_input').tipuesearch({
                    newWindow: true, 
                    minimumLength: 2,
                    wholeWords: false, // for search 中文
                });
            }
            $(document).ready(doSearch);
        </script>
        
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shCore.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushJScript.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushJava.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushPython.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushSql.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushHaxe.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushXml.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushPhp.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushLua.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushCpp.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushCss.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushCSharp.js"></script>
<script type="text/javascript" src="./../cmsimde/static/syntaxhighlighter/shBrushDart.js"></script>
<link type="text/css" rel="stylesheet" href="./../cmsimde/static/syntaxhighlighter/css/shCoreDefault.css"/>
<script type="text/javascript">SyntaxHighlighter.all();</script>

<!-- 啟用 LaTeX equations 編輯 -->
<script src="https://scrum-3.github.io/web/math/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript"></script>
<script type="text/javascript">
init_mathjax = function() {
    if (window.MathJax) {
        // MathJax loaded
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
            },
            displayAlign: 'left', // Change this to 'center' to center equations.
            "HTML-CSS": {
                styles: {'.MathJax_Display': {"margin": 0}}
            }
        });
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
    }
}
init_mathjax();
</script>

<!-- 暫時不用
<script src="./../cmsimde/static/fengari-web.js"></script>
<script type="text/javascript" src="./../cmsimde/static/Cango-13v08-min.js"></script>
<script type="text/javascript" src="./../cmsimde/static/CangoAxes-4v01-min.js"></script>
<script type="text/javascript" src="./../cmsimde/static/gearUtils-05.js"></script>
-->
<!-- for Brython 暫時不用
<script src="https://scrum-3.github.io/web/brython/brython.js"></script>
<script src="https://scrum-3.github.io/web/brython/brython_stdlib.js"></script>
-->
<style>
img.add_border {
    border: 3px solid blue;
}
</style>

</head>
<body>
<div class='container'><nav>
        
    <div class="site-wrap">

    <div class="site-mobile-menu">
      <div class="site-mobile-menu-header">
        <div class="site-mobile-menu-close mt-3">
          <span class="icon-close2 js-menu-toggle"></span>
        </div>
      </div>
      <div class="site-mobile-menu-body"></div>
    </div>
    
            <header class="site-navbar py-4 bg-white" role="banner">
              <div class="container-fluid">
                <div class="row align-items-center">
                <h1>2019 Fall 電腦輔助設計實習課程網頁</h1>
                <div class="pl-4">
                    <form>
                    <input type="text" placeholder="Search" name="q" id="tipue_search_input" pattern=".{2,}" title="At least 2 characters" required>
                    </form>
                </div>
                  <!-- <div class="col-11 col-xl-2">
                    <h1 class="mb-0 site-logo"><a href="index.html" class="text-black h2 mb-0">2019 Fall 電腦輔助設計實習課程網頁</a></h1> 
                  </div>
                  -->
                  <div class="col-12 col-md-10 d-none d-xl-block">
                    <nav class="site-navigation position-relative text-right" role="navigation">
    <ul class='site-menu js-clone-nav mr-auto d-none d-lg-block'>
                        <li class="active has-children"><a href="index.html">Home</a>
                        <ul class="dropdown">
                            <li><a href="sitemap.html">Site Map</a></li>
                            <li><a href="./../reveal/index.html">reveal</a></li>
                            <li><a href="./../blog/index.html">blog</a></li>
                        </ul>
                      </li>
                     <li class='has-children'><a href='About.html'>About</a><ul class='dropdown'><li><a href='CAD Process.html'>CAD Process</a><li><a href='Evaluation.html'>Evaluation</a><li><a href='課程表單.html'>課程表單</a><li class='has-children'><a href='Theories.html'>Theories</a><ul class='dropdown'><li><a href='Design Theory.html'>Design Theory</a><li><a href='Optimal Design.html'>Optimal Design</a><li><a href='Cloud MCAD.html'>Cloud MCAD</a><li><a href='Generative Design.html'>Generative Design</a></li></li></ul></ul><li class='has-children'><a href='CMS.html'>CMS</a><ul class='dropdown'><li class='has-children'><a href='CMSiMDE.html'>CMSiMDE</a><ul class='dropdown'><li><a href='CMSiMDE 已知錯誤.html'>CMSiMDE 已知錯誤</a></li></ul><li class='has-children'><a href='STL.html'>STL</a><ul class='dropdown'><li><a href='Trimesh.html'>Trimesh</a></li></li></ul></ul><li class='has-children'><a href='Tools.html'>Tools</a><ul class='dropdown'><li><a href='FFmpeg.html'>FFmpeg</a><li><a href='GUI.html'>GUI</a><li><a href='Solvespace.html'>Solvespace</a><li class='has-children'><a href='Pyslvs-UI.html'>Pyslvs-UI</a><ul class='dropdown'><li><a href='Pyside2.html'>Pyside2</a></li></ul><li><a href='Onshape.html'>Onshape</a><li class='has-children'><a href='V-rep.html'>V-rep</a><ul class='dropdown'><li><a href='V-rep Manual.html'>V-rep Manual</a><li><a href='3D Printer.html'>3D Printer</a><li><a href='Cyber-physical.html'>Cyber-physical</a></li></ul><li><a href='FreeCAD.html'>FreeCAD</a><li class='has-children'><a href='Webots.html'>Webots</a><ul class='dropdown'><li><a href='VRML.html'>VRML</a><li><a href='SciTE.html'>SciTE</a><li><a href='Webots Doc.html'>Webots Doc</a><li><a href='Robot Curriculum.html'>Robot Curriculum</a><li><a href='Three.js.html'>Three.js</a></li></ul><li class='has-children'><a href='Solidworks.html'>Solidworks</a><ul class='dropdown'><li><a href='SW API.html'>SW API</a></li></ul><li><a href='Libfivepy.html'>Libfivepy</a><li><a href='NX.html'>NX</a><li><a href='NX12 程式.html'>NX12 程式</a><li><a href='TeX.html'>TeX</a><li><a href='Open CAX.html'>Open CAX</a><li><a href='Bond Graphs.html'>Bond Graphs</a></li></ul><li class='has-children'><a href='Tasks.html'>Tasks</a><ul class='dropdown'><li><a href='分組名單.html'>分組名單</a><li class='has-children'><a href='Task1.html'>Task1</a><ul class='dropdown'><li><a href='Solvespace 編譯.html'>Solvespace 編譯</a><li><a href='Solvespace 操作.html'>Solvespace 操作</a><li><a href='機構設計與模擬.html'>機構設計與模擬</a><li><a href='GCS.html'>GCS</a></li></ul><li class='has-children'><a href='Task2.html'>Task2</a><ul class='dropdown'><li><a href='導入 GitExtensions.html'>導入 GitExtensions</a><li><a href='Batch Command.html'>Batch Command</a></li></ul><li class='has-children'><a href='Task3.html'>Task3</a><ul class='dropdown'><li><a href='WB Tutorial1.html'>WB Tutorial1</a><li><a href='W16 Exam.html'>W16 Exam</a><li><a href='W17 Exan.html'>W17 Exan</a></li></ul><li><a href='Project.html'>Project</a></li></ul><li class='has-children'><a href='Reference.html'>Reference</a><ul class='dropdown'><li><a href='Documentary.html'>Documentary</a><li><a href='Ebooks.html'>Ebooks</a><li class='has-children'><a href='Planar Linkage.html'>Planar Linkage</a><ul class='dropdown'><li><a href='Design of Machinary.html'>Design of Machinary</a><li><a href='Graph Grammar.html'>Graph Grammar</a><li><a href='PMKS.html'>PMKS</a></li></ul><li><a href='Robotics Lib.html'>Robotics Lib</a><li><a href='CAD2CAE.html'>CAD2CAE</a></li>
                      </ul>
                </nav>
              </div>
              <div class="d-inline-block d-xl-none ml-md-0 mr-auto py-3" style="position: relative; top: 3px;"><a href="#" class="site-menu-toggle js-menu-toggle text-black"><span class="icon-menu h3"></span></a></div>
              </div>

            </div>
          </div>
          
        </header>
    <div id="tipue_search_content">Design Theory << <a href='Design Theory.html'>Previous</a> <a href='Cloud MCAD.html'>Next</a> >> Cloud MCAD<br /><h1>Optimal Design</h1>
<p>Mechanical Design Optimization Using Advanced Optimization Techniques</p>
<p><a href="https://link.springer.com/book/10.1007/978-1-4471-2748-2">https://link.springer.com/book/10.1007/978-1-4471-2748-2</a> </p>
<p>Optimization Methods for Engineering Design</p>
<p><a href="http://apmonitor.com/me575/uploads/Main/optimization_book.pdf">http://apmonitor.com/me575/uploads/Main/optimization_book.pdf</a>  or<span> </span><a href="http://mde.tw/cadp2018/downloads/optimization_book.pdf">local</a></p>
<p><a href="https://github.com/williamhunter/topy">https://github.com/williamhunter/topy</a> </p>
<p><a href="http://www.analyzemath.com/calculus.html#Calculus_Problems">http://www.analyzemath.com/calculus.html#Calculus_Problems</a></p>
<p>以<span> </span><a href="https://en.wikipedia.org/wiki/Differential_evolution">Differential Evolution</a><span> </span>algorithm 解題:</p>
<p>以總面積 80 cm^2 的鐵皮所能焊出最大容量的方形容器:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">// 必須在演算過程中, 設法限制各變數的上下限!
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;memory.h&gt;
#include &lt;time.h&gt;
  
// 最大族群數, NP
#define MAXPOP  5000
// 最大向量維度, D
#define MAXDIM  35
// MAXIMAPROBLEM =1 最大化 0 最小化
#define MAXIMAPROBLEM 1
// 最大化時 PENALITY 必須為負值, 否則為正值
#define PENALITY -1000
/*
#define MAXIMAPROBLEM 0
#define PENALITY 1000
*/
  
/*------Constants for rnd_uni()--------------------------------------------*/
  
#define IM1 2147483563
#define IM2 2147483399
#define AM (1.0/IM1)
#define IMM1 (IM1-1)
#define IA1 40014
#define IA2 40692
#define IQ1 53668
#define IQ2 52774
#define IR1 12211
#define IR2 3791
#define NTAB 32
#define NDIV (1+IMM1/NTAB)
#define EPS 1.2e-7
#define RNMX (1.0-EPS)
  
/*------------------------Globals---------------------------------------*/
  
long  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */
double c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];
double (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];
  
/*---------Function declarations----------------------------------------*/
  
void  assignd(int D, double a[], double b[]);
double rnd_uni(long *idum);    /* uniform pseudo random number generator */
double extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */
  
/*---------Function definitions-----------------------------------------*/
// 指定向量 b 為 a
void  assignd(int D, double a[], double b[])
{
   int j;
   for (j=0; j&lt;D; j++)
   {
      a[j] = b[j];
   }
}
  
// 產生 0 ~ 1 間的亂數
double rnd_uni(long *idum)
{
  long j;
  long k;
  static long idum2=123456789;
  static long iy=0;
  static long iv[NTAB];
  double temp;
  
  if (*idum &lt;= 0)
  {
    if (-(*idum) &lt; 1) *idum=1;
    else *idum = -(*idum);
    idum2=(*idum);
    for (j=NTAB+7;j&gt;=0;j--)
    {
      k=(*idum)/IQ1;
      *idum=IA1*(*idum-k*IQ1)-k*IR1;
      if (*idum &lt; 0) *idum += IM1;
      if (j &lt; NTAB) iv[j] = *idum;
    }
    iy=iv[0];
  }
  k=(*idum)/IQ1;
  *idum=IA1*(*idum-k*IQ1)-k*IR1;
  if (*idum &lt; 0) *idum += IM1;
  k=idum2/IQ2;
  idum2=IA2*(idum2-k*IQ2)-k*IR2;
  if (idum2 &lt; 0) idum2 += IM2;
  j=iy/NDIV;
  iy=iv[j]-idum2;
  iv[j] = *idum;
  if (iy &lt; 1) iy += IMM1;
  if ((temp=AM*iy) &gt; RNMX) return RNMX;
  else return temp;
  
}/*------End of rnd_uni()--------------------------*/
  
// 將上下限轉為全域變數
double inibound_h;      /* upper parameter bound              */
double inibound_l;      /* lower parameter bound              */
// 與機構合成相關的全域變數
// 宣告一個座標結構
struct Coord {
    double x;
    double y;
  // 這裡保留 double z;
};
  
main(int argc, char *argv[])
{
   char  chr;             /* y/n choice variable                */
   char  *strat[] =       /* strategy-indicator                 */
   {
            "",
            "DE/best/1/exp",
            "DE/rand/1/exp",
            "DE/rand-to-best/1/exp",
            "DE/best/2/exp",
            "DE/rand/2/exp",
            "DE/best/1/bin",
            "DE/rand/1/bin",
            "DE/rand-to-best/1/bin",
            "DE/best/2/bin",
            "DE/rand/2/bin"
   };
  
   int   i, j, L, n;      /* counting variables                 */
   int   r1, r2, r3, r4;  /* placeholders for random indexes    */
   int   r5;              /* placeholders for random indexes    */
   int   D;               /* Dimension of parameter vector      */
   int   NP;              /* number of population members       */
   int   imin;            /* index to member with lowest energy */
   int   refresh;         /* refresh rate of screen output      */
   int   strategy;        /* choice parameter for screen output */
   int   gen, genmax, seed;   
  
   long  nfeval;          /* number of function evaluations     */
  
   double trial_cost;      /* buffer variable                    */
   // 將上下限轉為全域變數, 可能要根據各變數加以設定
   //double inibound_h;      /* upper parameter bound              */
   //double inibound_l;      /* lower parameter bound              */
   double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */
   double cost[MAXPOP];    /* obj. funct. values                 */
   double cvar;            /* computes the cost variance         */
   double cmean;           /* mean cost                          */
   double F,CR;            /* control variables of DE            */
   double cmin;            /* help variables                     */
  
   FILE  *fpin_ptr;
   FILE  *fpout_ptr;
  
// 計算執行過程所需時間起點, 需要導入 time.h
  clock_t start = clock();
  
/*------Initializations----------------------------*/
  
// 將結果寫入 out.dat
 fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */
// 目前已經採用 strategy 3 可以得到最佳結果
  strategy = 3;
  genmax = 2000;
  refresh = 100;
  // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 5 個通過點角度值
  D = 2;
  NP = 200;
  inibound_h = 50.;
  inibound_l = 0.;
/*得到最佳解
  F = 0.85;
CR 必須介於 0 to 1. 之間
  CR = 1.;
*/
  F = 0.85;
  CR = 1.;
  seed = 3;
  
 //fclose(fpin_ptr);
  
/*-----Checking input variables for proper range----------------------------*/
  
  if (D &gt; MAXDIM)
  {
     printf("\nError! D=%d &gt; MAXDIM=%d\n",D,MAXDIM);
     exit(1);
  }
  if (D &lt;= 0)
  {
     printf("\nError! D=%d, should be &gt; 0\n",D);
     exit(1);
  }
  if (NP &gt; MAXPOP)
  {
     printf("\nError! NP=%d &gt; MAXPOP=%d\n",NP,MAXPOP);
     exit(1);
  }
  if (NP &lt;= 0)
  {
     printf("\nError! NP=%d, should be &gt; 0\n",NP);
     exit(1);
  }
  if ((CR &lt; 0) || (CR &gt; 1.0))
  {
     printf("\nError! CR=%f, should be ex [0,1]\n",CR);
     exit(1);
  }
  if (seed &lt;= 0)
  {
     printf("\nError! seed=%d, should be &gt; 0\n",seed);
     exit(1);
  }
  if (refresh &lt;= 0)
  {
     printf("\nError! refresh=%d, should be &gt; 0\n",refresh);
     exit(1);
  }
  if (genmax &lt;= 0)
  {
     printf("\nError! genmax=%d, should be &gt; 0\n",genmax);
     exit(1);
  }
  if ((strategy &lt; 0) || (strategy &gt; 10))
  {
     printf("\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\n",strategy);
     exit(1);
  }
  if (inibound_h &lt; inibound_l)
  {
     printf("\nError! inibound_h=%f &lt; inibound_l=%f\n",inibound_h, inibound_l);
     exit(1);
  }
  
/*-----Initialize random number generator-----------------------------*/
  
 rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */
 nfeval       =  0;  /* reset number of function evaluations */
  
/*------Initialization------------------------------------------------*/
/*------Right now this part is kept fairly simple and just generates--*/
/*------random numbers in the range [-initfac, +initfac]. You might---*/
/*------want to extend the init part such that you can initialize-----*/
/*------each parameter separately.------------------------------------*/
  
   for (i=0; i&lt;NP; i++)
   {
      for (j=0; j&lt;D; j++) /* spread initial population members */
      {
        c[i][j] = inibound_l + rnd_uni(&amp;rnd_uni_init)*(inibound_h - inibound_l);
      }
      cost[i] = evaluate(D,c[i],&amp;nfeval); /* obj. funct. value */
   }
   cmin = cost[0];
   imin = 0;
   for (i=1; i&lt;NP; i++)
   {
     if(MAXIMAPROBLEM == 1)
     {
       // 改為最大化
        if (cost[i]&gt;cmin)
        {
          cmin = cost[i];
          imin = i;
        }
      }
      else
      {
        // 最小化問題
        if (cost[i]&lt;cmin)
        {
          cmin = cost[i];
          imin = i;
        }
      }
   }
  
   assignd(D,best,c[imin]);            /* save best member ever          */
   assignd(D,bestit,c[imin]);          /* save best member of generation */
  
   pold = &amp;c; /* old population (generation G)   */
   pnew = &amp;d; /* new population (generation G+1) */
  
/*=======================================================================*/
/*=========Iteration loop================================================*/
/*=======================================================================*/
  
   gen = 0;                          /* generation counter reset */
   while ((gen &lt; genmax) /*&amp;&amp; (kbhit() == 0)*/) /* remove comments if conio.h */
   {                                            /* is accepted by compiler    */
      gen++;
      imin = 0;
  
      for (i=0; i&lt;NP; i++)         /* Start of loop through ensemble  */
      {
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 2 !!!     */
       r1 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while(r1==i);            
  
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 3 !!!     */
       r2 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r2==i) || (r2==r1));
  
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 4 !!!     */
       r3 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r3==i) || (r3==r1) || (r3==r2));
  
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 5 !!!     */
       r4 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));
  
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 6 !!!     */
       r5 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));
  
/*=======EXPONENTIAL CROSSOVER============================================================*/
  
/*-------DE/best/1/exp--------------------------------------------------------------------*/
/*-------Our oldest strategy but still not bad. However, we have found several------------*/
/*-------optimization problems where misconvergence occurs.-------------------------------*/
     if (strategy == 1) /* strategy DE0 (not in our paper) */
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D);
       L = 0;
       do
       {                       
         tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/rand/1/exp-------------------------------------------------------------------*/
/*-------This is one of my favourite strategies. It works especially well when the-------*/
/*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/
/*-------as a first guess.---------------------------------------------------------------*/
     else if (strategy == 2) /* strategy DE1 in the techreport */
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D);
       L = 0;
       do
       {                       
         tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/
/*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/
/*-------If you get misconvergence try to increase NP. If this doesn't help you----------*/
/*-------should play around with all three control variables.----------------------------*/
     else if (strategy == 3) /* similiar to DE2 but generally better */
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
       L = 0;
       do
       {                       
         tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/
     else if (strategy == 4)
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
       L = 0;
       do
       {                           
         tmp[n] = bestit[n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/
     else if (strategy == 5)
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
       L = 0;
       do
       {                           
         tmp[n] = (*pold)[r5][n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
  
/*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/
  
/*-------DE/best/1/bin--------------------------------------------------------------------*/
     else if (strategy == 6) 
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         }
         n = (n+1)%D;
           }
     }
/*-------DE/rand/1/bin-------------------------------------------------------------------*/
     else if (strategy == 7) 
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         }
         n = (n+1)%D;
           }
     }
/*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/
     else if (strategy == 8) 
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
         }
         n = (n+1)%D;
           }
     }
/*-------DE/best/2/bin--------------------------------------------------------------------*/
     else if (strategy == 9)
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = bestit[n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         }
         n = (n+1)%D;
           }
     }
/*-------DE/rand/2/bin--------------------------------------------------------------------*/
     else
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = (*pold)[r5][n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         }
         n = (n+1)%D;
           }
     }
  
  
/*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/
  
     trial_cost = evaluate(D,tmp,&amp;nfeval);  /* Evaluate new vector in tmp[] */
   if(MAXIMAPROBLEM == 1)
   {
    // 改為最大化
       if (trial_cost &gt;= cost[i])   /* improved objective function value ? */
       {                                  
          cost[i]=trial_cost;         
          assignd(D,(*pnew)[i],tmp);
          if (trial_cost&gt;cmin)          /* Was this a new minimum? */
          {                               /* if so...*/
             cmin=trial_cost;           /* reset cmin to new low...*/
             imin=i;
             assignd(D,best,tmp);           
          }                           
       }                            
       else
       {
          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
       }
    }
    else
    {
          // 最小化問題
       if (trial_cost &lt;= cost[i])   /* improved objective function value ? */
       {                                  
          cost[i]=trial_cost;         
          assignd(D,(*pnew)[i],tmp);
          if (trial_cost&lt;cmin)          /* Was this a new minimum? */
          {                               /* if so...*/
             cmin=trial_cost;           /* reset cmin to new low...*/
             imin=i;
             assignd(D,best,tmp);           
          }                           
       }                            
       else
       {
          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
       }
    }
  
      }   /* End mutation loop through pop. */
  
      assignd(D,bestit,best);  /* Save best population member of current iteration */
  
      /* swap population arrays. New generation becomes old one */
  
      pswap = pold;
      pold  = pnew;
      pnew  = pswap;
  
/*----Compute the energy variance (just for monitoring purposes)-----------*/
  
      cmean = 0.;          /* compute the mean value first */
      for (j=0; j&lt;NP; j++)
      {
         cmean += cost[j];
      }
      cmean = cmean/NP;
  
      cvar = 0.;           /* now the variance              */
      for (j=0; j&lt;NP; j++)
      {
         cvar += (cost[j] - cmean)*(cost[j] - cmean);
      }
      cvar = cvar/(NP-1);
  
  
/*----Output part----------------------------------------------------------*/
  
      if (gen%refresh==1)   /* display after every refresh generations */
      { /* ABORT works only if conio.h is accepted by your compiler */
    printf("\n\n                         PRESS ANY KEY TO ABORT"); 
    printf("\n\n\n Best-so-far cost funct. value=%-15.10g\n",cmin);
  
    for (j=0;j&lt;D;j++)
    {
      printf("\n best[%d]=%-15.10g",j,best[j]);
    }
    printf("\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
    printf("\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\n",
               NP,F,CR,cvar);
      }
  
      fprintf(fpout_ptr,"%ld   %-15.10g\n",nfeval,cmin);
   }
/*=======================================================================*/
/*=========End of iteration loop=========================================*/
/*=======================================================================*/
  
/*-------Final output in file-------------------------------------------*/
  
  
   fprintf(fpout_ptr,"\n\n\n Best-so-far obj. funct. value = %-15.10g\n",cmin);
  
   for (j=0;j&lt;D;j++)
   {
     fprintf(fpout_ptr,"\n best[%d]=%-15.10g",j,best[j]);
   }
   fprintf(fpout_ptr,"\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
   fprintf(fpout_ptr,"\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\n",
           NP,F,CR,cvar); 
  
  fclose(fpout_ptr);
  
  /* Code you want timed here */
  printf("Time elapsed: %f\n", ((double)clock() - start) / CLOCKS_PER_SEC);
   return(0);
}
  
/*-----------End of main()------------------------------------------*/
  
// 適應函式 fittness function (cost function)
double evaluate(int D, double tmp[], long *nfeval)
{
   double result=0, surface = 80.0, z, volume, penality;
   (*nfeval)++;
   z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));
   volume = tmp[0]*tmp[1]*z;
  
  if(volume &lt;= 0){
    return PENALITY;
  }
// 只限制長度與寬度必須大於 0
  if(tmp[0] &lt;= inibound_l){
    return PENALITY;
  }
  
  if(tmp[1] &lt;= inibound_l){
    return PENALITY;
  }
/*
  if((tmp[0] &lt;= inibound_l)|| (tmp[0] &gt;inibound_h)){
    return PENALITY;
  }
  
  if((tmp[1] &lt;= inibound_l) || (tmp[1] &gt;inibound_h)){
    return PENALITY;
  }
  */
  // volume must &gt;0 and max volume
  // 目前為最小化問題
   //return 1+1/(volume*volume);
  return volume;
}</pre>
<p><span>Python </span><a href="https://en.wikipedia.org/wiki/Differential_evolution">Differential Evolution</a><span><span> </span>algorithm:</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import random
 
class Chromosome(object):
 
    """
    just copy the idea of genetic algorithm, pretty similar..
    """
    def __init__(self, n):
        """
        int n, dimension of question
        """
        # dimension
        self.n = n
        # the gene
        self.v = [0] * n
        # the fitness value
        self.f = 0
 
    def assign(self, obj):
        """
        Chromosome obj
 
        copy all attribute from obj to itself
        """
        self.n = obj.n
        self.v = obj.v[:]
        self.f = obj.f
 
 
class DiffertialEvolution(object):
 
    def __init__(self,Func, pType, strategy, D, NP, F, CR, lower, upper, maxGen, report):
        # if pType = 1 it is maximization  otherwise is minimization problem
        self.pType = pType
        # strategy 1~10, choice what strategy to generate new member in temporary
        self.strategy = strategy
        # dimesion of quesiton
        self.D = D
        # population size
        # To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence
        self.NP = NP
        # weight factor
        # F is usually between 0.5 and 1 (in rare cases &gt; 1)
        self.F = F
        # crossover possible
        # CR in [0,1]
        self.CR = CR
        # lower bound array
        self.lb = lower[:]
        # upper bound array
        self.ub = upper[:]
        # maximum generation
        self.maxGen = maxGen
        # how many generation report once
        self.rpt = report
        # object function, or enviorment
        self.f = Func
        # check parameter is set properly
        self.checkParameter()
 
        # generation pool, depend on population size
        self.pop = [Chromosome(D) for i in range(NP)]
        # last generation best member
        self.lastgenbest = Chromosome(D)
        # current best member
        self.currentbest = Chromosome(D)
        # the generation count
        self.gen = 0
        # the vector
        self.r1 = 0
        self.r2 = 0
        self.r3 = 0
        self.r4 = 0
        self.r5 = 0
 
    def checkParameter(self):
        """
        check parameter is set properly
        """
        if (type(self.D) is not int) and self.D &lt;= 0:
            raise Exception('D shoud be integer and larger than 0')
        if (type(self.NP) is not int) and self.NP &lt;= 0:
            raise Exception('NP shoud be integer and larger than 0')
        if self.CR &lt; 0 or self.CR &gt; 1:
            raise Exception('CR should be [0,1]')
        if self.maxGen &lt;= 0:
            raise Exception('generation should larger than 0')
        if self.rpt &lt;= 0 or self.rpt &gt; self.maxGen:
            raise Exception('report should be larger than 0 and less than max genration')
        if self.strategy &lt; 1 or self.strategy &gt; 10:
            raise Exception('strategy should be [1,10]')
        for lower, upper in zip(self.lb, self.ub):
            if lower &gt; upper:
                raise Exception('upper bound should be larger than lower bound')
 
    def init(self):
        """
        init population
        """
        for i in range(self.NP):
            for j in range(self.D):
                self.pop[i].v[j] = self.lb[j] + random.random()*(self.ub[j] - self.lb[j])
            self.pop[i].f = self.evalute(self.pop[i])
 
    def evalute(self, p):
        """
        evalute the member in enviorment
        """
        return self.f(p.v)
 
    def findBest(self):
        """
        find member that have minimum fitness value from pool
        """
        if self.pType == 1:
            return max(self.pop, key=lambda chrom:chrom.f)
        else:
            return min(self.pop, key=lambda chrom:chrom.f)
 
    def generateRandomVector(self, i):
        """
        generate new vector
        """
        while True:
            self.r1 = int(random.random() * self.NP)
            if not (self.r1 == i):
                break
 
        while True:
            self.r2 = int(random.random() * self.NP)
            if not ((self.r2 == i) or (self.r2 == self.r1)):
                break
 
        while True:
            self.r3 = int(random.random() * self.NP)
            if not ((self.r3 == i) or (self.r3 == self.r1) or (self.r3 == self.r2)):
                break
 
        while True:
            self.r4 = int(random.random() * self.NP)
            if not ((self.r4 == i) or (self.r4 == self.r1) or (self.r4 == self.r2) or (self.r4 == self.r3)):
                break
 
        while True:
            self.r5 = int(random.random() * self.NP)
            if not ((self.r5 == i) or (self.r5 == self.r1) or (self.r5 == self.r2) or (self.r5 == self.r3) or (self.r5 == self.r4)):
                break
 
    def recombination(self, i):
        """
        use new vector, recombination the new one member to tmp
        """
        tmp = Chromosome(self.D)
 
        if self.strategy == 1:
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            L = 0
            while True:
                tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
                n = (n + 1) % self.D
                L += 1
                if not ((random.random() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif self.strategy == 2:
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            L = 0
            while True:
                tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
                n = (n + 1) % self.D
                L += 1
                if not ((random.random() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 3):
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            L = 0
            while True:
                tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])
                n = (n + 1) % self.D
                L += 1
                if not ((random.random() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 4):
            tmp.assign(self.pop[i])
 
            n = int(random.random() * self.D)
 
            L = 0
            while True:
                tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
                n = (n + 1) % self.D
                L += 1
                if not ((random.random() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 5):
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            L = 0
            while True:
                tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
                n = (n + 1) % self.D
                L += 1
                if not ((random.random() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 6):
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            for L in range(self.D):
                if ((random.random() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
                n = (n + 1) % self.D
 
        elif (self.strategy == 7):
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            for L in range(self.D):
                if ((random.random() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
 
                n = (n + 1) % self.D
 
        elif (self.strategy == 8):
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            for L in range(self.D):
                if ((random.random() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])
 
                n = (n + 1) % self.D
 
        elif (self.strategy == 9):
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            for L in range(self.D):
                if ((random.random() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
 
                n = (n + 1) % self.D
 
        else:
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            for L in range(self.D):
                if ((random.random() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
                n = (n + 1) % self.D
        return tmp
 
    def report(self):
        """
        report current generation status
        """
        if self.gen == 0:
            print("DiffertialEvolution results - init pop")
        elif self.gen == self.maxGen:
            print("Final DiffertialEvolution results at", self.gen, "generations")
        else:
            print("DiffertialEvolution results after", self.gen, "generations")
        print("Function : %.6f" % (self.currentbest.f))
        for i, v in enumerate(self.currentbest.v, start=1):
            print("Var", i, ":", v)
 
    def overbound(self, member):
        """
        check the member's chromosome that is out of bound?
        """
        for i in range(self.D):
            if member.v[i] &gt; self.ub[i] or member.v[i] &lt; self.lb[i]:
                return True
        return False
 
    def run(self):
        """
        run the algorithm...
        """
        # initial step
        # generation 0
        self.gen = 0
        # init the member's chromsome
        self.init()
        # find the best one(smallest fitness value)
        tmp = self.findBest()
        # copy to lastgenbest
        self.lastgenbest.assign(tmp)
        # copy to currentbest
        self.currentbest.assign(tmp)
        # report status
        self.report()
        # end initial step
 
        # the evolution journey is beggin...
        for self.gen in range(1, self.maxGen + 1):
            for i in range(self.NP):
                # generate new vector
                self.generateRandomVector(i)
                # use the vector recombine the member to temporary
                tmp = self.recombination(i)
                # check the one is out of bound?
                if self.overbound(tmp):
                    # if it is, then ignore
                    continue
                # is not out of bound, that mean it's quilify of enviorment
                # then evalute the one
                tmp.f = self.evalute(tmp)
                # if temporary one is better than origin(fitness value is larger or smaller)
                # pType is 1, the problem is maximization type
                if self.pType == 1:
                    if tmp.f &gt;= self.pop[i].f:
                        # copy the temporary one to origin member
                        self.pop[i].assign(tmp)
                        # check the temporary one is better than the currentbest
                        if tmp.f &gt; self.currentbest.f:
                            # copy the temporary one to currentbest
                            self.currentbest.assign(tmp)
                else:
                    if tmp.f &lt;= self.pop[i].f:
                        # copy the temporary one to origin member
                        self.pop[i].assign(tmp)
                        # check the temporary one is better than the currentbest
                        if tmp.f &lt; self.currentbest.f:
                            # copy the temporary one to currentbest
                            self.currentbest.assign(tmp)
            # copy the currentbest to lastgenbest
            self.lastgenbest.assign(self.currentbest)
            # if report generation is set, report
            if self.rpt != 0:
                if self.gen % self.rpt == 0:
                    self.report()
        # the evolution journey is done, report the final status
        self.report()
 
#fittness function (cost function)
def evaluate(designVariablel):
    surface = 80.0
    # if pType is 1, the penality is negative (maximization problem)
    # if pType is 0, the penality is positive (minimization problem)
    penality = -1000
 
    z = (surface-designVariablel[0]*designVariablel[1])/(2.0*(designVariablel[0]\
         +designVariablel[1]))
    volume = designVariablel[0]*designVariablel[1]*z
   
    if(volume &lt;= 0):
        return penality
 
    # box length and width need to be larger than 0
    if(designVariablel[0] &lt;= 0):
        return penality
 
    if(designVariablel[1] &lt;= 0):
        return penality
    return volume
#volume = DiffertialEvolution((self,Func, max, strategy, D, NP, F, CR, lower, upper, maxGen, report)
volume = DiffertialEvolution(evaluate, 1, 3, 2, 100, 0.6, 0.85, [0, 0], [50, 50], 100, 10)
volume.run()</pre>
<p><span>為了提升運算速度, 將上述 Python 程式轉為 <a href="https://cython.org/">Cython</a> 格式:</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#import random
from cpython cimport bool
#from array import array
import numpy as np
cimport numpy as np
from libc.stdlib cimport rand, RAND_MAX, srand
from libc.time cimport time
 
# make true it is random everytime
srand(time(NULL))
 
cdef double randV():
    return rand()*1.0 / RAND_MAX
 
cdef class Chromosome(object):
    """
    just copy the idea of genetic algorithm, pretty similar..
    """
    cdef public int n
    cdef public double f
    cdef public np.ndarray v
 
    def __cinit__(self, int n):
        """
        int n, dimension of question
        """
        # dimension
        self.n = n
        # the gene
        self.v = np.zeros(n)
        # the fitness value
        self.f = 0
 
    def assign(self, Chromosome obj):
        """
        Chromosome obj
        copy all attribute from obj to itself
        """
        self.n = obj.n
        self.v[:] = obj.v
        self.f = obj.f
 
 
cdef class DiffertialEvolution(object):
 
    cdef:
        int strategy, D, NP, maxGen, rpt, gen, r1, r2, r3, r4, r5
        double F, CR
        np.ndarray lb, ub, pop
        object f
        Chromosome lastgenbest, currentbest
 
    def __cinit__(self, object Func, int strategy, int D, int NP, double F, double CR, object lower, object upper, int maxGen, int report):
        # strategy 1~10, choice what strategy to generate new member in temporary
        self.strategy = strategy
        # dimesion of quesiton
        self.D = D
        # population size
        # To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence
        self.NP = NP
        # weight factor
        # F is usually between 0.5 and 1 (in rare cases &gt; 1)
        self.F = F
        # crossover possible
        # CR in [0,1]
        self.CR = CR
        # low bound
        self.lb = np.array(lower[:])
        # up bound
        self.ub = np.array(upper[:])
        # maximum generation
        self.maxGen = maxGen
        # how many generation report once
        self.rpt = report
        # object function, or enviorment
        self.f = Func
        # check parameter is set properly
        self.checkParameter()
 
        # generation pool, depend on population size
        #self.pop = [Chromosome(self.D) for i in range(self.NP)]
        self.pop = np.ndarray((NP,),dtype=np.object)
        for i in range(NP):
            self.pop[i] = Chromosome(self.D)
        # last generation best member
        self.lastgenbest = Chromosome(D)
        # current best member
        self.currentbest = Chromosome(D)
        # the generation count
        self.gen = 0
        # the vector
        self.r1 = 0
        self.r2 = 0
        self.r3 = 0
        self.r4 = 0
        self.r5 = 0
 
    cdef void checkParameter(self):
        """
        check parameter is set properly
        """
        if (type(self.D) is not int) and self.D &lt;= 0:
            raise Exception('D shoud be integer and larger than 0')
        if (type(self.NP) is not int) and self.NP &lt;= 0:
            raise Exception('NP shoud be integer and larger than 0')
        if self.CR &lt; 0 or self.CR &gt; 1:
            raise Exception('CR should be [0,1]')
        if self.maxGen &lt;= 0:
            raise Exception('generation should larger than 0')
        if self.rpt &lt;= 0 or self.rpt &gt; self.maxGen:
            raise Exception('report should be larger than 0 and less than max genration')
        if self.strategy &lt; 1 or self.strategy &gt; 10:
            raise Exception('strategy should be [1,10]')
        for lower, upper in zip(self.lb, self.ub):
            if lower &gt; upper:
                raise Exception('upper bound should be larger than lower bound')
 
    cdef void init(self):
        """
        init population
        """
        cdef int i, j
 
        for i in range(self.NP):
            for j in range(self.D):
                self.pop[i].v[j] = self.lb[j] + randV()*(self.ub[j] - self.lb[j])
            self.pop[i].f = self.evalute(self.pop[i])
 
    cdef double evalute(self, Chromosome member):
        """
        evalute the member in enviorment
        """
        return self.f(member.v)
 
    cdef Chromosome findBest(self):
        """
        find member that have minimum fitness value from pool
        """
        return min(self.pop, key=lambda chrom:chrom.f)
 
    cdef void generateRandomVector(self, i):
        """
        generate new vector
        """
        while True:
            self.r1 = int(randV() * self.NP)
            if not (self.r1 == i):
                break
 
        while True:
            self.r2 = int(randV() * self.NP)
            if not ((self.r2 == i) or (self.r2 == self.r1)):
                break
 
        while True:
            self.r3 = int(randV() * self.NP)
            if not ((self.r3 == i) or (self.r3 == self.r1) or (self.r3 == self.r2)):
                break
 
        while True:
            self.r4 = int(randV() * self.NP)
            if not ((self.r4 == i) or (self.r4 == self.r1) or (self.r4 == self.r2) or (self.r4 == self.r3)):
                break
 
        while True:
            self.r5 = int(randV() * self.NP)
            if not ((self.r5 == i) or (self.r5 == self.r1) or (self.r5 == self.r2) or (self.r5 == self.r3) or (self.r5 == self.r4)):
                break
 
    cdef Chromosome recombination(self, int i):
        """
        use new vector, recombination the new one member to tmp
        """
        cdef Chromosome tmp
        cdef int n, L
 
        tmp = Chromosome(self.D)
 
        if self.strategy == 1:
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            L = 0
            while True:
                tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
                n = (n + 1) % self.D
                L += 1
                if not ((randV() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif self.strategy == 2:
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            L = 0
            while True:
                tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
                n = (n + 1) % self.D
                L += 1
                if not ((randV() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 3):
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            L = 0
            while True:
                tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])
                n = (n + 1) % self.D
                L += 1
                if not ((randV() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 4):
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            L = 0
            while True:
                tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
                n = (n + 1) % self.D
                L += 1
                if not ((randV() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 5):
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            L = 0
            while True:
                tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
                n = (n + 1) % self.D
                L += 1
                if not ((randV() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 6):
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            for L in range(self.D):
                if ((randV() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
                n = (n + 1) % self.D
 
        elif (self.strategy == 7):
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            for L in range(self.D):
                if ((randV() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
                n = (n + 1) % self.D
 
        elif (self.strategy == 8):
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            for L in range(self.D):
                if ((randV() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])
                n = (n + 1) % self.D
 
        elif (self.strategy == 9):
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            for L in range(self.D):
                if ((randV() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
                n = (n + 1) % self.D
 
        else:
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            for L in range(self.D):
                if ((randV() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
                n = (n + 1) % self.D
        return tmp
 
    cdef void report(self):
        """
        report current generation status
        """
        cdef int i
        cdef double v
 
        if self.gen == 0:
            print("DiffertialEvolution results - init pop")
        elif self.gen == self.maxGen:
            print("Final DiffertialEvolution results at %d generations"%(self.gen,))
        else:
            print("DiffertialEvolution results after %d generations"%(self.gen,))
        print("Function : %.6f" % (self.currentbest.f))
        for i, v in enumerate(self.currentbest.v.flat, start=1):
            print("Var %d : %.4f"%(i, v))
 
    cdef bool overbound(self, Chromosome member):
        """
        check the member's chromosome that is out of bound?
        """
        cdef int i
 
        for i in range(self.D):
            if member.v[i] &gt; self.ub[i] or member.v[i] &lt; self.lb[i]:
                return True
        return False
 
    cdef void run(self):
        """
        run the algorithm...
        """
        cdef Chromosome tmp
        cdef int i
 
        # initial step
        # generation 0
        self.gen = 0
        # init the member's chromsome
        self.init()
        # find the best one(smallest fitness value)
        tmp = self.findBest()
        # copy to lastgenbest
        self.lastgenbest.assign(tmp)
        # copy to currentbest
        self.currentbest.assign(tmp)
        # report status
        self.report()
        # end initial step
 
        # the evolution journey is beggin...
        for self.gen in range(1, self.maxGen + 1):
            for i in range(self.NP):
                # generate new vector
                self.generateRandomVector(i)
                # use the vector recombine the member to temporary
                tmp = self.recombination(i)
                # check the one is out of bound?
                if self.overbound(tmp):
                    # if it is, then abandon it
                    continue
                # is not out of bound, that mean it's quilify of enviorment
                # then evalute the one
                tmp.f = self.evalute(tmp)
                # if temporary one is better than origin(fitness value is smaller)
                if tmp.f &lt;= self.pop[i].f:
                    # copy the temporary one to origin member
                    self.pop[i].assign(tmp)
                    # check the temporary one is better than the currentbest
                    if tmp.f &lt; self.currentbest.f:
                        # copy the temporary one to currentbest
                        self.currentbest.assign(tmp)
            # copy the currentbest to lastgenbest
            self.lastgenbest.assign(self.currentbest)
            # if report generation is set, report
            if self.rpt != 0:
                if self.gen % self.rpt == 0:
                    self.report()
        # the evolution journey is done, report the final status
        self.report()</pre>
<p><span>使用 Real-coded Genetic algorithm 解題:</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import time
import math
 
 
class Chromosome(object):
 
    def __init__(self, n=None):
        self.np = n if n &gt; 0 else 2
        self.f = 0.0
        self.v = [0.0] * n
 
    def cp(self, obj):
        """
        copy all atribute from another chromsome object
        """
        self.np = obj.np
        self.f = obj.f
        self.v = obj.v[:]
 
    def get_v(self, i):
        return self.v[i]
 
    def is_self(self, obj):
        """
        check the object is self?
        """
        return obj is self
 
    def assign(self, obj):
        if not self.is_self(obj):
            self.cp(obj)
 
 
class Genetic(object):
 
    def __init__(self, func, pType, nParm, nPop, pCross, pMute, pWin, bDelta, upper, lower):
        """
        init(function func)
        """
        self.func=func
        self.pType = pType
        self.nParm=nParm
        self.nPop=nPop
        self.pCross=pCross
        self.pMute=pMute
        self.pWin=pWin
        self.bDelta=bDelta
 
        self.chrom = [Chromosome(nParm) for i in range(nPop)]
        self.newChrom = [Chromosome(nParm) for i in range(nPop)]
        self.babyChrom = [Chromosome(nParm) for i in range(3)]
        self.chromElite = [Chromosome(nParm)]
        self.chromBest = [Chromosome(nParm)]
        self.maxLimit = upper[:]
        self.minLimit = lower[:]
 
        self.maxGen = None
        self.gen = None
 
        self.seed = 0.0
        self.iseed = 470211272.0
        self.mask = 2147483647
 
    def check(self, i, v):
        """
        If a variable is out of bound,
        replace it with a random value
        """
        if (v &gt; self.maxLimit[i]) or (v &lt; self.minLimit[i]):
            return self.randVal(self.minLimit[i], self.maxLimit[i])
        return v
 
    def crossOver(self):
        for i in range(0, self.nPop-1, 2):
            # crossover
            if(self.rnd() &lt; self.pCross):
                for s in range(self.nParm):
                    # first baby, half father half mother
                    self.babyChrom[0].v[s] = 0.5 * self.chrom[i].v[s] + 0.5*self.chrom[i+1].v[s];
                    # second baby, three quaters of fater and quater of mother
                    self.babyChrom[1].v[s] = self.check(s, 1.5 * self.chrom[i].v[s] - 0.5*self.chrom[i+1].v[s])
                    # third baby, quater of fater and three quaters of mother
                    self.babyChrom[2].v[s] = self.check(s,-0.5 * self.chrom[i].v[s] + 1.5*self.chrom[i+1].v[s]);
 
                for j in range(3):
                    self.babyChrom[j].f = self.func(self.babyChrom[j].v)
                # maximization
                if self.pType == 1:
                     
                    if self.babyChrom[1].f &gt; self.babyChrom[0].f:
                        self.babyChrom[0], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[0]
 
                    if self.babyChrom[2].f &gt; self.babyChrom[0].f:
                        self.babyChrom[2], self.babyChrom[0] = self.babyChrom[0], self.babyChrom[2]
 
                    if self.babyChrom[2].f &gt; self.babyChrom[1].f:
                        self.babyChrom[2], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[2]
 
                else:
                     
                    if self.babyChrom[1].f &lt; self.babyChrom[0].f:
                        self.babyChrom[0], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[0]
 
                    if self.babyChrom[2].f &lt; self.babyChrom[0].f:
                        self.babyChrom[2], self.babyChrom[0] = self.babyChrom[0], self.babyChrom[2]
 
                    if self.babyChrom[2].f &lt; self.babyChrom[1].f:
                        self.babyChrom[2], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[2]
 
                # replace first two baby to parent, another one will be
                self.chrom[i].assign(self.babyChrom[0])
                self.chrom[i+1].assign(self.babyChrom[1])
 
    def delta(self, y):
        r = float(self.gen) / self.maxGen;
        return y*self.rnd()*math.pow(1.0-r, self.bDelta)
 
    def fitness(self):
        for j in range(self.nPop):
            self.chrom[j].f = self.func(self.chrom[j].v)
 
        self.chromBest[0].assign(self.chrom[0])
 
        for j in range(self.nPop):
            if self.pType == 1:
                if(self.chrom[j].f &gt; self.chromBest[0].f):
                    self.chromBest[0].assign(self.chrom[j])
            else:
                if(self.chrom[j].f &lt; self.chromBest[0].f):
                    self.chromBest[0].assign(self.chrom[j])
        if self.pType == 1:
            if(self.chromBest[0].f &gt; self.chromElite[0].f):
                self.chromElite[0].assign(self.chromBest[0])
        else:
            if(self.chromBest[0].f &lt; self.chromElite[0].f):
                self.chromElite[0].assign(self.chromBest[0])
 
    def initialPop(self):
        for j in range(self.nPop):
            for i in range(self.nParm):
                self.chrom[j].v[i] = self.randVal(self.minLimit[i], self.maxLimit[i])
 
    def mutate(self):
        for i in range(self.nPop):
            if self.rnd() &lt; self.pMute:
                s = self.random(self.nParm)
                if (self.random(2) == 0):
                    self.chrom[i].v[s] += self.delta(self.maxLimit[s]-self.chrom[i].v[s])
                else:
                    self.chrom[i].v[s] -= self.delta(self.chrom[i].v[s]-self.minLimit[s])
 
    def report(self):
        if self.gen == 0:
            print("Genetik results - Initial population")
        elif self.gen == self.maxGen:
            print("Final Genetik results at", self.gen, "generations")
        else:
            print("Genetik results after", self.gen, "generations")
 
        print("Function : %.6f" % (self.chromElite[0].f))
        for i, p in enumerate(self.chromElite[0].v):
            print("Var", i+1, ":", p)
 
    def select(self):
        """
        roulette wheel selection
        """
        for i in range(self.nPop):
            j = self.random(self.nPop)
            k = self.random(self.nPop)
            self.newChrom[i].assign(self.chrom[j])
            if self.pType == 1:
                if(self.chrom[k].f &gt; self.chrom[j].f) and (self.rnd() &gt; self.pWin):
                    self.newChrom[i].assign(self.chrom[k])
            else:
                if(self.chrom[k].f &lt; self.chrom[j].f) and (self.rnd() &lt; self.pWin):
                    self.newChrom[i].assign(self.chrom[k])
        # in this stage, newChrom is select finish
        # now replace origin chrom
        for i in range(self.nPop):
            self.chrom[i].assign(self.newChrom[i])
 
        # select random one chrom to be best chrom, make best chrom still exist
        j = self.random(self.nPop);
        self.chrom[j].assign(self.chromElite[0])
 
    def run(self, mxg, rp):
        """
        // **** Init and run GA for maxGen times
        // **** mxg : maximum generation
        // **** rp  : report cycle, 0 for final report or
        // ****       report each mxg modulo rp
        """
        self.maxGen = mxg
        self.rpt = rp
 
        self.randomize()
        self.initialPop()
        self.chrom[0].f = self.func(self.chrom[0].v)
        self.chromElite[0].assign(self.chrom[0])
 
        self.gen = 0
        self.fitness()
        self.report()
 
        for self.gen in range(1, self.maxGen + 1):
            self.select()
            self.crossOver()
            self.mutate()
            self.fitness()
            if rp != 0:
                if self.gen % self.rpt == 0:
                    self.report()
        self.report()
 
    def newSeed(self):
        if(self.seed == 0.0):
            self.seed=self.iseed
        else:
            self.seed *= 16807.0
            self.seed = math.fmod(self.seed, self.mask)
 
    def rnd(self):
        self.newSeed()
        return self.seed/self.mask
 
    def randomize(self):
        self.seed = time.time()
 
    def random(self, k):
        return int(self.rnd()*k)
 
    def randVal(self, low, high):
        number_types = (int, float)
        if isinstance(low, number_types) and isinstance(high, number_types):
            return self.rnd()*(high-low)+low
        raise ValueError
         
#fittness function (cost function)
def evaluate(designVariablel):
    surface = 80.0
    # if pType is 1, the penality is negative (maximization problem)
    # if pType is 0, the penality is positive (minimization problem)
    penality = -1000
 
    z = (surface-designVariablel[0]*designVariablel[1])/(2.0*(designVariablel[0]\
         +designVariablel[1]))
    volume = designVariablel[0]*designVariablel[1]*z
   
    if(volume &lt;= 0):
        return penality
 
    # box length and width need to be larger than 0
    if(designVariablel[0] &lt;= 0):
        return penality
 
    if(designVariablel[1] &lt;= 0):
        return penality
    #return 1+1/(volume*volume)
    return volume
 
#volume = Genetic(self, func, pType, nParm, nPop, pCross, pMute, pWin, bDelta, upper, lower):
volume = Genetic(evaluate, 1, 2, 1000, 0.95, 0.05, 0.95, 5, [0, 0], [50, 50])
volume.run(1000, 50)</pre>
<p></p>
<br />Design Theory << <a href='Design Theory.html'>Previous</a> <a href='Cloud MCAD.html'>Next</a> >> Cloud MCAD</div>
        
    <!-- footer -->
      <div class="container">
        <div class="row pt-3 mx-auto">
            <p>
            <!-- Link back to Colorlib can't be removed. Template is licensed under CC BY 3.0. -->
            Copyright &copy;<script>document.write(new Date().getFullYear());</script> All rights reserved | This template is made with <i class="icon-heart" aria-hidden="true"></i> by <a href="https://colorlib.com" target="_blank" >Colorlib</a>
            <!-- Link back to Colorlib can't be removed. Template is licensed under CC BY 3.0. -->
            </p>
        </div>
      </div>
    <!-- for footer -->
    
        </div> <!-- for site wrap -->
            <!-- <script src="../cmsimde/static/chimper/js/jquery-3.3.1.min.js"></script> -->
            <script src="../cmsimde/static/chimper/js/jquery-migrate-3.0.1.min.js"></script>
            <script src="../cmsimde/static/chimper/js/jquery-ui.js"></script>
            <script src="../cmsimde/static/chimper/js/popper.min.js"></script>
            <script src="../cmsimde/static/chimper/js/bootstrap.min.js"></script>
            <script src="../cmsimde/static/chimper/js/owl.carousel.min.js"></script>
            <script src="../cmsimde/static/chimper/js/jquery.stellar.min.js"></script>
            <script src="../cmsimde/static/chimper/js/jquery.countdown.min.js"></script>
            <script src="../cmsimde/static/chimper/js/jquery.magnific-popup.min.js"></script>
            <script src="../cmsimde/static/chimper/js/bootstrap-datepicker.min.js"></script>
            <script src="../cmsimde/static/chimper/js/aos.js"></script>
            <!--
            <script src="../cmsimde/static/chimper/js/typed.js"></script>
                    <script>
                    var typed = new Typed('.typed-words', {
                    strings: ["Web Apps"," WordPress"," Mobile Apps"],
                    typeSpeed: 80,
                    backSpeed: 80,
                    backDelay: 4000,
                    startDelay: 1000,
                    loop: true,
                    showCursor: true
                    });
                    </script>
            -->
            <script src="../cmsimde/static/chimper/js/main.js"></script>
        </body></html>
        