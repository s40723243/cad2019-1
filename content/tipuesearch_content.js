var tipuesearch = {"pages": [{'title': 'About', 'text': '本電腦輔助機械設計實習課程, 除了教導學生使用電腦輔助設計套件 (  Solidworks ,  NX ) 中, 各種參數式 3D 零組件設計與繪圖功能外, 也導入開源的  Solvespace ,  FreeCAD ,  V-rep  與  Webots , 讓學員了解這些中高端套件的底層所包含的各種數學原理與程式技術. 並且透過實驗中的 網際 Solvespace , 以及全雲端  Onshape  的協同設計, 引領學員一窺未來全球協同產品開發流程可能呈現的架構與風貌. \n 電腦輔助設計實習課程承接計算機程式與網際內容管理課程, 並與協同產品設計實習採用相同工具與理念, 希望所有學員能夠在電腦軟硬體與網路系統的充分整合應用下, 有能力透過程式方法與網際內容管理的架構, 執行創新產品開發. \n 課程工具套件: \n 倉儲:\xa0 https://github.com/mdecourse/cad2019 \n 2019Fall可攜套件.7z \xa0(編譯\xa0 Solvespace 用) \n dartpad_based.7z \xa0(登入 @gm 帳號後下載) \n GitExtensions.7z \n FreeCAD 0.18.7z \n V-rep 3.6.1 rev 4.7z \n Webot 2019a.7z \n 登入 @gm 帳號後,  下載課程教學影片 \n 請登入 @gm 帳號後,\xa0 填寫選課學員基本資料 \n 電腦輔助設計室與協同設計室行事曆 \n 全頁檢視 \n \n 2019 Fall 學期教育目標: \n 使用可攜程式系統與網際內容管理系統, 管理各學員與分組學習內容, 同時利用  Solidworks ,  NX , \xa0 Onshape ,  Solvespace ,  FreeCAD ,  Webots \xa0 與 \xa0 V-rep \xa0 執行機電資整合產品開發, 當面臨各種電腦輔助機械設計階段所遭遇問題時, 各學員可利用客製化程式加以解決. \n Textbooks: \n 1) 2015- Space Modeling with SolidWorks and NX \n https://link.springer.com/book/10.1007/978-3-319-03862-9 \n 2) 2008- The Engineering Design Revolution \n The Engineering Design Revolution \xa0(a.k.a. cad_history.pdf) \n 達成學期教育目標之評量方式與標準: \n 評分比例  (包含學員自評、同組互評與教師評分等三項) : \n \n 請注意: \n \n 建議各學員針對課程所指定之作業或課題時, 務必先在個人網頁與網誌登錄相關搜尋結果, 初步完成之個人操作影片, 以及個人擬解決問題的想法後, 再參與分組討論與任務執行. \n 除第一週外, 每位組員必須在次週上課前完成個人倉儲的資料維護, 並至 課程評量表單 完成自評與同組組員互評. \n 任何課程相關問題可以至  Q&A  (需登入) 或 回饋表單  (無需登入) 提出. \n \n \n 學員出席 (10%) \n 個人倉儲與網站查驗 (20%) \n Task1: 參數式繪圖軟體 Solvespace 編譯、零組件繪圖與應用 (10%) \n Task2: MCAD 套件安裝與設定, 零組件繪圖、轉檔與 CAE 工程分析 (10%) \n Task3:\xa0 Rover 零組件轉入 \xa0 V-rep \xa0 與 \xa0 Webots \xa0 執行機電控制系統設計 (20%) \n Project:\xa0 機電資整合分組專案執行 (30%) \n 評分方式: \n 電腦輔助設計實習每週自評與互評表單:  https://forms.gle/raTtrfjv8cMMVSZd6 \xa0 \n 教學方式: \n 課堂講授 \n 操作錄影 \n 學員實習 \n 分組報告 \n 參考資料: \n https://open.umn.edu/opentextbooks/subjects/engineering \xa0', 'tags': '', 'url': 'About.html'}, {'title': 'Evaluation', 'text': "本課程經由第五、七與期中考週的學員自評與互評, 提供教師評量學員期中成績. \n 並依據第十四、十六與期末考週的學員自評與互評, 提供教師評量學員的期末成績. \n 電腦輔助設計實習每週自評與互評表單:\xa0 https://forms.gle/raTtrfjv8cMMVSZd6 \xa0 \n 課程計分流程: \n '''\n根據評分表單中的 自評分數, 互評得分, 教師評分, 計算學員課程成績\n'''\n \ndef diff(自評分數, 互評得分):\n    return abs(自評分數 - 互評得分)\n     \ndef max(自評分數, 互評得分):\n    if 自評分數 > 互評得分:\n        return 自評分數\n    else:\n        return 互評得分\n \ndef 分組比分(自評分數, 互評得分):\n    if diff(自評分數, 互評得分) < 5:\n        學員得分 = max(自評分數, 互評得分)\n    else:\n        學員得分 = 互評得分 - diff(自評分數, 互評得分)\n    return 學員得分\n     \ndef 全班比分(學員得分, 教師評分):\n    if diff(學員得分, 教師評分) < 5:\n        學員成績 = max(學員得分, 教師評分)\n    else:\n        學員成績 = 教師評分 - diff(學員得分, 教師評分)/4\n    return 學員成績\n \ndef 學員成績(自評分數, 互評得分, 教師評分):\n    學員分組得分 = 分組比分(自評分數, 互評得分)\n    學員課程成績 = 全班比分(學員分組得分, 教師評分)\n    return 學員課程成績\n     \nprint(學員成績(80, 70, 60))\nprint(學員成績(60, 70, 80)) \n 此一計分流程的 Dart 網際與手機版本將作為  cp2019  課程學員的分組練習之一.", 'tags': '', 'url': 'Evaluation.html'}, {'title': '課程表單', 'text': '本課程的學員自評與互評訂於第五、七、九、十四、十六與十八週上課時段之前完成. \n 電腦輔助設計實習每週自評與互評表單:\xa0 https://forms.gle/raTtrfjv8cMMVSZd6 \xa0(必須登入 @gm 帳號) \n 與課程相關的議題, 請利用下列 Github Issues 與 Google 表單填寫: \n 電腦輔助設計實習課程 Q and A  (需登入 Github 帳號) \n 課程反應表單  (無需登入 @gm 帳號) \n', 'tags': '', 'url': '課程表單.html'}, {'title': 'Theories', 'text': '以下所列為與課程相關的理論參考資料: \n Advanced CAD Modeling \n https://github.com/deadsy/sdfx \xa0 \n Solid Modeling and Applications \n Solid Modeling and CAD Systems \n http://mde.tw/cadp2018/downloads/intro_cad.pdf \n http://mde.tw/cadp2018/downloads/cadbook.pdf \xa0( CAD_Book.pdf ) \n 3D-Modelling-with-the-ACIS-Kernel-and-Toolkit.pdf \n http://mde.tw/cadp2018/downloads/mit_intro_cad.pdf \n http://mde.tw/cadp2018/downloads/robot_kinematics_and_dynamics.pdf \n http://mde.tw/cadp2018/downloads/Kinematics%20of%20Machines.pdf \n http://mde.tw/cadp2018/gears/Gear%20Drawing%20with%20Bezier%20Curves.pdf \n http://mde.tw/cadp2018/content/%E7%A8%8B%E5%BC%8F%E5%BA%AB%E7%AF%84%E4%BE%8B.html \n http://mde.tw/cadp2018/content/%E8%BC%94%E5%8A%A9%E8%A8%AD%E8%A8%88%E5%A5%97%E4%BB%B6.html \n http://mde.tw/cadp2018/downloads/intro_curves.pdf \n http://verbnurbs.com/ \xa0( https://github.com/pboyer/verb ) ( https://haxe.org/ ) \n https://pomax.github.io/bezierinfo/ \n https://github.com/bluecube/codecad \n https://github.com/DLR-SC/tigl \n Mechanical Design Report DARPA BOSS Program.pdf \n Coordinate_system_and_transformations.pdf \n Optimization.pdf \n Optimization_search.pdf \n Curves.pdf \n b-spline_examples.pdf \n CAD_Data_Exchange.pdf', 'tags': '', 'url': 'Theories.html'}, {'title': 'Design Theory', 'text': 'Computer-Based Design Synthesis Research - An Overview.pdf \n Implications of designer behavior for design synthesis tool interaction design.pdf \n A method based on C-K Theory for fast STCR development - The case of a drilling robot design.pdf \n Product Design and Development 2.0 Applied C-K theory -to innovate in a digital age.pdf \n IDEA GENERATION IN ENGINEERING DESIGN APPLICATION OF A MEMORY SEARCH PERSPECTIVE AND SOME EXPERIMENTAL STUDIES.pdf \n \n https://github.com/mdecourse/cd2018/issues/3 \n Design Theory - Methods and Organization for Innovation \n https://link.springer.com/book/10.1007/978-3-319-50277-9 \n Theory and Design of CNC Systems \n https://link.springer.com/book/10.1007/978-1-84800-336-1 \n An Anthology of Theories and Models of Design - Philosophy, Approaches and Empirical Explorations \n https://link.springer.com/book/10.1007/978-1-4471-6338-1 \n Control Systems Design - A New Framework \n https://link.springer.com/book/10.1007/1-84628-215-2', 'tags': '', 'url': 'Design Theory.html'}, {'title': 'Optimal Design', 'text': 'Mechanical Design Optimization Using Advanced Optimization Techniques \n https://link.springer.com/book/10.1007/978-1-4471-2748-2 \xa0 \n Optimization Methods for Engineering Design \n http://apmonitor.com/me575/uploads/Main/optimization_book.pdf \xa0\xa0or \xa0 local \n https://github.com/williamhunter/topy \xa0 \n http://www.analyzemath.com/calculus.html#Calculus_Problems \n 以 \xa0 Differential Evolution \xa0 algorithm 解題: \n 以總面積 80 cm^2 的鐵皮所能焊出最大容量的方形容器: \n // 必須在演算過程中, 設法限制各變數的上下限!\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <memory.h>\n#include <time.h>\n  \n// 最大族群數, NP\n#define MAXPOP  5000\n// 最大向量維度, D\n#define MAXDIM  35\n// MAXIMAPROBLEM =1 最大化 0 最小化\n#define MAXIMAPROBLEM 1\n// 最大化時 PENALITY 必須為負值, 否則為正值\n#define PENALITY -1000\n/*\n#define MAXIMAPROBLEM 0\n#define PENALITY 1000\n*/\n  \n/*------Constants for rnd_uni()--------------------------------------------*/\n  \n#define IM1 2147483563\n#define IM2 2147483399\n#define AM (1.0/IM1)\n#define IMM1 (IM1-1)\n#define IA1 40014\n#define IA2 40692\n#define IQ1 53668\n#define IQ2 52774\n#define IR1 12211\n#define IR2 3791\n#define NTAB 32\n#define NDIV (1+IMM1/NTAB)\n#define EPS 1.2e-7\n#define RNMX (1.0-EPS)\n  \n/*------------------------Globals---------------------------------------*/\n  \nlong  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */\ndouble c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];\ndouble (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];\n  \n/*---------Function declarations----------------------------------------*/\n  \nvoid  assignd(int D, double a[], double b[]);\ndouble rnd_uni(long *idum);    /* uniform pseudo random number generator */\ndouble extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */\n  \n/*---------Function definitions-----------------------------------------*/\n// 指定向量 b 為 a\nvoid  assignd(int D, double a[], double b[])\n{\n   int j;\n   for (j=0; j<D; j++)\n   {\n      a[j] = b[j];\n   }\n}\n  \n// 產生 0 ~ 1 間的亂數\ndouble rnd_uni(long *idum)\n{\n  long j;\n  long k;\n  static long idum2=123456789;\n  static long iy=0;\n  static long iv[NTAB];\n  double temp;\n  \n  if (*idum <= 0)\n  {\n    if (-(*idum) < 1) *idum=1;\n    else *idum = -(*idum);\n    idum2=(*idum);\n    for (j=NTAB+7;j>=0;j--)\n    {\n      k=(*idum)/IQ1;\n      *idum=IA1*(*idum-k*IQ1)-k*IR1;\n      if (*idum < 0) *idum += IM1;\n      if (j < NTAB) iv[j] = *idum;\n    }\n    iy=iv[0];\n  }\n  k=(*idum)/IQ1;\n  *idum=IA1*(*idum-k*IQ1)-k*IR1;\n  if (*idum < 0) *idum += IM1;\n  k=idum2/IQ2;\n  idum2=IA2*(idum2-k*IQ2)-k*IR2;\n  if (idum2 < 0) idum2 += IM2;\n  j=iy/NDIV;\n  iy=iv[j]-idum2;\n  iv[j] = *idum;\n  if (iy < 1) iy += IMM1;\n  if ((temp=AM*iy) > RNMX) return RNMX;\n  else return temp;\n  \n}/*------End of rnd_uni()--------------------------*/\n  \n// 將上下限轉為全域變數\ndouble inibound_h;      /* upper parameter bound              */\ndouble inibound_l;      /* lower parameter bound              */\n// 與機構合成相關的全域變數\n// 宣告一個座標結構\nstruct Coord {\n    double x;\n    double y;\n  // 這裡保留 double z;\n};\n  \nmain(int argc, char *argv[])\n{\n   char  chr;             /* y/n choice variable                */\n   char  *strat[] =       /* strategy-indicator                 */\n   {\n            "",\n            "DE/best/1/exp",\n            "DE/rand/1/exp",\n            "DE/rand-to-best/1/exp",\n            "DE/best/2/exp",\n            "DE/rand/2/exp",\n            "DE/best/1/bin",\n            "DE/rand/1/bin",\n            "DE/rand-to-best/1/bin",\n            "DE/best/2/bin",\n            "DE/rand/2/bin"\n   };\n  \n   int   i, j, L, n;      /* counting variables                 */\n   int   r1, r2, r3, r4;  /* placeholders for random indexes    */\n   int   r5;              /* placeholders for random indexes    */\n   int   D;               /* Dimension of parameter vector      */\n   int   NP;              /* number of population members       */\n   int   imin;            /* index to member with lowest energy */\n   int   refresh;         /* refresh rate of screen output      */\n   int   strategy;        /* choice parameter for screen output */\n   int   gen, genmax, seed;   \n  \n   long  nfeval;          /* number of function evaluations     */\n  \n   double trial_cost;      /* buffer variable                    */\n   // 將上下限轉為全域變數, 可能要根據各變數加以設定\n   //double inibound_h;      /* upper parameter bound              */\n   //double inibound_l;      /* lower parameter bound              */\n   double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */\n   double cost[MAXPOP];    /* obj. funct. values                 */\n   double cvar;            /* computes the cost variance         */\n   double cmean;           /* mean cost                          */\n   double F,CR;            /* control variables of DE            */\n   double cmin;            /* help variables                     */\n  \n   FILE  *fpin_ptr;\n   FILE  *fpout_ptr;\n  \n// 計算執行過程所需時間起點, 需要導入 time.h\n  clock_t start = clock();\n  \n/*------Initializations----------------------------*/\n  \n// 將結果寫入 out.dat\n fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */\n// 目前已經採用 strategy 3 可以得到最佳結果\n  strategy = 3;\n  genmax = 2000;\n  refresh = 100;\n  // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 5 個通過點角度值\n  D = 2;\n  NP = 200;\n  inibound_h = 50.;\n  inibound_l = 0.;\n/*得到最佳解\n  F = 0.85;\nCR 必須介於 0 to 1. 之間\n  CR = 1.;\n*/\n  F = 0.85;\n  CR = 1.;\n  seed = 3;\n  \n //fclose(fpin_ptr);\n  \n/*-----Checking input variables for proper range----------------------------*/\n  \n  if (D > MAXDIM)\n  {\n     printf("\\nError! D=%d > MAXDIM=%d\\n",D,MAXDIM);\n     exit(1);\n  }\n  if (D <= 0)\n  {\n     printf("\\nError! D=%d, should be > 0\\n",D);\n     exit(1);\n  }\n  if (NP > MAXPOP)\n  {\n     printf("\\nError! NP=%d > MAXPOP=%d\\n",NP,MAXPOP);\n     exit(1);\n  }\n  if (NP <= 0)\n  {\n     printf("\\nError! NP=%d, should be > 0\\n",NP);\n     exit(1);\n  }\n  if ((CR < 0) || (CR > 1.0))\n  {\n     printf("\\nError! CR=%f, should be ex [0,1]\\n",CR);\n     exit(1);\n  }\n  if (seed <= 0)\n  {\n     printf("\\nError! seed=%d, should be > 0\\n",seed);\n     exit(1);\n  }\n  if (refresh <= 0)\n  {\n     printf("\\nError! refresh=%d, should be > 0\\n",refresh);\n     exit(1);\n  }\n  if (genmax <= 0)\n  {\n     printf("\\nError! genmax=%d, should be > 0\\n",genmax);\n     exit(1);\n  }\n  if ((strategy < 0) || (strategy > 10))\n  {\n     printf("\\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\\n",strategy);\n     exit(1);\n  }\n  if (inibound_h < inibound_l)\n  {\n     printf("\\nError! inibound_h=%f < inibound_l=%f\\n",inibound_h, inibound_l);\n     exit(1);\n  }\n  \n/*-----Initialize random number generator-----------------------------*/\n  \n rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */\n nfeval       =  0;  /* reset number of function evaluations */\n  \n/*------Initialization------------------------------------------------*/\n/*------Right now this part is kept fairly simple and just generates--*/\n/*------random numbers in the range [-initfac, +initfac]. You might---*/\n/*------want to extend the init part such that you can initialize-----*/\n/*------each parameter separately.------------------------------------*/\n  \n   for (i=0; i<NP; i++)\n   {\n      for (j=0; j<D; j++) /* spread initial population members */\n      {\n        c[i][j] = inibound_l + rnd_uni(&rnd_uni_init)*(inibound_h - inibound_l);\n      }\n      cost[i] = evaluate(D,c[i],&nfeval); /* obj. funct. value */\n   }\n   cmin = cost[0];\n   imin = 0;\n   for (i=1; i<NP; i++)\n   {\n     if(MAXIMAPROBLEM == 1)\n     {\n       // 改為最大化\n        if (cost[i]>cmin)\n        {\n          cmin = cost[i];\n          imin = i;\n        }\n      }\n      else\n      {\n        // 最小化問題\n        if (cost[i]<cmin)\n        {\n          cmin = cost[i];\n          imin = i;\n        }\n      }\n   }\n  \n   assignd(D,best,c[imin]);            /* save best member ever          */\n   assignd(D,bestit,c[imin]);          /* save best member of generation */\n  \n   pold = &c; /* old population (generation G)   */\n   pnew = &d; /* new population (generation G+1) */\n  \n/*=======================================================================*/\n/*=========Iteration loop================================================*/\n/*=======================================================================*/\n  \n   gen = 0;                          /* generation counter reset */\n   while ((gen < genmax) /*&& (kbhit() == 0)*/) /* remove comments if conio.h */\n   {                                            /* is accepted by compiler    */\n      gen++;\n      imin = 0;\n  \n      for (i=0; i<NP; i++)         /* Start of loop through ensemble  */\n      {\n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 2 !!!     */\n       r1 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while(r1==i);            \n  \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 3 !!!     */\n       r2 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r2==i) || (r2==r1));\n  \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 4 !!!     */\n       r3 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r3==i) || (r3==r1) || (r3==r2));\n  \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 5 !!!     */\n       r4 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));\n  \n     do                        /* Pick a random population member */\n     {                         /* Endless loop for NP < 6 !!!     */\n       r5 = (int)(rnd_uni(&rnd_uni_init)*NP);\n     }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));\n  \n/*=======EXPONENTIAL CROSSOVER============================================================*/\n  \n/*-------DE/best/1/exp--------------------------------------------------------------------*/\n/*-------Our oldest strategy but still not bad. However, we have found several------------*/\n/*-------optimization problems where misconvergence occurs.-------------------------------*/\n     if (strategy == 1) /* strategy DE0 (not in our paper) */\n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D);\n       L = 0;\n       do\n       {                       \n         tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand/1/exp-------------------------------------------------------------------*/\n/*-------This is one of my favourite strategies. It works especially well when the-------*/\n/*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/\n/*-------as a first guess.---------------------------------------------------------------*/\n     else if (strategy == 2) /* strategy DE1 in the techreport */\n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D);\n       L = 0;\n       do\n       {                       \n         tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/\n/*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/\n/*-------If you get misconvergence try to increase NP. If this doesn\'t help you----------*/\n/*-------should play around with all three control variables.----------------------------*/\n     else if (strategy == 3) /* similiar to DE2 but generally better */\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                       \n         tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/\n     else if (strategy == 4)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                           \n         tmp[n] = bestit[n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n/*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/\n     else if (strategy == 5)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n       L = 0;\n       do\n       {                           \n         tmp[n] = (*pold)[r5][n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         n = (n+1)%D;\n         L++;\n       }while((rnd_uni(&rnd_uni_init) < CR) && (L < D));\n     }\n  \n/*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/\n  \n/*-------DE/best/1/bin--------------------------------------------------------------------*/\n     else if (strategy == 6) \n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand/1/bin-------------------------------------------------------------------*/\n     else if (strategy == 7) \n     {\n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/\n     else if (strategy == 8) \n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/best/2/bin--------------------------------------------------------------------*/\n     else if (strategy == 9)\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = bestit[n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         }\n         n = (n+1)%D;\n           }\n     }\n/*-------DE/rand/2/bin--------------------------------------------------------------------*/\n     else\n     { \n       assignd(D,tmp,(*pold)[i]);\n       n = (int)(rnd_uni(&rnd_uni_init)*D); \n           for (L=0; L<D; L++) /* perform D binomial trials */\n           {\n         if ((rnd_uni(&rnd_uni_init) < CR) || L == (D-1)) /* change at least one parameter */\n         {                       \n           tmp[n] = (*pold)[r5][n] + \n              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;\n         }\n         n = (n+1)%D;\n           }\n     }\n  \n  \n/*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/\n  \n     trial_cost = evaluate(D,tmp,&nfeval);  /* Evaluate new vector in tmp[] */\n   if(MAXIMAPROBLEM == 1)\n   {\n    // 改為最大化\n       if (trial_cost >= cost[i])   /* improved objective function value ? */\n       {                                  \n          cost[i]=trial_cost;         \n          assignd(D,(*pnew)[i],tmp);\n          if (trial_cost>cmin)          /* Was this a new minimum? */\n          {                               /* if so...*/\n             cmin=trial_cost;           /* reset cmin to new low...*/\n             imin=i;\n             assignd(D,best,tmp);           \n          }                           \n       }                            \n       else\n       {\n          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */\n       }\n    }\n    else\n    {\n          // 最小化問題\n       if (trial_cost <= cost[i])   /* improved objective function value ? */\n       {                                  \n          cost[i]=trial_cost;         \n          assignd(D,(*pnew)[i],tmp);\n          if (trial_cost<cmin)          /* Was this a new minimum? */\n          {                               /* if so...*/\n             cmin=trial_cost;           /* reset cmin to new low...*/\n             imin=i;\n             assignd(D,best,tmp);           \n          }                           \n       }                            \n       else\n       {\n          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */\n       }\n    }\n  \n      }   /* End mutation loop through pop. */\n  \n      assignd(D,bestit,best);  /* Save best population member of current iteration */\n  \n      /* swap population arrays. New generation becomes old one */\n  \n      pswap = pold;\n      pold  = pnew;\n      pnew  = pswap;\n  \n/*----Compute the energy variance (just for monitoring purposes)-----------*/\n  \n      cmean = 0.;          /* compute the mean value first */\n      for (j=0; j<NP; j++)\n      {\n         cmean += cost[j];\n      }\n      cmean = cmean/NP;\n  \n      cvar = 0.;           /* now the variance              */\n      for (j=0; j<NP; j++)\n      {\n         cvar += (cost[j] - cmean)*(cost[j] - cmean);\n      }\n      cvar = cvar/(NP-1);\n  \n  \n/*----Output part----------------------------------------------------------*/\n  \n      if (gen%refresh==1)   /* display after every refresh generations */\n      { /* ABORT works only if conio.h is accepted by your compiler */\n    printf("\\n\\n                         PRESS ANY KEY TO ABORT"); \n    printf("\\n\\n\\n Best-so-far cost funct. value=%-15.10g\\n",cmin);\n  \n    for (j=0;j<D;j++)\n    {\n      printf("\\n best[%d]=%-15.10g",j,best[j]);\n    }\n    printf("\\n\\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);\n    printf("\\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\\n",\n               NP,F,CR,cvar);\n      }\n  \n      fprintf(fpout_ptr,"%ld   %-15.10g\\n",nfeval,cmin);\n   }\n/*=======================================================================*/\n/*=========End of iteration loop=========================================*/\n/*=======================================================================*/\n  \n/*-------Final output in file-------------------------------------------*/\n  \n  \n   fprintf(fpout_ptr,"\\n\\n\\n Best-so-far obj. funct. value = %-15.10g\\n",cmin);\n  \n   for (j=0;j<D;j++)\n   {\n     fprintf(fpout_ptr,"\\n best[%d]=%-15.10g",j,best[j]);\n   }\n   fprintf(fpout_ptr,"\\n\\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);\n   fprintf(fpout_ptr,"\\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\\n",\n           NP,F,CR,cvar); \n  \n  fclose(fpout_ptr);\n  \n  /* Code you want timed here */\n  printf("Time elapsed: %f\\n", ((double)clock() - start) / CLOCKS_PER_SEC);\n   return(0);\n}\n  \n/*-----------End of main()------------------------------------------*/\n  \n// 適應函式 fittness function (cost function)\ndouble evaluate(int D, double tmp[], long *nfeval)\n{\n   double result=0, surface = 80.0, z, volume, penality;\n   (*nfeval)++;\n   z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));\n   volume = tmp[0]*tmp[1]*z;\n  \n  if(volume <= 0){\n    return PENALITY;\n  }\n// 只限制長度與寬度必須大於 0\n  if(tmp[0] <= inibound_l){\n    return PENALITY;\n  }\n  \n  if(tmp[1] <= inibound_l){\n    return PENALITY;\n  }\n/*\n  if((tmp[0] <= inibound_l)|| (tmp[0] >inibound_h)){\n    return PENALITY;\n  }\n  \n  if((tmp[1] <= inibound_l) || (tmp[1] >inibound_h)){\n    return PENALITY;\n  }\n  */\n  // volume must >0 and max volume\n  // 目前為最小化問題\n   //return 1+1/(volume*volume);\n  return volume;\n} \n Python\xa0 Differential Evolution \xa0 algorithm: \n import random\n \nclass Chromosome(object):\n \n    """\n    just copy the idea of genetic algorithm, pretty similar..\n    """\n    def __init__(self, n):\n        """\n        int n, dimension of question\n        """\n        # dimension\n        self.n = n\n        # the gene\n        self.v = [0] * n\n        # the fitness value\n        self.f = 0\n \n    def assign(self, obj):\n        """\n        Chromosome obj\n \n        copy all attribute from obj to itself\n        """\n        self.n = obj.n\n        self.v = obj.v[:]\n        self.f = obj.f\n \n \nclass DiffertialEvolution(object):\n \n    def __init__(self,Func, pType, strategy, D, NP, F, CR, lower, upper, maxGen, report):\n        # if pType = 1 it is maximization  otherwise is minimization problem\n        self.pType = pType\n        # strategy 1~10, choice what strategy to generate new member in temporary\n        self.strategy = strategy\n        # dimesion of quesiton\n        self.D = D\n        # population size\n        # To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence\n        self.NP = NP\n        # weight factor\n        # F is usually between 0.5 and 1 (in rare cases > 1)\n        self.F = F\n        # crossover possible\n        # CR in [0,1]\n        self.CR = CR\n        # lower bound array\n        self.lb = lower[:]\n        # upper bound array\n        self.ub = upper[:]\n        # maximum generation\n        self.maxGen = maxGen\n        # how many generation report once\n        self.rpt = report\n        # object function, or enviorment\n        self.f = Func\n        # check parameter is set properly\n        self.checkParameter()\n \n        # generation pool, depend on population size\n        self.pop = [Chromosome(D) for i in range(NP)]\n        # last generation best member\n        self.lastgenbest = Chromosome(D)\n        # current best member\n        self.currentbest = Chromosome(D)\n        # the generation count\n        self.gen = 0\n        # the vector\n        self.r1 = 0\n        self.r2 = 0\n        self.r3 = 0\n        self.r4 = 0\n        self.r5 = 0\n \n    def checkParameter(self):\n        """\n        check parameter is set properly\n        """\n        if (type(self.D) is not int) and self.D <= 0:\n            raise Exception(\'D shoud be integer and larger than 0\')\n        if (type(self.NP) is not int) and self.NP <= 0:\n            raise Exception(\'NP shoud be integer and larger than 0\')\n        if self.CR < 0 or self.CR > 1:\n            raise Exception(\'CR should be [0,1]\')\n        if self.maxGen <= 0:\n            raise Exception(\'generation should larger than 0\')\n        if self.rpt <= 0 or self.rpt > self.maxGen:\n            raise Exception(\'report should be larger than 0 and less than max genration\')\n        if self.strategy < 1 or self.strategy > 10:\n            raise Exception(\'strategy should be [1,10]\')\n        for lower, upper in zip(self.lb, self.ub):\n            if lower > upper:\n                raise Exception(\'upper bound should be larger than lower bound\')\n \n    def init(self):\n        """\n        init population\n        """\n        for i in range(self.NP):\n            for j in range(self.D):\n                self.pop[i].v[j] = self.lb[j] + random.random()*(self.ub[j] - self.lb[j])\n            self.pop[i].f = self.evalute(self.pop[i])\n \n    def evalute(self, p):\n        """\n        evalute the member in enviorment\n        """\n        return self.f(p.v)\n \n    def findBest(self):\n        """\n        find member that have minimum fitness value from pool\n        """\n        if self.pType == 1:\n            return max(self.pop, key=lambda chrom:chrom.f)\n        else:\n            return min(self.pop, key=lambda chrom:chrom.f)\n \n    def generateRandomVector(self, i):\n        """\n        generate new vector\n        """\n        while True:\n            self.r1 = int(random.random() * self.NP)\n            if not (self.r1 == i):\n                break\n \n        while True:\n            self.r2 = int(random.random() * self.NP)\n            if not ((self.r2 == i) or (self.r2 == self.r1)):\n                break\n \n        while True:\n            self.r3 = int(random.random() * self.NP)\n            if not ((self.r3 == i) or (self.r3 == self.r1) or (self.r3 == self.r2)):\n                break\n \n        while True:\n            self.r4 = int(random.random() * self.NP)\n            if not ((self.r4 == i) or (self.r4 == self.r1) or (self.r4 == self.r2) or (self.r4 == self.r3)):\n                break\n \n        while True:\n            self.r5 = int(random.random() * self.NP)\n            if not ((self.r5 == i) or (self.r5 == self.r1) or (self.r5 == self.r2) or (self.r5 == self.r3) or (self.r5 == self.r4)):\n                break\n \n    def recombination(self, i):\n        """\n        use new vector, recombination the new one member to tmp\n        """\n        tmp = Chromosome(self.D)\n \n        if self.strategy == 1:\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n \n        elif self.strategy == 2:\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 3):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 4):\n            tmp.assign(self.pop[i])\n \n            n = int(random.random() * self.D)\n \n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 5):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((random.random() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 6):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n \n        elif (self.strategy == 7):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n \n                n = (n + 1) % self.D\n \n        elif (self.strategy == 8):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n \n                n = (n + 1) % self.D\n \n        elif (self.strategy == 9):\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n \n                n = (n + 1) % self.D\n \n        else:\n            tmp.assign(self.pop[i])\n            n = int(random.random() * self.D)\n            for L in range(self.D):\n                if ((random.random() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n        return tmp\n \n    def report(self):\n        """\n        report current generation status\n        """\n        if self.gen == 0:\n            print("DiffertialEvolution results - init pop")\n        elif self.gen == self.maxGen:\n            print("Final DiffertialEvolution results at", self.gen, "generations")\n        else:\n            print("DiffertialEvolution results after", self.gen, "generations")\n        print("Function : %.6f" % (self.currentbest.f))\n        for i, v in enumerate(self.currentbest.v, start=1):\n            print("Var", i, ":", v)\n \n    def overbound(self, member):\n        """\n        check the member\'s chromosome that is out of bound?\n        """\n        for i in range(self.D):\n            if member.v[i] > self.ub[i] or member.v[i] < self.lb[i]:\n                return True\n        return False\n \n    def run(self):\n        """\n        run the algorithm...\n        """\n        # initial step\n        # generation 0\n        self.gen = 0\n        # init the member\'s chromsome\n        self.init()\n        # find the best one(smallest fitness value)\n        tmp = self.findBest()\n        # copy to lastgenbest\n        self.lastgenbest.assign(tmp)\n        # copy to currentbest\n        self.currentbest.assign(tmp)\n        # report status\n        self.report()\n        # end initial step\n \n        # the evolution journey is beggin...\n        for self.gen in range(1, self.maxGen + 1):\n            for i in range(self.NP):\n                # generate new vector\n                self.generateRandomVector(i)\n                # use the vector recombine the member to temporary\n                tmp = self.recombination(i)\n                # check the one is out of bound?\n                if self.overbound(tmp):\n                    # if it is, then ignore\n                    continue\n                # is not out of bound, that mean it\'s quilify of enviorment\n                # then evalute the one\n                tmp.f = self.evalute(tmp)\n                # if temporary one is better than origin(fitness value is larger or smaller)\n                # pType is 1, the problem is maximization type\n                if self.pType == 1:\n                    if tmp.f >= self.pop[i].f:\n                        # copy the temporary one to origin member\n                        self.pop[i].assign(tmp)\n                        # check the temporary one is better than the currentbest\n                        if tmp.f > self.currentbest.f:\n                            # copy the temporary one to currentbest\n                            self.currentbest.assign(tmp)\n                else:\n                    if tmp.f <= self.pop[i].f:\n                        # copy the temporary one to origin member\n                        self.pop[i].assign(tmp)\n                        # check the temporary one is better than the currentbest\n                        if tmp.f < self.currentbest.f:\n                            # copy the temporary one to currentbest\n                            self.currentbest.assign(tmp)\n            # copy the currentbest to lastgenbest\n            self.lastgenbest.assign(self.currentbest)\n            # if report generation is set, report\n            if self.rpt != 0:\n                if self.gen % self.rpt == 0:\n                    self.report()\n        # the evolution journey is done, report the final status\n        self.report()\n \n#fittness function (cost function)\ndef evaluate(designVariablel):\n    surface = 80.0\n    # if pType is 1, the penality is negative (maximization problem)\n    # if pType is 0, the penality is positive (minimization problem)\n    penality = -1000\n \n    z = (surface-designVariablel[0]*designVariablel[1])/(2.0*(designVariablel[0]\\\n         +designVariablel[1]))\n    volume = designVariablel[0]*designVariablel[1]*z\n   \n    if(volume <= 0):\n        return penality\n \n    # box length and width need to be larger than 0\n    if(designVariablel[0] <= 0):\n        return penality\n \n    if(designVariablel[1] <= 0):\n        return penality\n    return volume\n#volume = DiffertialEvolution((self,Func, max, strategy, D, NP, F, CR, lower, upper, maxGen, report)\nvolume = DiffertialEvolution(evaluate, 1, 3, 2, 100, 0.6, 0.85, [0, 0], [50, 50], 100, 10)\nvolume.run() \n 為了提升運算速度, 將上述 Python 程式轉為  Cython  格式: \n #import random\nfrom cpython cimport bool\n#from array import array\nimport numpy as np\ncimport numpy as np\nfrom libc.stdlib cimport rand, RAND_MAX, srand\nfrom libc.time cimport time\n \n# make true it is random everytime\nsrand(time(NULL))\n \ncdef double randV():\n    return rand()*1.0 / RAND_MAX\n \ncdef class Chromosome(object):\n    """\n    just copy the idea of genetic algorithm, pretty similar..\n    """\n    cdef public int n\n    cdef public double f\n    cdef public np.ndarray v\n \n    def __cinit__(self, int n):\n        """\n        int n, dimension of question\n        """\n        # dimension\n        self.n = n\n        # the gene\n        self.v = np.zeros(n)\n        # the fitness value\n        self.f = 0\n \n    def assign(self, Chromosome obj):\n        """\n        Chromosome obj\n        copy all attribute from obj to itself\n        """\n        self.n = obj.n\n        self.v[:] = obj.v\n        self.f = obj.f\n \n \ncdef class DiffertialEvolution(object):\n \n    cdef:\n        int strategy, D, NP, maxGen, rpt, gen, r1, r2, r3, r4, r5\n        double F, CR\n        np.ndarray lb, ub, pop\n        object f\n        Chromosome lastgenbest, currentbest\n \n    def __cinit__(self, object Func, int strategy, int D, int NP, double F, double CR, object lower, object upper, int maxGen, int report):\n        # strategy 1~10, choice what strategy to generate new member in temporary\n        self.strategy = strategy\n        # dimesion of quesiton\n        self.D = D\n        # population size\n        # To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence\n        self.NP = NP\n        # weight factor\n        # F is usually between 0.5 and 1 (in rare cases > 1)\n        self.F = F\n        # crossover possible\n        # CR in [0,1]\n        self.CR = CR\n        # low bound\n        self.lb = np.array(lower[:])\n        # up bound\n        self.ub = np.array(upper[:])\n        # maximum generation\n        self.maxGen = maxGen\n        # how many generation report once\n        self.rpt = report\n        # object function, or enviorment\n        self.f = Func\n        # check parameter is set properly\n        self.checkParameter()\n \n        # generation pool, depend on population size\n        #self.pop = [Chromosome(self.D) for i in range(self.NP)]\n        self.pop = np.ndarray((NP,),dtype=np.object)\n        for i in range(NP):\n            self.pop[i] = Chromosome(self.D)\n        # last generation best member\n        self.lastgenbest = Chromosome(D)\n        # current best member\n        self.currentbest = Chromosome(D)\n        # the generation count\n        self.gen = 0\n        # the vector\n        self.r1 = 0\n        self.r2 = 0\n        self.r3 = 0\n        self.r4 = 0\n        self.r5 = 0\n \n    cdef void checkParameter(self):\n        """\n        check parameter is set properly\n        """\n        if (type(self.D) is not int) and self.D <= 0:\n            raise Exception(\'D shoud be integer and larger than 0\')\n        if (type(self.NP) is not int) and self.NP <= 0:\n            raise Exception(\'NP shoud be integer and larger than 0\')\n        if self.CR < 0 or self.CR > 1:\n            raise Exception(\'CR should be [0,1]\')\n        if self.maxGen <= 0:\n            raise Exception(\'generation should larger than 0\')\n        if self.rpt <= 0 or self.rpt > self.maxGen:\n            raise Exception(\'report should be larger than 0 and less than max genration\')\n        if self.strategy < 1 or self.strategy > 10:\n            raise Exception(\'strategy should be [1,10]\')\n        for lower, upper in zip(self.lb, self.ub):\n            if lower > upper:\n                raise Exception(\'upper bound should be larger than lower bound\')\n \n    cdef void init(self):\n        """\n        init population\n        """\n        cdef int i, j\n \n        for i in range(self.NP):\n            for j in range(self.D):\n                self.pop[i].v[j] = self.lb[j] + randV()*(self.ub[j] - self.lb[j])\n            self.pop[i].f = self.evalute(self.pop[i])\n \n    cdef double evalute(self, Chromosome member):\n        """\n        evalute the member in enviorment\n        """\n        return self.f(member.v)\n \n    cdef Chromosome findBest(self):\n        """\n        find member that have minimum fitness value from pool\n        """\n        return min(self.pop, key=lambda chrom:chrom.f)\n \n    cdef void generateRandomVector(self, i):\n        """\n        generate new vector\n        """\n        while True:\n            self.r1 = int(randV() * self.NP)\n            if not (self.r1 == i):\n                break\n \n        while True:\n            self.r2 = int(randV() * self.NP)\n            if not ((self.r2 == i) or (self.r2 == self.r1)):\n                break\n \n        while True:\n            self.r3 = int(randV() * self.NP)\n            if not ((self.r3 == i) or (self.r3 == self.r1) or (self.r3 == self.r2)):\n                break\n \n        while True:\n            self.r4 = int(randV() * self.NP)\n            if not ((self.r4 == i) or (self.r4 == self.r1) or (self.r4 == self.r2) or (self.r4 == self.r3)):\n                break\n \n        while True:\n            self.r5 = int(randV() * self.NP)\n            if not ((self.r5 == i) or (self.r5 == self.r1) or (self.r5 == self.r2) or (self.r5 == self.r3) or (self.r5 == self.r4)):\n                break\n \n    cdef Chromosome recombination(self, int i):\n        """\n        use new vector, recombination the new one member to tmp\n        """\n        cdef Chromosome tmp\n        cdef int n, L\n \n        tmp = Chromosome(self.D)\n \n        if self.strategy == 1:\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n \n        elif self.strategy == 2:\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 3):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 4):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 5):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            L = 0\n            while True:\n                tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n                L += 1\n                if not ((randV() < self.CR) and (L < self.D)):\n                    break\n \n        elif (self.strategy == 6):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n \n        elif (self.strategy == 7):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])\n                n = (n + 1) % self.D\n \n        elif (self.strategy == 8):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])\n                n = (n + 1) % self.D\n \n        elif (self.strategy == 9):\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n \n        else:\n            tmp.assign(self.pop[i])\n            n = int(randV() * self.D)\n            for L in range(self.D):\n                if ((randV() < self.CR) or L == (self.D - 1)):\n                    tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F\n                n = (n + 1) % self.D\n        return tmp\n \n    cdef void report(self):\n        """\n        report current generation status\n        """\n        cdef int i\n        cdef double v\n \n        if self.gen == 0:\n            print("DiffertialEvolution results - init pop")\n        elif self.gen == self.maxGen:\n            print("Final DiffertialEvolution results at %d generations"%(self.gen,))\n        else:\n            print("DiffertialEvolution results after %d generations"%(self.gen,))\n        print("Function : %.6f" % (self.currentbest.f))\n        for i, v in enumerate(self.currentbest.v.flat, start=1):\n            print("Var %d : %.4f"%(i, v))\n \n    cdef bool overbound(self, Chromosome member):\n        """\n        check the member\'s chromosome that is out of bound?\n        """\n        cdef int i\n \n        for i in range(self.D):\n            if member.v[i] > self.ub[i] or member.v[i] < self.lb[i]:\n                return True\n        return False\n \n    cdef void run(self):\n        """\n        run the algorithm...\n        """\n        cdef Chromosome tmp\n        cdef int i\n \n        # initial step\n        # generation 0\n        self.gen = 0\n        # init the member\'s chromsome\n        self.init()\n        # find the best one(smallest fitness value)\n        tmp = self.findBest()\n        # copy to lastgenbest\n        self.lastgenbest.assign(tmp)\n        # copy to currentbest\n        self.currentbest.assign(tmp)\n        # report status\n        self.report()\n        # end initial step\n \n        # the evolution journey is beggin...\n        for self.gen in range(1, self.maxGen + 1):\n            for i in range(self.NP):\n                # generate new vector\n                self.generateRandomVector(i)\n                # use the vector recombine the member to temporary\n                tmp = self.recombination(i)\n                # check the one is out of bound?\n                if self.overbound(tmp):\n                    # if it is, then abandon it\n                    continue\n                # is not out of bound, that mean it\'s quilify of enviorment\n                # then evalute the one\n                tmp.f = self.evalute(tmp)\n                # if temporary one is better than origin(fitness value is smaller)\n                if tmp.f <= self.pop[i].f:\n                    # copy the temporary one to origin member\n                    self.pop[i].assign(tmp)\n                    # check the temporary one is better than the currentbest\n                    if tmp.f < self.currentbest.f:\n                        # copy the temporary one to currentbest\n                        self.currentbest.assign(tmp)\n            # copy the currentbest to lastgenbest\n            self.lastgenbest.assign(self.currentbest)\n            # if report generation is set, report\n            if self.rpt != 0:\n                if self.gen % self.rpt == 0:\n                    self.report()\n        # the evolution journey is done, report the final status\n        self.report() \n 使用 Real-coded Genetic algorithm 解題: \n import time\nimport math\n \n \nclass Chromosome(object):\n \n    def __init__(self, n=None):\n        self.np = n if n > 0 else 2\n        self.f = 0.0\n        self.v = [0.0] * n\n \n    def cp(self, obj):\n        """\n        copy all atribute from another chromsome object\n        """\n        self.np = obj.np\n        self.f = obj.f\n        self.v = obj.v[:]\n \n    def get_v(self, i):\n        return self.v[i]\n \n    def is_self(self, obj):\n        """\n        check the object is self?\n        """\n        return obj is self\n \n    def assign(self, obj):\n        if not self.is_self(obj):\n            self.cp(obj)\n \n \nclass Genetic(object):\n \n    def __init__(self, func, pType, nParm, nPop, pCross, pMute, pWin, bDelta, upper, lower):\n        """\n        init(function func)\n        """\n        self.func=func\n        self.pType = pType\n        self.nParm=nParm\n        self.nPop=nPop\n        self.pCross=pCross\n        self.pMute=pMute\n        self.pWin=pWin\n        self.bDelta=bDelta\n \n        self.chrom = [Chromosome(nParm) for i in range(nPop)]\n        self.newChrom = [Chromosome(nParm) for i in range(nPop)]\n        self.babyChrom = [Chromosome(nParm) for i in range(3)]\n        self.chromElite = [Chromosome(nParm)]\n        self.chromBest = [Chromosome(nParm)]\n        self.maxLimit = upper[:]\n        self.minLimit = lower[:]\n \n        self.maxGen = None\n        self.gen = None\n \n        self.seed = 0.0\n        self.iseed = 470211272.0\n        self.mask = 2147483647\n \n    def check(self, i, v):\n        """\n        If a variable is out of bound,\n        replace it with a random value\n        """\n        if (v > self.maxLimit[i]) or (v < self.minLimit[i]):\n            return self.randVal(self.minLimit[i], self.maxLimit[i])\n        return v\n \n    def crossOver(self):\n        for i in range(0, self.nPop-1, 2):\n            # crossover\n            if(self.rnd() < self.pCross):\n                for s in range(self.nParm):\n                    # first baby, half father half mother\n                    self.babyChrom[0].v[s] = 0.5 * self.chrom[i].v[s] + 0.5*self.chrom[i+1].v[s];\n                    # second baby, three quaters of fater and quater of mother\n                    self.babyChrom[1].v[s] = self.check(s, 1.5 * self.chrom[i].v[s] - 0.5*self.chrom[i+1].v[s])\n                    # third baby, quater of fater and three quaters of mother\n                    self.babyChrom[2].v[s] = self.check(s,-0.5 * self.chrom[i].v[s] + 1.5*self.chrom[i+1].v[s]);\n \n                for j in range(3):\n                    self.babyChrom[j].f = self.func(self.babyChrom[j].v)\n                # maximization\n                if self.pType == 1:\n                     \n                    if self.babyChrom[1].f > self.babyChrom[0].f:\n                        self.babyChrom[0], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[0]\n \n                    if self.babyChrom[2].f > self.babyChrom[0].f:\n                        self.babyChrom[2], self.babyChrom[0] = self.babyChrom[0], self.babyChrom[2]\n \n                    if self.babyChrom[2].f > self.babyChrom[1].f:\n                        self.babyChrom[2], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[2]\n \n                else:\n                     \n                    if self.babyChrom[1].f < self.babyChrom[0].f:\n                        self.babyChrom[0], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[0]\n \n                    if self.babyChrom[2].f < self.babyChrom[0].f:\n                        self.babyChrom[2], self.babyChrom[0] = self.babyChrom[0], self.babyChrom[2]\n \n                    if self.babyChrom[2].f < self.babyChrom[1].f:\n                        self.babyChrom[2], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[2]\n \n                # replace first two baby to parent, another one will be\n                self.chrom[i].assign(self.babyChrom[0])\n                self.chrom[i+1].assign(self.babyChrom[1])\n \n    def delta(self, y):\n        r = float(self.gen) / self.maxGen;\n        return y*self.rnd()*math.pow(1.0-r, self.bDelta)\n \n    def fitness(self):\n        for j in range(self.nPop):\n            self.chrom[j].f = self.func(self.chrom[j].v)\n \n        self.chromBest[0].assign(self.chrom[0])\n \n        for j in range(self.nPop):\n            if self.pType == 1:\n                if(self.chrom[j].f > self.chromBest[0].f):\n                    self.chromBest[0].assign(self.chrom[j])\n            else:\n                if(self.chrom[j].f < self.chromBest[0].f):\n                    self.chromBest[0].assign(self.chrom[j])\n        if self.pType == 1:\n            if(self.chromBest[0].f > self.chromElite[0].f):\n                self.chromElite[0].assign(self.chromBest[0])\n        else:\n            if(self.chromBest[0].f < self.chromElite[0].f):\n                self.chromElite[0].assign(self.chromBest[0])\n \n    def initialPop(self):\n        for j in range(self.nPop):\n            for i in range(self.nParm):\n                self.chrom[j].v[i] = self.randVal(self.minLimit[i], self.maxLimit[i])\n \n    def mutate(self):\n        for i in range(self.nPop):\n            if self.rnd() < self.pMute:\n                s = self.random(self.nParm)\n                if (self.random(2) == 0):\n                    self.chrom[i].v[s] += self.delta(self.maxLimit[s]-self.chrom[i].v[s])\n                else:\n                    self.chrom[i].v[s] -= self.delta(self.chrom[i].v[s]-self.minLimit[s])\n \n    def report(self):\n        if self.gen == 0:\n            print("Genetik results - Initial population")\n        elif self.gen == self.maxGen:\n            print("Final Genetik results at", self.gen, "generations")\n        else:\n            print("Genetik results after", self.gen, "generations")\n \n        print("Function : %.6f" % (self.chromElite[0].f))\n        for i, p in enumerate(self.chromElite[0].v):\n            print("Var", i+1, ":", p)\n \n    def select(self):\n        """\n        roulette wheel selection\n        """\n        for i in range(self.nPop):\n            j = self.random(self.nPop)\n            k = self.random(self.nPop)\n            self.newChrom[i].assign(self.chrom[j])\n            if self.pType == 1:\n                if(self.chrom[k].f > self.chrom[j].f) and (self.rnd() > self.pWin):\n                    self.newChrom[i].assign(self.chrom[k])\n            else:\n                if(self.chrom[k].f < self.chrom[j].f) and (self.rnd() < self.pWin):\n                    self.newChrom[i].assign(self.chrom[k])\n        # in this stage, newChrom is select finish\n        # now replace origin chrom\n        for i in range(self.nPop):\n            self.chrom[i].assign(self.newChrom[i])\n \n        # select random one chrom to be best chrom, make best chrom still exist\n        j = self.random(self.nPop);\n        self.chrom[j].assign(self.chromElite[0])\n \n    def run(self, mxg, rp):\n        """\n        // **** Init and run GA for maxGen times\n        // **** mxg : maximum generation\n        // **** rp  : report cycle, 0 for final report or\n        // ****       report each mxg modulo rp\n        """\n        self.maxGen = mxg\n        self.rpt = rp\n \n        self.randomize()\n        self.initialPop()\n        self.chrom[0].f = self.func(self.chrom[0].v)\n        self.chromElite[0].assign(self.chrom[0])\n \n        self.gen = 0\n        self.fitness()\n        self.report()\n \n        for self.gen in range(1, self.maxGen + 1):\n            self.select()\n            self.crossOver()\n            self.mutate()\n            self.fitness()\n            if rp != 0:\n                if self.gen % self.rpt == 0:\n                    self.report()\n        self.report()\n \n    def newSeed(self):\n        if(self.seed == 0.0):\n            self.seed=self.iseed\n        else:\n            self.seed *= 16807.0\n            self.seed = math.fmod(self.seed, self.mask)\n \n    def rnd(self):\n        self.newSeed()\n        return self.seed/self.mask\n \n    def randomize(self):\n        self.seed = time.time()\n \n    def random(self, k):\n        return int(self.rnd()*k)\n \n    def randVal(self, low, high):\n        number_types = (int, float)\n        if isinstance(low, number_types) and isinstance(high, number_types):\n            return self.rnd()*(high-low)+low\n        raise ValueError\n         \n#fittness function (cost function)\ndef evaluate(designVariablel):\n    surface = 80.0\n    # if pType is 1, the penality is negative (maximization problem)\n    # if pType is 0, the penality is positive (minimization problem)\n    penality = -1000\n \n    z = (surface-designVariablel[0]*designVariablel[1])/(2.0*(designVariablel[0]\\\n         +designVariablel[1]))\n    volume = designVariablel[0]*designVariablel[1]*z\n   \n    if(volume <= 0):\n        return penality\n \n    # box length and width need to be larger than 0\n    if(designVariablel[0] <= 0):\n        return penality\n \n    if(designVariablel[1] <= 0):\n        return penality\n    #return 1+1/(volume*volume)\n    return volume\n \n#volume = Genetic(self, func, pType, nParm, nPop, pCross, pMute, pWin, bDelta, upper, lower):\nvolume = Genetic(evaluate, 1, 2, 1000, 0.95, 0.05, 0.95, 5, [0, 0], [50, 50])\nvolume.run(1000, 50) \n \n', 'tags': '', 'url': 'Optimal Design.html'}, {'title': 'Cloud MCAD', 'text': 'http://mde.tw/cadp2018/content/%E9%9B%B2%E7%AB%AF%20CAD.html \n University \n http://mde.tw/cadp2018/content/%E5%A4%A7%E5%AD%B8.html \n', 'tags': '', 'url': 'Cloud MCAD.html'}, {'title': 'Generative Design', 'text': 'Solving Engineering Design Problems through a Combination of Generative Grammars and Simulations.pdf \n Generative Programming.pdf \n generative representations for evoluationary design automation.pdf \n \n', 'tags': '', 'url': 'Generative Design.html'}, {'title': 'CMS', 'text': '請注意: 由於自\xa0 https://github.com/mdecourse/cmsimde/blob/5acf7403a8e4615edc93711dcb17a5a56438e0bc/flaskapp.py \xa0版本開始, 納入 flask_cors, 因此先前所下載的可攜程式系統需要安裝 flask_cors, 否則無法啟動 CMSiMDE. \n 安裝 flask_cors \n python -m pip install flask_cors \n https://github.com/mdecourse/cmsimde \xa0的開發, 可以讓使用者在一個 Github 倉儲目錄中, 透過子模組的方式放入 cmsimde, 然後將 cmsimde 目錄中 up_dir 的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄後, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443\xa0就可以連接在近端啟動的動態內容管理系統, 以 admin 作為管理者密碼, 就可以登入維護內容. \n 利用 Leo Editor 執行開發 \n cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可持續對 cmsimde 遠端倉儲進行改版. \n Pelican 網誌與 reveal 簡報系統 \n cmsimde 除了利用\xa0 flask, bs4, lxml 與 flask_cors 建立網際內容管理系統外, 同時利用 markdown 與 pelican 模組建立網誌系統, 利用 reveal.js 建立網際簡報系統. \n pelican 網誌系統的編輯採用 Leo Editor, 管理檔案位於 config/pelican.leo, 而網際 reveal.js 簡報系統的編輯也採用 Leo Editor, 管理檔案位於 config/reveal.leo. \n pelican 網際系統的 markdown 檔案位於 mardown 目錄, 轉換完成的網誌檔案則位於 blog 目錄, 而 reveal.js 的簡報檔案則位於 reveal 目錄. \n 使用者設定 \n init.py 位於\xa0 up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數. uwsgi 執行模式主要用於 Ubuntu 伺服器, 必須結合 nginx 全球資訊網伺服器建立具有隨開機啟動與提供 https 連線的網際內容管理服務. \n 利用 cmsimde 建立靜態網誌方法: \n 1. 在 github 建立倉儲, git clone 到近端 \n 2. 參考\xa0 https://github.com/mdecourse/newcms , 加入除了 cmsimde 目錄外的所有內容 \n 以 git submodule add\xa0 https://github.com/mdecourse/cmsimde \xa0cmsimde \n 建立 cmsimde 目錄, 並從 github 取下子模組內容. \n 3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器. \n 動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端. \n 4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行: \n git clone --recurse-submodules  https://github.com/mdecourse/newcms.git \n 參考資料: \n http://lab.kmol.info/2017fall/blog/index.html \n https://buttercms.com/blog/buttercms-vs-wordpress-headless-cms-vs-traditional-cms', 'tags': '', 'url': 'CMS.html'}, {'title': 'CMSiMDE', 'text': 'https://github.com/mdecourse/cmsimde \xa0是一套以 Python 加上 flask, bs4, lxml, mardown, pelican, flask_cors, leo 等模組所建構的網際內容管理系統. \n flask 模組是一套網際程式框架, CMSiMDE 利用此一框架編寫網際相關的函式, 用來執行動態的內容管理系統. \n bs4 在 CMSiMDE 擔任解析 config/content.htm 超文件檔案的工作, 根據 h1, h2 與 h3 標註, 對 content.htm 進行分頁, 因此使用者可以透過 3 個階次的內容架構進行編輯. \n lxml 模組主要用來將 content.htm 逐一轉換為 content 目錄中的個別檔案, 也就是在 CMSiMDE 動態系統中, 點擊 generate_pages 之後, 呼叫 lxml 模組中的分頁方法, 將動態內容轉為靜態內容. \n markdown 與 pelican 在 CMSiMDE 主要用來產生靜態網誌, 而網誌的設計與編輯則透過 Leo Editor 進行, 此外 CMSiMDE 除了網際內容管理與網誌之外, 還透過 Leo Editor 管理 reveal.js 網際簡報系統. \n flask_cors 模組, 在 CMSiMDE 是為了配合 Dartpad 程式編寫過程, 需要跨網站擷取資料的需求而加入, 在舊版的可攜系統中若無此模組, 執行 CMSiMDE 之前必須透過 \n python -m pip install flask_cors\xa0 \n 安裝. \n CMSiMDE 可以放入 Javascript 前端程式, 進行簡單的設計運算, 例如: \n http://mde.tw/cp2019/content/Task3.html \xa0中的猜數字遊戲. \n 也可以嵌入 STL文字格式零件, 例如: \n http://mde.tw/cad2019/content/STL.html \n 也可以利用前端的 Javascript 與伺服器後端的程式進行非同步設計運算或遠端控制, 例如: \n http://mde.tw/cad2019/content/Task1.html \xa0中的網際虛擬雙輪車控制. \n', 'tags': '', 'url': 'CMSiMDE.html'}, {'title': 'CMSiMDE 已知錯誤', 'text': '', 'tags': '', 'url': 'CMSiMDE 已知錯誤.html'}, {'title': 'STL', 'text': 'CMSiMDE 引用 ASCII STL方法: \n 將 ascii.stl 檔案上傳至 downloads 目錄後, 利用 File List 功能, 後列出 ascii.stl, 以滑鼠點擊會出現顯示 stl 檔案的頁面, 導入頁面時, 以 iframe 標註之 src 對應至顯示 stl 檔案的 html 連結即可, 例如:\xa0 <iframe width="600" height="400" src="./../cmsimde/static/viewstl.html?src=./../../downloads/spikeball.stl"></iframe> \n \n 將 Solvespace 轉出的 Binary STL 零組件轉為 ASCII STL 程式碼: \n import struct\nnormals = []\npoints = []\ntriangles = []\ntriangle_number = 0\ndef load_binary_stl(fp):\n    \'\'\'\n    二位元 STL 檔案格式如下:\n    檔案標頭共有 80 個字元(bytes), 內容通常省略, 但是內容不可使用 solid, 以免與文字檔案 STL 混淆\n    UINT8[80] – Header\n    UINT32 – Number of triangles (I:佔 4 bytes 的 unsigned integer)\n  \n    foreach triangle\n    REAL32[3] – Normal vector (f:每一座標分量為一佔 4 bytes 的 float, 共佔 12 bytes)\n    REAL32[3] – Vertex 1\n    REAL32[3] – Vertex 2\n    REAL32[3] – Vertex 3\n    UINT16 – Attribute byte count (H:兩個 bytes 的 unsigned short, 表示 attribute byte count)\n    end\n  \n    \'\'\'\n    # 已經在外部開檔\n    #fp=open(filename,\'rb\')\n    header=fp.read(80)\n    triangle_number = struct.unpack(\'I\',fp.read(4))[0]\n    #print(triangle_number)\n    count=0\n    while True:\n        try:\n            p=fp.read(12)\n            if len(p)==12:\n                n=[struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]]\n                normals.append(n)\n                l = len(points)\n                #print(n)\n            p=fp.read(12)\n            if len(p)==12:\n                p1=[struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]]\n                points.append(p1)\n                #print(p1)\n            p=fp.read(12)\n            if len(p)==12:\n                p2=[struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]]\n                points.append(p2)\n            p=fp.read(12)\n            if len(p)==12:\n                p3=[struct.unpack(\'f\',p[0:4])[0],struct.unpack(\'f\',p[4:8])[0],struct.unpack(\'f\',p[8:12])[0]]\n                points.append(p3)\n                triangles.append((l, l+1, l+2))\n            # 使用 count 來計算三角形平面個數\n            # triangle_number 為 STL 檔案中的三角形個數\n            count += 1\n            #print(count)\n            # 在前面 12*4 個 bytes 的 normal 與三個點資料後, 為\n            # 一個 2 bytes 長的 unsigned short, 其值為零, 為 attribute\n            fp.read(2)\n            # 讀完所有三角平面後, 即跳出 while\n            if count > triangle_number:\n                break\n        except EOFError:\n            break\n    #fp.close()\ndef read_length(f):\n    length = struct.unpack("@i", f.read(4))\n    return length[0]\ndef read_header(f):\n    f.seek(f.tell()+80)\ndef write_as_ascii(outfilename):\n    f = open(outfilename, "w")\n    f.write ("solid "+outfilename+"\\n")\n    for n  in range(len(triangles)):\n        f.write ("facet normal {} {} {}\\n".format(normals[n][0],normals[n][1],normals[n][2]))\n        f.write ("outer loop\\n")\n        f.write ("vertex {} {} {}\\n".format(points[triangles[n][0]][0],points[triangles[n][0]][1],points[triangles[n][0]][2]))\n        f.write ("vertex {} {} {}\\n".format(points[triangles[n][1]][0],points[triangles[n][1]][1],points[triangles[n][1]][2]))\n        f.write ("vertex {} {} {}\\n".format(points[triangles[n][2]][0],points[triangles[n][2]][1],points[triangles[n][2]][2]))\n        f.write ("endloop\\n")\n        f.write ("endfacet\\n")\n    f.write ("endsolid "+outfilename+"\\n")\n    f.close()\ndef main():\n    infilename = "binary.stl"\n    outfilename = "ascii.stl"\n    try:\n        f = open(infilename, "rb")\n        #read_header(f)\n        #l = read_length(f)\n        try:\n            load_binary_stl(f)\n            l = len(normals)\n        except Exception as e:\n            print("Exception",e)\n        print(len(normals), len(points), len(triangles), l)\n        write_as_ascii(outfilename)\n        print("done")\n    except Exception as e:\n        print(e)\nif __name__ == \'__main__\':\n    main() \n 切割多零件 STL 檔案: \n stlSplitter.py 與 stlRW.py \n stlSplitter.py \n #!/usr/bin/env python\n# STL splitter\n# splits a STL file containing separate objects\n#\n# copyright 2014 Francesco Santini <francesco.santini@gmail.com>\n#\n# based on https://github.com/cmpolis/convertSTL by Chris Polis\n# and BinarySTL https://github.com/sukhbinder/python by Sukhbinder Singh\n#\n# Released under the MIT/X license\n\n\nimport stlRW\nimport sys\nfrom os import path\n\n## functions\n\n# maybe insert a tolerance for floating points?\ndef check_connection(tri1, tri2):\n  for v1 in tri1[0:2]:\n    for v2 in tri2[0:2]:\n      if (v1[0] == v2[0] and v1[1] == v2[1] and v1[2] == v2[2]): return True\n  return False\n    \n\nif len(sys.argv) < 2:\n  print("Usage: " + sys.argv[0] + " <file.stl>")\n  sys.exit(-1)\n\nfname = sys.argv[1]\n\nprint("Reading...")\n\nhead,points,n,v1,v2,v3,isAscii = stlRW.stlRead(fname)\n\nprint("Analyzing...")\n\nfaceTree = []\n\nfor triangleIndex in range(0, len(v1)):\n  triangle = [ v1[triangleIndex], v2[triangleIndex], v3[triangleIndex], n[triangleIndex] ]\n  connectedTo = []\n  for treeindex in range(0, len(faceTree)):\n    for face in faceTree[treeindex]:\n      if check_connection(face, triangle):\n        connectedTo.append(treeindex) # the triangle is connected to at least one triangle of the current treeIndex\n        break\n      \n  if len(connectedTo) == 0:\n    # this is a triangle from a new set\n    #print "new set"\n    faceTree.append([])\n    faceTree[len(faceTree)-1].append(triangle)\n  elif len(connectedTo) == 1:\n    #print "existing set"\n    # the triangle is connected to one set\n    faceTree[connectedTo[0]].append(triangle)\n  else:\n    #print "connecting triangle"\n    #this triangle connects two branches of the tree: collapse the branches\n    faceTree[connectedTo[0]].append(triangle)\n    for i in range(len(connectedTo)-1, 0, -1):\n      faceTree[connectedTo[0]].extend(faceTree.pop(connectedTo[i]))\n      \nprint("Number of separate objects: ", len(faceTree))\n\nprint("Writing files")\n\norigFile, origExt = path.splitext(fname)\nfor i in range(0, len(faceTree)):\n  newFile = origFile + "-" + str(i+1) + origExt\n  print("Writing ", newFile)\n  n = [field[2] for field in faceTree[i]]\n  v1 = [field[0] for field in faceTree[i]] \n  v2 = [field[1] for field in faceTree[i]] \n  v3 = [field[2] for field in faceTree[i]]\n  stlRW.stlWrite(newFile, n, v1, v2, v3)\n \n stlRW.py \n # STL reader-writer\n#\n# copyright 2014 Francesco Santini <francesco.santini@gmail.com>\n#\n# based on https://github.com/cmpolis/convertSTL by Chris Polis\n# and BinarySTL https://github.com/sukhbinder/python by Sukhbinder Singh\n#\n# Released under the MIT/X license\n\nimport numpy as np\nfrom struct import unpack, pack\n\ndef stlReadBinary(fname):\n  fp = open(fname, \'rb\')\n  Header = fp.read(80)\n  nn = fp.read(4)\n  Numtri = unpack(\'i\', nn)[0]\n  #print nn\n  record_dtype = np.dtype([\n                  (\'normals\', np.float32,(3,)),  \n                  (\'Vertex1\', np.float32,(3,)),\n                  (\'Vertex2\', np.float32,(3,)),\n                  (\'Vertex3\', np.float32,(3,)) ,              \n                  (\'atttr\', \'<i2\',(1,) )\n  ])\n  data = np.fromfile(fp , dtype = record_dtype , count =Numtri)\n  fp.close()\n\n  Normals = data[\'normals\']\n  Vertex1= data[\'Vertex1\']\n  Vertex2= data[\'Vertex2\']\n  Vertex3= data[\'Vertex3\']\n\n  p = np.append(Vertex1,Vertex2,axis=0)\n  p = np.append(p,Vertex3,axis=0) #list(v1)\n  Points =np.array(list(set(tuple(p1) for p1 in p)))\n  \n  return Header,Points,Normals,Vertex1,Vertex2,Vertex3,False\n\ndef stlReadAscii(fname):\n  fp = open(fname, \'r\')\n  Normals = []\n  Vertex1 = []\n  Vertex2 = []\n  Vertex3 = []\n  Points = []\n  while True:\n    line = fp.readline()\n    if not line: break\n    if line.find("solid") > -1 or line.find("endfacet") > -1: continue\n    if line.find("facet normal") > -1:\n      normline = line[line.find("facet normal")+len("facet normal"):]\n      normal = np.array([float(val.strip()) for val in normline.split()])\n      Normals.append(normal)\n      vertices = []\n      fp.readline() # outer loop\n      # read vertices after normal\n      for vIndex in range(0,3):\n        vLine = fp.readline()\n        vLine = vLine[vLine.find("vertex")+len("vertex"):]\n        vertices.append(np.array([float(val.strip()) for val in vLine.split()]))\n      Vertex1.append(vertices[0])\n      Vertex2.append(vertices[1])\n      Vertex3.append(vertices[2])\n      Points.extend(vertices)\n      fp.readline() # endloop\n  return "", Points, Normals, Vertex1, Vertex2, Vertex3,True\n    \n  \ndef stlRead(fname):\n  fp = open(fname, "r")\n  try:\n      if fp.readline().find("solid") > -1:\n        fp.close()\n        return stlReadAscii(fname)\n      else:\n        fp.close()\n        return stlReadBinary(fname)\n  except:\n      return stlReadBinary(fname)\n    \ndef stlWriteBinary(fname, normals, v1, v2, v3):\n  with open(fname, "wb") as fout:\n    # write 80 bytes header\n    for i in range(0, 80): fout.write(pack("<c", b" "))\n    fout.write(pack("<I", len(normals))) # number of triangles\n    for i in range(0, len(normals)):\n      fout.write(pack("<fff", *normals[i]))\n      fout.write(pack("<fff", *v1[i]))\n      fout.write(pack("<fff", *v2[i]))\n      fout.write(pack("<fff", *v3[i]))\n      fout.write(pack("<H", 0)) # attribute\n      \ndef writeVector(fd, vec):\n  for v in vec:\n    fd.write("{:.7e}".format(v))\n    fd.write(" ")\n      \ndef stlWriteAscii(fname, normals, v1, v2, v3):\n  with open(fname, "w") as fout:\n    fout.write("solid \\n")\n    for i in range(0, len(normals)):\n      fout.write("  facet normal ")\n      writeVector(fout, normals[i])\n      fout.write("\\n")\n      fout.write("    outer loop\\n")\n      fout.write("      vertex ")\n      writeVector(fout, v1[i])\n      fout.write("\\n")\n      fout.write("      vertex ")\n      writeVector(fout, v2[i])\n      fout.write("\\n")\n      fout.write("      vertex ")\n      writeVector(fout, v3[i])\n      fout.write("\\n")\n      fout.write("    endloop\\n")\n      fout.write("  endfacet\\n")\n      \n      \ndef stlWrite(fname, normals, v1, v2, v3, isAscii=False):\n  if isAscii:\n    stlWriteAscii(fname, normals, v1, v2, v3)\n  else:\n    stlWriteBinary(fname, normals, v1, v2, v3)\n# test\nif __name__ == "__main__":\n  import sys\n  fname = sys.argv[1]\n  h,p,n,v1,v2,v3,isAscii = stlRead(fname)\n  print(len(n))\n  print(v1[0])\n  stlWriteBinary("binary.stl", n, v1, v2, v3);\n  stlWriteAscii("ascii.stl", n, v1, v2, v3);\n \n 用法: \n python stlSplitter.py solvespace_assembly_ascii.stl \n 目前可以分割從 Solvespace 轉出的組立檔案, 但是各零件比例與座標位置錯誤, 希望修正後可以套用到 wrl 組立件檔案的分割, 以便將 Solvespace 轉出的 wrl 組立檔案輸入 Webots.', 'tags': '', 'url': 'STL.html'}, {'title': 'Tools', 'text': '從未使用 Solidworks, Inventor 或 Solid Edge 等中端 MCAD 者: \n 請 登入 @gm 電子郵箱,  下載 SolidWorks 2017 SP2 安裝光碟 , 或下載已經安裝好的 \xa0 SolidWorks 2017 SP2 虛擬主機版本 , 從熟悉 Solidworks 參數繪圖與零組件設計操作開始. (參考資料:\xa0 https://github.com/mdecourse/cad2019/tree/master/downloads ) \n 曾經使用過中端 MCAD 者: \n 請 登入 @gm 電子郵箱,  下載 NX 12.0.2 安裝光碟 , 或者 下載 NX12.0.2 虛擬主機板本 . 隨後的零組件設計繪圖可以使用 Solidworks, Inventor 或 NX.\xa0(參考資料:\xa0 https://github.com/mdecourse/cad2019/tree/master/downloads ) \n 所有學員需要以學號建立  Onshape  帳號, 自行下載  Solvespace  原始碼,\xa0 根據\xa0 http://mde.tw/cp2019 \xa0中有關編譯 Solvespace 的步驟說明, 完成 Solvespace 工具的編譯, 並學習如何利用 Solvespace 建立簡單的零組件. 並嘗試從\xa0 https://github.com/KmolYuan/solvespace \xa0中建立能讓 Python 3 程式呼叫的 Geometric Constraint Solver 動態連結程式庫, 以便利用程式方法進行平面機構設計. \n 所有學員都必須下載: \n FreeCAD 0.18.7z \xa0 (登入 gm.nfu.edu.tw 後下載) - 電腦輔助設計實習課程專用 \n V-rep 3.6.1 rev 4.7z \xa0 (登入 gm.nfu.edu.tw 後下載) - 電腦輔助設計實習課程專用 \n Webot 2019a.7z \xa0 (登入 gm.nfu.edu.tw 後下載) - 電腦輔助設計實習課程專用 \n 並在各分組中探討這些工具能夠用來解決電腦輔助機械設計流程中的那些問題? \n', 'tags': '', 'url': 'Tools.html'}, {'title': 'FFmpeg', 'text': 'FFmpeg 手冊:  http://ffmpeg.org/ffmpeg.html \n 擷取 mp4 片段檔案 \n 從 origin.mp4 影片中的第一秒開始, 切出 15 分鐘的影片, 存為 new.mp4 \n ffmpeg -i origin.mp4 -ss 00:00:01 -t 00:15:00 -async 1 new.mp4 \n 刪除影片中的聲音資料 \n ffmpeg -i origin.mp4 -c copy -an new.mp4 \n 合併 mp4 檔案 \n 建立 allmp4.txt 內容為 file \'/path/to/1.mp4\' file \'/path/to/2.mp4\' file \'/path/to/3.mp4\' \n 將 1.mp4, 2.mp4 與 3.mp4 合併為 new.mp4 \n ffmpeg -f concat -i allmp4.txt -c copy new.mp4 \n 影片中加入字幕 \n 利用  http://www.aegisub.org/  可攜版本工具加入字幕 \n 直接將 input.srt 字幕資料 burn 入 input.mp4 \n ffmpeg -i input.mp4 -vf subtitles=input.srt output.mp4 \n 影片畫面中座標 x=5, y=950 位置中加入圖檔 \n \n ffmpeg -i input.mp4 -i kmol_102x30_color.png -filter_complex "overlay=5:950" output.mp4 \n 其他圖形化工具: \n http://www.aegisub.org/ \xa0(Font: SimSun, Size: 40, Bold, Primary, Color (255, 200, 5)) \n http://www.avidemux.org/nightly/win64_support/ \xa0(建立使用 2.6.21 版本, 可與 aegisub 配合使用) \n https://www.openshot.org/ \xa0(必須分段輸入字幕, 無法與 aegisub 配合使用) \n 請登入 @gm 電子郵箱後, 下載  aegisub_avidemux_openshot.7z \n \n', 'tags': '', 'url': 'FFmpeg.html'}, {'title': 'GUI', 'text': 'https://github.com/TransmissionZero/MinGW-Win32-Application \n http://cq.cx/index.pl \xa0(for @gm user -\xa0 sketchflat_project.7z ) \n https://github.com/LDmicro/LDmicro', 'tags': '', 'url': 'GUI.html'}, {'title': 'Solvespace', 'text': 'http://solvespace.com \n https://github.com/solvespace/solvespace \xa0 \n https://www.youtube.com/channel/UCPwwPIXHMZYcVyJ2SuRJjuA/videos \n 編譯步驟: \n 先將 Y:\\portablegit\\bin\\sh.exe 改名為 sh_rename_for_solvespace.exe \n git version 查驗 git 版本 \n git 2.13 版本以上, 可以使用下列 git clone\xa0 --recurse-submodules 取得所有子模組資料 \n git clone --recurse-submodules https://github.com/solvespace/solvespace.git solvespace \n edit Y:\\tmp\\solvespace\\extlib\\angle\\CMakeLists.txt comment out line 713 and 714 \n #list(APPEND ANGLE_DEFINITIONS  #"-DANGLE_PRELOADED_D3DCOMPILER_MODULE_NAMES={ \\"d3dcompiler_47.dll\\", \\"d3dcompiler_46.dll\\", \\"d3dcompiler_43.dll\\" }") endif() \n 需要手動進行 libpng.dll.a 的編譯, 並改名為 libpng_static.a, 並放到編譯系統的 lib 目錄中: \n cd solvespace \n cd extlib \n cd libpng \n mkdir build \n cd build \n cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release mingw32-make \n rename\xa0libpng.dll.a to libpng_static.a and copy to\xa0Y:\\msys64\\mingw64\\lib \n 接著回到 solvespace 原始碼目錄, 建立 build 目錄後進入 build 目錄, 執行: \n cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release mingw32-make \n 登入 @gm 後: \n 下載 Solvespace\xa0 986da7d 版本 \n 下載自行編譯的\xa0 solvespace.exe \n 下載 Solvespace 22e4011 版本 \n \n', 'tags': '', 'url': 'Solvespace.html'}, {'title': 'Pyslvs-UI', 'text': 'https://github.com/KmolYuan/Pyslvs-UI \n 目前正將原先使用 PyQt 的使用者介面改寫為\xa0 https://github.com/mottosso/Qt.py \xa0相容,\xa0 \n 套件執行請下載\xa0 https://github.com/KmolYuan/Pyslvs-UI/releases \xa0Windows 64 位元版本. \n 自行編譯核心程式碼: \n git clone\xa0 https://github.com/KmolYuan/Pyslvs-UI .git\xa0 \n cd Pyslvs-UI \n git submodule update --init --recursive \n cd depend/pyslvs \n python setup.py install \n cd .. \n cd solvespce/cython \n python setup.py install \n 接下來可直接利用 Python 程式呼叫位於 Lib/site-packages/pyslvs 與\xa0 Lib/site-packages/python-solvespace 中的動態連結程式庫. \n 自行編譯 pyslvs.exe 套件時, 必須先檢查可攜系統是否已經安裝 requirements.txt 中所需的模組. \n cd Pyslvs-UI\xa0 \n mingw32-make build', 'tags': '', 'url': 'Pyslvs-UI.html'}, {'title': 'Onshape', 'text': 'Link Tab \n 3DX Models \n https://3dx-us.com/onshape \n PartCommunity \n Version manager \n https://cad.onshape.com/help/Content/versionmanager.htm \n Onshape and Simscale \n https://www.simscale.com/blog/2015/12/introducing-simscale-connector-app-for-onshape/ \n Simright \n Onshape and Kiri:Moto (CAM) \n https://forum.onshape.com/discussion/5081/kiri-moto-integration \n https://forum.onshape.com/discussion/8248/kiri-moto-video-guide-for-cnc-machining \n OpenBOM \n https://www.onshape.com/cad-blog/creating-a-bill-of-materials-using-openbom', 'tags': '', 'url': 'Onshape.html'}, {'title': 'V-rep', 'text': '登入 @gm 電子郵箱後, 可以下載  V-rep 3.6.1 rev4.7z  (139 MB) \n 登入 @gm 電子郵箱後, 可以 下載截至 3.4.0 版的\xa0 V-rep 原始碼 \n 已經不存在的  v_rep 原始碼倉儲連結 \n 目前最新版為  V-rep 3.6.2 rev0.7z , 必須比較  cd2019  所使用的\xa0 V-rep 版本後, 選擇一個版本. \n reading and display vision sensor image using python remoate api ( 來源 ) \n 改為 Python 3 相容 \n # -*- coding: utf-8 -*-\n"""\nCreated on Sun Jul 05 15:01:58 2015\n\n@author: ACSECKIN\n\npython -m pip install opencv-python\n"""\n\nimport vrep\nimport time\nimport cv2\nimport numpy as np\n\nvrep.simxFinish(-1)\n\nclientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n\nif clientID!=-1:\n    print(\'Connected to remote API server\')\n    print(\'Vision Sensor object handling\')\n    res, v1 = vrep.simxGetObjectHandle(clientID, \'vs1\', vrep.simx_opmode_oneshot_wait)\n    print(\'Getting first image\')\n    err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v1, 0, vrep.simx_opmode_streaming)\n    while (vrep.simxGetConnectionId(clientID) != -1):\n        err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v1, 0, vrep.simx_opmode_buffer)\n        if err == vrep.simx_return_ok:\n            print("image OK!!!")\n            img = np.array(image,dtype=np.uint8)\n            img.resize([resolution[1],resolution[0],3])\n            cv2.imshow(\'image\',img)\n            if cv2.waitKey(1) & 0xFF == ord(\'q\'):\n                break\n        elif err == vrep.simx_return_novalue_flag:\n            print("no image yet")\n            pass\n        else:\n          print(err)\nelse:\n  print("Failed to connect to remote API Server")\n  vrep.simxFinish(clientID)\n\ncv2.destroyAllWindows() \n pythonBubbleRob.pdf \n lua_one_link_remote_api.7z \n V-rep 系統目錄中的\xa0remoteApiConnections.txt 可以同時啟動多個 port 允許多 client 連線: \n // This file defines all the continuous remote API server services (started at remote API plugin initialization, i.e. V-REP start-up)\n//\n// Each remote API server service requires following 3 entries:\n//\n// portIndex@_port = xxxx               // where xxxx is the desired port number (below 19997 are preferred for server services starting at V-REP start-up)\n// portIndex@_debug = xxxx              // where xxxx is true or false\n// portIndex@_syncSimTrigger = xxxx     // where xxxx is true or false. When true, then the service will be pre-enabled for synchronous operation.\n//\n// In above strings, @ can be any number starting with 1. If more than one server service is required, then numbers need to be consecutive and starting with 1\n\n// Let\'s start a continuous remote API server service on port 19997:\nportIndex1_port             = 19997\nportIndex1_debug            = false\nportIndex1_syncSimTrigger   = true\n\nportIndex2_port             = 19998\nportIndex2_debug            = false\nportIndex2_syncSimTrigger   = true\n \n \n 在遠端的多台電腦, 可以利用 \n clientID = vrep.simxStart(\'Server_IP\', 19997, True, True, 5000, 5) \n 與 \n clientID = vrep.simxStart(\'Server_IP\', 19998, True, True, 5000, 5) \n 同時對 rempte API server 進行操控, 各 client 並可以透過上述程式取得 rempte API Server 運作時的影像, 以便利用各 client 中的 python 程式對遠端 V-rep 模擬進行遠端操控. \n 例如: 兩名使用者分別在不同電腦上對同一台 rempte API Server 中的手足球模型進行操控競賽. \n 以下為另外一個參考程式: \n import vrep\n\nprint(\'Program started\')\nvrep.simxFinish(-1) # just in case, close all opened connections\nclientID=vrep.simxStart(\'127.0.0.1\',19999,True,True,5000,5)\nif clientID!=-1:\n    print(\'Connected to remote API server\')\n    res,v0=vrep.simxGetObjectHandle(clientID,\'Vision_sensor\',vrep.simx_opmode_oneshot_wait)\n    res,v1=vrep.simxGetObjectHandle(clientID,\'PassiveVision_sensor\',vrep.simx_opmode_oneshot_wait)\n\n    res,resolution,image=vrep.simxGetVisionSensorImage(clientID,v0,0,vrep.simx_opmode_streaming)\n    while (vrep.simxGetConnectionId(clientID)!=-1):\n        res,resolution,image=vrep.simxGetVisionSensorImage(clientID,v0,0,vrep.simx_opmode_buffer)\n        if res==vrep.simx_return_ok:\n            res=vrep.simxSetVisionSensorImage(clientID,v1,image,0,vrep.simx_opmode_oneshot)\n    vrep.simxFinish(clientID)\nelse:\n    print(\'Failed connecting to remote API server\')\nprint(\'Program ended\') \n 此外 system 目錄下的\xa0usrset.txt 可以進行客製化設定 \n 參考資料 \n Virtual Experiments Design for Robotics Based on V-REP.pdf \n Adaptive Biped Locomotion from a Single Demonstration Using Motion Primitives.pdf', 'tags': '', 'url': 'V-rep.html'}, {'title': 'V-rep Manual', 'text': 'http://www.coppeliarobotics.com/helpFiles/index.html \n V-rep 支援的程式架構: \n http://www.coppeliarobotics.com/helpFiles/en/writingCode.htm \n V-rep 使用者介面 : \n http://www.coppeliarobotics.com/helpFiles/en/userInterface.htm \n V-rep 場景與模型: \n http://www.coppeliarobotics.com/helpFiles/en/scenesAndModels.htm \n V-rep 模擬元件: \n http://www.coppeliarobotics.com/helpFiles/en/entities.htm \n V-rep 運算模組: \n http://www.coppeliarobotics.com/helpFiles/en/calculationModules.htm \n V-rep 模擬: \n http://www.coppeliarobotics.com/helpFiles/en/simulation.htm \n V-rep 錄影: \n http://www.coppeliarobotics.com/helpFiles/en/aviRecorder.htm \n Lua 簡介: \n http://www.coppeliarobotics.com/helpFiles/en/luaCrashCourse.htm \n V-rep 教學導引 : \n http://www.coppeliarobotics.com/helpFiles/en/tutorials.htm \n V-rep 編譯: \n http://www.coppeliarobotics.com/helpFiles/en/compilingVrep.htm', 'tags': '', 'url': 'V-rep Manual.html'}, {'title': '3D Printer', 'text': 'Create Shape from path \n http://www.forum.coppeliarobotics.com/viewtopic.php?f=9&t=7920 \n Question: \n Can\xa0 http://www.coppeliarobotics.com/helpFiles/en/regularApi/simCreateMeshShape.htm \xa0be used to create virtual printing function?', 'tags': '', 'url': '3D Printer.html'}, {'title': 'Cyber-physical', 'text': 'Virtual vs Real Controller \n http://www.forum.coppeliarobotics.com/viewtopic.php?f=9&t=7906 \n http://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm \n', 'tags': '', 'url': 'Cyber-physical.html'}, {'title': 'FreeCAD', 'text': 'FreeCAD 0.18.7z \xa0 (登入 gm.nfu.edu.tw 後下載) - 電腦輔助設計實習課程專用 \n', 'tags': '', 'url': 'FreeCAD.html'}, {'title': 'Webots', 'text': '官方網站:\xa0 https://cyberbotics.com/ \n 原始碼:\xa0 https://github.com/cyberbotics \n https://github.com/cyberbotics/webots/releases \n https://github.com/cyberbotics/blender-webots-exporter \n 2018 論文 - Robot Design for Everyone: Computational Tools that Democratize the Design of Robots ( 下載 ) \n Part1:\xa0 Robot Design for Everyone_1_2.pdf \n Part2:\xa0 Robot Design for Everyone_2_2.pdf \n V-rep  早在 2013 年初就 率先開源 , 而同樣來自瑞士 ( V-rep \xa0 2010  推出模擬套件 , 公司在  2014 成立 ,  Webots 則在 1998 年 從  EPFL  轉出成立公司) 的\xa0 Webots \xa0也在 2018 年底 宣布開源 \n 這兩套機電資整合系統模擬套件之所以選擇透過軟體開源行銷, 背後可能的思考參見: \n https://opensource.com/life/15/12/why-open-source \n https://rubygarage.org/blog/why-open-source-is-good-for-business \n \n Webots APIs Overview \n \n \n Webots_2019b_rev1.7z  (登入 gm.nfu.edu.tw 後下載) \n Webots 啟動條件: \n 執行路徑設定 \n set path_webots=%Disk%:\\Webots_2019b_rev1\\msys64\\mingw64\\bin;%Disk%:\\Webots_2019b_rev1\\msys64\\usr\\bin \n 啟動指令: \n 在 y:\\ 根目錄建立 start_webots.bat, 內容為: \n start Y:\\Webots_2019b_rev1\\msys64\\mingw64\\bin\\webots.exe \n 當隨身程式系統納入上述兩個條件並啟動後, 可以直接在命令列輸入 start_webots.bat 啟動. \n Webots 執行時, 會將 prefs 相關設定存在 Registry 中: \n Computer\\HKEY_USERS\\...\\Software\\Cyberbotics\\Webots-R2019b \n 包括:\xa0 \n Directories - \n Editor - \n General - \n Internal - \n MainWindow - \n Movie - \n Network - \n OpenGL - \n RecentFiles - \n Sound - \n View3d -\xa0 \n VirtualRealityHeadset - \n 其中, 在 Tools->Preferences 只開放\xa0 General, OpenGL 與 Network 等三項透過視窗表單設定. \n Webots 組態設定檔案:  windows10_webots_registry.7z \n \n Webots Tutorial \n https://cyberbotics.com/doc/guide/tutorials \n webots_ex1.pdf \n webots_lab2.pdf \n webots_user_guide_2004.pdf \n webots_curriculum_2008.pdf \n https://cyberbotics.com/doc/guide/tinkerbots \n Revolve-An Evolutionary Robotics.pdf \n https://www.idi.ntnu.no/emner/it3708/index.php \n Analysis of Simple Planar Linkages.pdf \n Tutorial 1 \n 這裡的 World 指由機電資系統整合模擬者所建構的\xa0 system of created things (造物系統), 在 V-rep 此一包含模擬環境設定的模型稱為 Scene (場景), 而在 Webots 則可稱為 World (模擬世界). \n A  World \xa0(模擬世界) is a file containing information like where the objects are, what they look like, how they interact with each other, what is the color of the sky, how is defined the gravity, friction, masses of the objects, etc. It defines the initial state of a simulation. The different objects are called  Nodes \xa0(節點) and are organized hierarchically in a  Scene Tree  (場景樹). Therefore, a node may contain sub-nodes. A world is stored in a file having the  .wbt extension . The file format is  derived from the VRML97 language , and is human readable. The world files must be stored directly in a  directory called worlds . \n VRML_lecture.pdf \n intro_vrml97.pdf \n vrml_2.0_specification.pdf \n VRML Primer and Tutorial.pdf \n https://www.whoishostingthis.com/resources/vrml/ \n Studying Geometry Color and Texture in VRML.pdf \n 標準檔案架構 \n The Root Directory of a Project \n The root directory of a project contains at least a directory called "worlds" containing a single world file. But several other directories are often required: \n "controllers": this directory contains the controllers available in each world files of the current project. The link between the world files and this directory is done through the controller field of the Robot node. More information about this directory in the following subsections. \n "protos": this directory contains the PROTO files available for all the world files of the current project. \n "plugins": this directory contains the plugins available in the current project. The link between the world files and this directory is done through the physics field of the WordInfo node. \n "worlds": this directory contains the world files, the project files (see below) and the textures (typically in a subdirectory called "textures"). \n The Project Files \n The project files contain information about the GUI (such as the perspective). These files are hidden. Each world file can have one project file. If the world file is named "myWorldFile.wbt", its project file is named ".myWorldFile.wbproj". This file is written by Webots when a world is correctly closed. Removing it allows you to retrieve the default perspective. \n The "controllers" Directory \n This directory contains the controllers. Each controller is defined in a directory. A controller is referenced by the name of the directory. Here is an example of the controllers directory having one simple controller written in C which can be edited and executed. \n controllers/ controllers/simple_controller/ controllers/simple_controller/Makefile controllers/simple_controller/simple_controller.c controllers/simple_controller/simple_controller[.exe] \n 場景導航 \n Dragging the mouse while pressing a mouse button moves the camera of the 3D window. \n Camera rotation: In the 3D window, click on an object with the left mouse button and drag the mouse to rotate the viewpoint around it. If you click on the background, the camera will rotate around its own position. \n Camera translation: In the 3D window, press the right button and drag the mouse to translate the camera. \n Zooming / Camera rotation: In the 3D window, press both left and right mouse buttons simultaneously (or just the middle button) and drag the mouse vertically, to zoom in and out. Dragging the mouse horizontally will rotate the camera around the viewing axis. Alternatively, the mouse wheel alone can also be used for zooming. \n 移動與縮放物體 \n Currently Webots provides two different ways to move solid objects: axis-aligned handles and keyboard shortcuts. \n Axis-aligned Handles \n When a solid object is selected, some arrow-shaped handles appear in the 3D window. These handles can be used to translate and rotate the object along the corresponding axis. For moving the object you can simply click on the handle and drag it to the desired position. A label will show the currect relative translation or rotation during the movement. \n If the Control key (Ctrl) is pressed, the handles for resizing the solid object will be displayed instead of translation and rotation handles. These resize handles can also be enabled from the Field Editor. \n 快捷鍵 \n Translation: To move an object parallel to the ground: hold down the Shift key, press the left mouse button and drag. \n Rotation: To rotate an object around the world\'s vertical axis: hold down the Shift key, press the right mouse button and drag. \n Lift: To raise or lower an object: hold down the Shift key, press both left and right mouse buttons (or the middle button) and drag. Alternatively, the mouse wheel combined with the Shift key can also be used. \n Applying a Force to a Solid Object with Physics \n To apply a force to an object, place the mouse pointer where the force will apply, hold down the Alt key and left mouse button together while dragging the mouse. \n Linux users should also hold down the Control key (Ctrl) together with the Alt key. This way your are drawing a 3D-vector whose end is located on the plane parallel to the view which passes through the point of application. The intensity of the applied force is directly proportional to the cube of the length of this vector. \n Applying a Torque to a Solid Object with Physics \n To apply a torque to an object, place the mouse pointer on it, hold down the Alt key and right mouse button together while dragging the mouse. \n Linux users should also hold down the Control key (Ctrl) together with the Alt key. Also, macOS users with a one-button mouse should hold down the Control key (Ctrl) to emulate the right mouse button. This way your are drawing a 3D-vector with origin the center of mass and whose end is located on the plane parallel to the view which passes through this center. The object is prompted to turn around the vector direction, the intensity of the applied torque is directly proportional to the product of the mass by the length of the 3D-vector. \n Solvespace 零件尺寸與 Webots \n 因為 Webots 內建的尺寸單位為 m, 因此利用 Import 導入 wrl 檔案時, 該檔案從 Solvespace 以 mm 尺寸執行繪圖後, 轉為 wrl 後導入 Webots, 若 Solvespace 以 mm 數字輸出, 則必須將 scale 調整為 1/1000, 才能夠將該 mm 數字轉為 m, 得到正確的零件尺寸. 一般在 Solvespace 均以 mm 作圖, 因此轉出 wrl 時必須注意轉出內容與所使用繪圖單位之間的轉換. \n Solvespace 與轉出檔案有關的 export scale factor 在 home->configuration 中, 內建為 1, 以 mm 單位輸出, 若要改為以 m 輸出, 可將 export scale factor 設為 1:1000. \n 使用者可以將零件從 Solvespace 轉出 wrl 後, 在 transform 中加入 \n scale 0.001 0.001 0.001 \n 後重新存檔, 就可以在 Import 轉入 Webots 後, 得到正確的尺寸. 也可以修改 Solvespace 的原始碼, 自動在轉出的 wrl 檔案中加入 scale 轉換, 改以 m 作為尺寸單位. \n 另外, 由於 Webots 無法解讀從 Solvespace 轉出 wrl 檔案中的  colorPerVertex, color 以及 colorIndex  等三種欄位資料, 因此也可以在修改 scale 時將這些欄位資料刪除. 或從 Solvespace 原始碼中進行修改. \n 例如: \n #VRML V2.0 utf8\n#Exported from SolveSpace 3.0\n\nDEF a1m_block Transform {\n  scale 0.001 0.001 0.001\n  children [\n    Shape {\n      appearance Appearance {\n        material DEF a1m_block_material_255 Material {\n          diffuseColor 0.300000 0.300000 0.300000\n          ambientIntensity 0.300000\n          transparency 0.000000\n        }\n      }\n      geometry IndexedFaceSet {\n        colorPerVertex TRUE\n        coord Coordinate { point [\n          -50.400000 50.000000 1000.000000,\n          -50.400000 -0.000000 1000.000000,\n          0.000000 50.000000 1000.000000,\n          0.000000 -0.000000 1000.000000,\n          -50.400000 -0.000000 0.000000,\n          -50.400000 50.000000 0.000000,\n          0.000000 -0.000000 0.000000,\n          0.000000 50.000000 0.000000,\n        ] }\n        coordIndex [\n          0, 1, 2, -1,\n          2, 1, 3, -1,\n          4, 5, 6, -1,\n          6, 5, 7, -1,\n          3, 1, 6, -1,\n          6, 1, 4, -1,\n          1, 0, 4, -1,\n          4, 0, 5, -1,\n          0, 2, 5, -1,\n          5, 2, 7, -1,\n          2, 3, 7, -1,\n          7, 3, 6, -1,\n        ]\n        color Color { color [\n          0.3921568692 0.3921568692 0.3921568692,\n        ] }\n        colorIndex [\n          0, 0, 0, -1,\n          0, 0, 0, -1,\n          0, 0, 0, -1,\n          0, 0, 0, -1,\n          0, 0, 0, -1,\n          0, 0, 0, -1,\n          0, 0, 0, -1,\n          0, 0, 0, -1,\n          0, 0, 0, -1,\n          0, 0, 0, -1,\n          0, 0, 0, -1,\n          0, 0, 0, -1,\n        ]\n      }\n    }\n  ]\n}\n \n E-Puck Python control program \n """e-puck controller."""\n\nfrom controller import DifferentialWheels\n\nrobot = DifferentialWheels()\n\nmaxSpeed = 1000.0\nspeed = 500.0\ntimestep = int(robot.getBasicTimeStep())\n\ndef clamp(value, minValue, maxValue):\n    return max(minValue, min(maxValue, value))\n\ndistanceSensors = []\nfor i in range(8):\n    name = \'ps\' + str(i)\n    distanceSensor = robot.getDistanceSensor(name)\n    distanceSensor.enable(timestep)\n    distanceSensors.append(distanceSensor)\n\nwhile robot.step(timestep) != -1:\n    delta = distanceSensors[7].getValue() - distanceSensors[0].getValue()\n    robot.setSpeed(\n        clamp(speed + 4 * delta, -maxSpeed, maxSpeed),\n        clamp(speed - 4 * delta, -maxSpeed, maxSpeed)\n    ) \n 利用可攜系統中的 SciTE 控制 Webots 模擬世界 \n 目前\xa0 Webots_2019b_rev1.7z \xa0啟用 Python 執行 controller 程式時, 使用可攜系統所安裝的 Python 3.7 版, 假如要使用 SciTE 執行 Webots 中模擬世界中的 Controller, 必須: \n 1. 將 Webots 中 python 3.7 動態程式庫與 bin 中的 c++ 動態程式庫目錄, 納入可攜 Python 程式庫路徑設定, 例如: \n set PYTHONPATH=%CDisk%\\py373\\DLLs;%CDisk%\\py373\\Lib;%CDisk%\\py373\\Lib\\site-packages;Y:\\Webots_2019b_rev1\\msys64\\mingw64\\bin;Y:\\Webots_2019b_rev1\\lib\\python37; \n 2.\xa0 將模型中 controller 設為 <extern>, 然後啟動 Webots 模擬後, 以 SciTE 開啟位於 controller 目錄中的控制器 python 程式後, 以 Tools->Go 執行 controller 程式, 以便控制 Webots 中的對應模型. \n Controller Programming \n https://cyberbotics.com/doc/guide/controller-programming \n Web Simulation \n https://cyberbotics.com/doc/guide/web-simulation \n TCP/IP interface \n https://cyberbotics.com/doc/guide/interfacing-webots-to-third-party-software-with-tcp-ip \n SolidReference \n https://cyberbotics.com/doc/reference/solidreference \n Worldinfo \n https://www.cyberbotics.com/doc/reference/worldinfo \n Webots and Python Controller \n When Webots launches a controller program, it searches inside the controller folder for a binary file with the same name as the folder, e.g., my_controller/my_controller.exe. if not found, it will try to copy it from the my_controller/build folder. If not such folder exists, it will try other possibilities, including launching my_controller/my_controller.py. This is certainly what you want to achieve. Therefore, I would recommend you to delete any file and subfolder from your controller folder except your Python controller program. That should fix your problem. \n https://stackoverflow.com/questions/55702930/how-to-program-a-controller-using-python3 \n https://cyberbotics.com/doc/guide/using-python \n https://cyberbotics.com/doc/guide/controller-programming#languages-settings \n Webots Nodes and API functions \n https://www.cyberbotics.com/doc/reference/nodes-and-api-functions \n VRML viewer in Javascript \n https://github.com/easyw/vrm360 \n Numerical Optimization Methods \n https://cyberbotics.com/doc/guide/using-numerical-optimization-methods \n Webots archive \n https://www.cyberbotics.com/archive/ \n Closed Chain \n The  SolidReference  is a placeholder of a Solid nodes and can be inserted in the joint \'endPoint\' field to link two separate structures together. \n 參考資料 \n https://janus.conf.meetecho.com/ \n https://github.com/Phylliade/ikpy \n https://www.x3dom.org/ \n https://github.com/x3dom/x3dom \n 2016 報價: 約 NT$ 400,000. ( https://www.cyberbotics.com/e-puck \xa0約 NT$ 25,000.) \n', 'tags': '', 'url': 'Webots.html'}, {'title': 'VRML', 'text': 'https://cyberbotics.com/doc/reference/group \n https://cyberbotics.com/doc/reference/transform \n https://cyberbotics.com/doc/reference/solid \n https://cyberbotics.com/doc/reference/robot \n Group 節點 \n A Group node contains children nodes without introducing a new transformation. It is equivalent to a Transform node without the "translation" and "rotation" fields. \n Transform 節點 \n The Transform node is a grouping node that defines a coordinate system for its children that is relative to the coordinate system of its parent. The \'scale\' field of a Transform node can be adjusted only in a graphical context and not in a \'boundingObject\' context. \n Shape 節點 \n A Shape node is a visual objects that includes both an \'appearance\' and a \'geometry\'. A Shape can also be used in a \'boundingObject\', in this case, only its \'geometry\' field is taken into account. \n 建立模擬世界的地板 \n 第一階段: 先定義一個 Transform 節點, 然後在其下的 children 新增一個 Shape 節點, 然後將 Shape 節點中的 geometry 欄位設為 plane. 接著將此 Shape 命名 (DEF) 為 floor. \n 第二階段: 將第一階段所建立的 Transform 節點, 轉 (Transform to) 為 Solid 節點. 再將此一 Solid 命名為 FLOOR 後, 將此 FLOOR Solid 中的 boundingObject 欄位指定為第一階段所定義的 floor Shape 節點. 意即要以此 plane Shape 節點作為此 FLOOR Solid olid 節點的邊界物件. \n 第三階段: 利用 File -> Save World 將所加入的地板實體節點內容存檔. \n #VRML V2.0 utf8\n\nSwitch {\n  choice [\n    DEF RedSphere Shape {\n      appearance Appearance {\n        material Material { diffuseColor 1 0 0 } }\n      geometry Sphere { }\n    }\n    DEF GreenSphere Shape {\n      appearance Appearance {\n        material Material { diffuseColor 0 1 0 } }\n      geometry Sphere { }\n    }\n    DEF BlueSphere Shape {\n      appearance Appearance {\n        material Material { diffuseColor 0 0 1 } }\n      geometry Sphere { }\n    }\n    DEF SphereColumn Group {\n      children [\n        Transform { translation 0 -5 0 children USE RedSphere }\n        Transform { translation 0  0 0 children USE GreenSphere }\n        Transform { translation 0  5 0 children USE BlueSphere }\n      ]\n    }\n  ]\n}\n\nTransform { translation -5 0 0 children USE SphereColumn }\nTransform { translation  0 0 0 children USE SphereColumn }\nTransform { translation  5 0 0 children USE SphereColumn } \n 控制程式 \n from controller import Robot, Motor\n\nTIME_STEP = 64\n\n# create the Robot instance.\nrobot = Robot()\n\n# get the motor devices\nleftMotor = robot.getMotor(\'left wheel motor\')\nrightMotor = robot.getMotor(\'right wheel motor\')\n# set the target position of the motors\nleftMotor.setPosition(10.0)\nrightMotor.setPosition(10.0)\n\nwhile robot.step(TIME_STEP) != -1:\n   pass \n 參考資料 \n https://github.com/cyberbotics/urdf2webots \n https://github.com/cyberbotics/blender-webots-exporter \n https://github.com/sobotka/blender-addons/blob/master/io_scene_x3d/import_x3d.py \xa0(也許可以將此程式改為 Leo Editor 的 VRML\xa0 parser plugin)', 'tags': '', 'url': 'VRML.html'}, {'title': 'SciTE', 'text': 'https://github.com/mirror/scite \n https://github.com/mirror/scintilla \n 利用 MSYS2 編譯 SciTE 編輯器: \n git clone  https://github.com/mirror/scite.git \xa0 \n git clone  https://github.com/mirror/scintilla.git \n cd scintilla\\win32 \n get\xa0Scintilla.dll and\xa0SciLexer.dll under\xa0 scintilla\\bin \n mingw32-make \n cd scite\\win32 \n mingw32-make \n get\xa0SciTE.exe under scite\\bin \n need extra\xa0libgcc_s_seh-1.dll,\xa0libstdc++-6.dll and\xa0libwinpthread-1.dll along with  Scintilla.dll and\xa0 SciLexer.dll\xa0 to execute SciTE.exe \n SciTE properties files:  SciTE_properties_files.7z \n 上述編譯流程所有檔案:  compile_scite.7z \n', 'tags': '', 'url': 'SciTE.html'}, {'title': 'WB Tutorial1', 'text': 'Webots 啟動條件: \n 執行路徑設定 \n set path_webots=%Disk%:\\Webots_2019b_rev1\\msys64\\mingw64\\bin;%Disk%:\\Webots_2019b_rev1\\msys64\\usr\\bin \n 啟動指令: \n 在 y:\\ 根目錄建立 start_webots.bat, 內容為: \n start Y:\\Webots_2019b_rev1\\msys64\\mingw64\\bin\\webots.exe \n 當隨身程式系統納入上述兩個條件並啟動後, 可以直接在命令列輸入 start_webots.bat 啟動. \n 建立新專案 \n 利用下拉式功能表中的 Wizards 精靈, 選擇 New Project Directory.\xa0 將會自動建立: \n controllers \n libraries \n plugins \n protos \n worlds\xa0 \n 等目錄. 各目錄內容說明如下: \n The Root Directory of a Project \n The root directory of a project contains at least a directory called "worlds" containing a single world file. But several other directories are often required: \n "controllers": this directory contains the controllers available in each world files of the current project. The link between the world files and this directory is done through the controller field of the Robot node. More information about this directory in the following subsections. \n "protos": this directory contains the PROTO files available for all the world files of the current project. \n "plugins": this directory contains the plugins available in the current project. The link between the world files and this directory is done through the physics field of the WordInfo node. \n "worlds": this directory contains the world files, the project files (see below) and the textures (typically in a subdirectory called "textures").', 'tags': '', 'url': 'WB Tutorial1.html'}, {'title': 'Three.js', 'text': 'https://github.com/mrdoob/three.js \n https://github.com/josdirksen/essential-threejs \n https://github.com/josdirksen/learning-threejs-third \n https://www.web3d.org/ \n https://www.x3dom.org/ \n http://mde.tw/cp2019/content/Javascript.html \n', 'tags': '', 'url': 'Three.js.html'}, {'title': 'Solidworks', 'text': 'STL to part:\xa0 https://grabcad.com/tutorials/convert-stl-mesh-to-solidworks-model-nurbs \n 登入 @gm 電子郵箱, 可以 下載 SolidWorks 2017 SP2 安裝光碟 ), 或是已經安裝好的  SolidWorks 2017 SP2 虛擬主機版本 . \n solidworks_basics.pdf \n Solidworks_EDU_Drawing_Exercises_2010_ENG.pdf \n Solidworks_tutorial_exercise.pdf \n SolidWorks_2010_軟體教師手冊.pdf \xa0( 英文版 ) ( 2013 版 ) \n SolidWorks_2010_ 軟體學生手冊.pdf \n SolidWorks_Tutorial08_BearingPuller_English_08_LR.pdf \n SolidWorks_Simulation_執行應力分析簡介.pdf \xa0( 英文版 ) \n SolidWorks_Simulation_Instructor_Guide_2010_ENG.pdf \n 使用 SolidWorks Simulation 執行應力 分析的簡介 講師指南.pdf \n Solidworks_Mountainboard_Design_Project_Student_2010_LR_ENG.pdf \n Solidworks_SIM_2010_HOTD_ENG.pdf \n Mountainboard_Student_WB_2011_ENG.pdf \n Solidworks_2010_Bridge_Design_Project_ENG.pdf \n Solidworks_Motion_Instructor_Guide_2010_ENG.pdf \n Solidworks_Flow_Simulation_Instructor_Guide_2010_ENG.pdf \n Solidworks_CO2_Car_Project_Workbook_2010_ENG.pdf \n Solidworks_CSWPAdvancedSheetMetalSampleExam.pdf \n Solidworks_DRWT Sample Exam.pdf \n Solidworks_Sample CSWP-SURF Advanced Surfacing Certification Exam.pdf \n Solidworks_CSWP-WLDM Sample Exam.pdf \n Solidworks_CSWP-FEA Sample Exam 2011.pdf \n downloads 目錄中 Solidworks_Tutorial 子目錄中的 pdf 教學檔案', 'tags': '', 'url': 'Solidworks.html'}, {'title': 'SW API', 'text': 'INTEGRATION OF MODELING IN SOLIDWORKS AND MATLAB/SIMULINK ENVIRONMENTS.pdf \n import win32com.client\nimport pythoncom\nswYearLastDigit = 6\nsw = win32com.client.Dispatch("SldWorks.Application.%d" % (25+(swYearLastDigit-2)))  # e.g. 24 is SW2016,  25 is SW2017\n\nmodel = sw.ActiveDoc\nmodelExt = model.Extension\nselMgr = model.SelectionManager\nfeatureMgr = model.FeatureManager\nsketchMgr = model.SketchManager\neqMgr = model.GetEquationMgr\n\nprint("Equation 1 is: " + eqMgr.Equation(1))\neqMgr.Equation(1, "\\"myVar\\" = 2017")\nprint("Equation 1 is now: " + eqMgr.Equation(1)) \n', 'tags': '', 'url': 'SW API.html'}, {'title': 'Solid Edge', 'text': 'https://www.plm.automation.siemens.com/plmapp/education/solid-edge/en_us/free-software/student \n', 'tags': '', 'url': 'Solid Edge.html'}, {'title': 'NX', 'text': 'Space Modeling with SolidWorks and NX.pdf \n https://docs.plm.automation.siemens.com/docs/nx/12.0.1/en_US/release_notes.pdf \n https://docs.plm.automation.siemens.com/tdoc/nx/12/nx_help/ \n NX12 for engineering design.pdf \n parametric_modeling_with_nx12.pdf \n nxopen_getting_started_v12.pdf \n NXOpen Python Guide: \n https://docs.plm.automation.siemens.com/data_services/resources/nx/12/nx_api/custom/en_US/nxopen_python_ref/index.html \n import math\nimport NXOpen\nimport NXOpen.UF\n\ndef BoundingBox() : \n\n    theSession  = NXOpen.Session.GetSession()\n    theUFSession = NXOpen.UF.UFSession.GetUFSession()\n    workPart = theSession.Parts.Work\n    \n    size = theSession.ListingWindow\n    size.Open()\n    size.WriteLine("Bounding Boxes:")\n\n    NULLTAG = 0\n\n    all_bodies = workPart.Bodies\n    bounding_Box_Coords = []\n\n    for body in all_bodies:\n        bounding_Box_Coords = theUFSession.ModlGeneral.AskBoundingBox(body.Tag) \n\n        size.WriteLine(str(bounding_Box_Coords[0]) + "  ")\n        size.WriteLine(str(bounding_Box_Coords[1]) + "  ")\n        size.WriteLine(str(bounding_Box_Coords[2]) + "  ")\n        size.WriteLine(str(bounding_Box_Coords[3]) + "  ")\n        size.WriteLine(str(bounding_Box_Coords[4]) + "  ")\n        size.WriteLine(str(bounding_Box_Coords[5]))\n        size.WriteLine("  ")\n\n    \nif __name__ == \'__main__\':\n    BoundingBox() \n nx12_python_setup \n NX3 \n 登入 @gm 電子郵箱, 就可以 下載 NX3_portable.7z , 解開壓縮檔放入隨身碟, 並且連上網路擷取授權認證後, 就可以使用. \n 滑鼠中鍵加上右鍵 - Pan \n UG-NX3-Tutorial.pdf \n UG-NX_Drafting.pdf \n nx2_UGOPEN_API.pdf \n MoldWizard_handbook .pdf \n Knowledge-Fusion.pdf \n 6539345-Knowledge-Fusion.pdf \n gears.pdf \n Gear.zip \xa0(UGOPEN example) \n UG_WAVE_ref.7z \n NX3_samples.7z \n UG_NX6_Intro-2010.pdf \n CADCAECAM_Review.pdf \n UG_NX6_Buttons.pdf \n NX12 \n 登入 @gm 電子郵箱, 可以 下載 NX 12.0.2 安裝光碟 \xa0(Windows 64 位元),  下載 Linux NX12.0.2 安裝光碟 , 或者 下載 NX12.0.2 虛擬主機板本 , 或者 下載 NX12 可攜版本 . \n 可否利用 NX12 執行  Computer Aided Virtual Manufacturing Using Creo Parametric - Easy to Learn Step by Step Guide.pdf \xa0中的所有步驟? \n How to Speed up Your NX.pdf \n NX12.0.2_release_notes.pdf \xa0( FlexNet 2015 License Administration Guide.pdf ) \n With the creation of the central runtime directory, there are two different locations for these files (nxbin and ugii), so the concept of UGII_ROOT_DIR is obsoleted. Use the UGII_BASE_DIR variable instead when you write custom application code and scripts \n The minimum recommended amount of memory to run native NX is 8GB \n SuSE Linux Enterprise Server/Desktop 12 Red Hat Enterprise Linux Server/Desktop 7 \n IPv6 Support: \n \n In license and options files, FlexNet Publisher supports only the site-local form of the IPv6 address (those prefixed with FEC0). (請注意: Virtualbox 的 Host only 網路 IPv4/IPv6 位址從控制台中的\xa0VirtualBox Host-Only Network 設定中取得, 另外當採純 IPv4 建置認證與 client 電腦之後, 可以再透過\xa0 https://www.softether.org/ \xa0建構 VPN 環境, 讓 client 可以從外部網段取得所需套件認證) \n While IPv6 address can be used in license or options files, the best-practice recommended is to use hostname or IPv4 address. \n If IPv6 address is used in the license or options file, then the FNP_IP_PRIORITY environment variable will need to be set (FNP_IP_PRIORITY=6). \n A mix of IPv4 and IPv6 addresses in the license and/or options file is not supported. \n \n FlexNet Publisher \n https://en.wikipedia.org/wiki/FlexNet_Publisher \n FlexNet Publisher v11.15.0.0 for Windows 64-bit.zip \n FlexNet Publisher 2018 R4.pdf  (Version 11.16.2) \n FlexNet Publisher v11.15.0.0 for Linux 64-bit.tgz \n https://developer.arm.com/tools-and-software/software-development-tools/license-management/downloads# \n https://helpnet.flexerasoftware.com/eol/flexnet-publisher.htm \n Siemens PLM Licensing User Guide.pdf \n NX Installation Guide for Linux and Mac OS X.pdf \n NX-12-for-Engineering-Design.pdf \n Journaling:\xa0 http://www.nxjournaling.com/content/beginning-journaling-using-nx-journal \n nxopen_getting_started_v12.pdf \n SNAP_Getting_Started_v12.pdf \n NX Nastran 12 - Release Guide.pdf \n NX12_NASTRAN_get_start.pdf \n NX Nastran 12 - Quick Reference Guide.pdf \n NX Nastran 12 - Advanced Nonlinear Theory and Modeling Guide.pdf', 'tags': '', 'url': 'NX.html'}, {'title': 'NX12 程式', 'text': 'NX12 for Engineering Design.pdf \xa0-> 分組任務: 根據  2015- Space Modeling with SolidWorks and NX \xa0中的 NX 資料與本電子書內容, 完成中英文並列的\xa0 NX12 教學導引分組報告. \n NXOpen \n NX12 NXOpen 支援程式版本 \n nxopen_getting_started_v12.pdf \xa0- 分組任務: 將本電子書中的 .NET 範例改寫為  NXOpen Python 版本範例 , 並提供每一個程式範例的執行教學影片. \n Setup_Eclipse_for_NXOpenPythonScripting.pdf \n https://docs.plm.automation.siemens.com/data_services/resources/nx/12/nx_api/custom/en_US/nxopen_python_ref/index.html \n http://nxjournaling.com/ \n eng-tips.com about NXOpen and Python \n run_journal 指令 可以直接執行外部的 NXOpen Python Journal 程式 \n \n \n \n \n \n 環境變數 \n REM nx use python 3.6.1\nREM Python 位於 Y:\\NX12\\NXBIN\\python\nset PYTHONPATH=y:\\py373;Y:\\NX12\\NXBIN\\python\nUGII_PYTHON_HOME=y:\\py373;Y:\\NX12\\NXBIN\\python\nUGII_PYTHON_LIBRARY_DIR=y:\\py373\nUGII_PYTHONPATH=y:\\py373;y:\\py373\\dlls;y:\\py373\\libs;y:\\py373\\lib;y:\\py373\\lib\\site-packages\nUGII_PYTHON_DLL=python37.dll\nTCL_LIBRARY=y:\\py373\\tcl\\tcl8.6 \n NXOpen Python Remote \n https://docs.plm.automation.siemens.com/data_services/resources/nx/12/nx_api/custom/en_US/nxopen_python_ref/NXOpen.RemoteUtilities.html \n .Net 相關範例:\xa0Y:\\NX12\\UGOPEN\\SampleNXOpenApplications\\.NET\\RemotingExample \n File -> Preferences -> User Interface -> Tools - > Journal 可以將 Journal Language 設為 Python. \n Menu -> Tools -> Journal 可以選擇錄製 Journal File. \n 利用 Menu -> Tools -> Journal 可以選擇 play 所錄製的 .py Journal File, 點選 Play 後, 選擇鎖鑰執行的 .py Journal 檔案後, 按下 Run 執行. \n 利用\xa0 NXOpen API Python 程式建立 Cube: \n # NX 12.0.2.9\n\n#\nimport math\nimport NXOpen\nimport NXOpen.Annotations\nimport NXOpen.Features\nimport NXOpen.GeometricUtilities\nimport NXOpen.Preferences\n\ndef main() : \n\n    theUI = NXOpen.UI.GetUI()\n    theMsgBox = theUI.NXMessageBox\n    theMsgBox.Show("簡要說明", NXOpen.NXMessageBox.DialogType.Information,"以下流程將建立一個簡單的長方體")\n\n    theSession  = NXOpen.Session.GetSession()\n\n    # 以下利用 ListingWindow 列出相關資訊, 可用於程式除錯\n    theLw = theSession.ListingWindow\n    # 開啟 console 將資料印出\n    theLw.Open()\n    theLw.WriteLine("theSession 變數目前為: "+str(theSession))\n\n    workPart = theSession.Parts.Work\n    # ----------------------------------------------\n    #   Menu: Insert->Sketch...\n    # ----------------------------------------------\n    markId1 = theSession.SetUndoMark(NXOpen.Session.MarkVisibility.Visible, "Start")\n    \n    sketchInPlaceBuilder1 = workPart.Sketches.CreateSketchInPlaceBuilder2(NXOpen.Sketch.Null)\n    \n    origin1 = NXOpen.Point3d(0.0, 0.0, 0.0)\n    normal1 = NXOpen.Vector3d(0.0, 0.0, 1.0)\n    plane1 = workPart.Planes.CreatePlane(origin1, normal1, NXOpen.SmartObject.UpdateOption.WithinModeling)\n    \n    sketchInPlaceBuilder1.PlaneReference = plane1\n    \n    unit1 = workPart.UnitCollection.FindObject("MilliMeter")\n    \n    sketchAlongPathBuilder1 = workPart.Sketches.CreateSketchAlongPathBuilder(NXOpen.Sketch.Null)\n\n    datumAxis1 = workPart.Datums.FindObject("DATUM_CSYS(0) X axis")\n    direction1 = workPart.Directions.CreateDirection(datumAxis1, NXOpen.Sense.Forward, NXOpen.SmartObject.UpdateOption.WithinModeling)\n    \n    datumPlane1 = workPart.Datums.FindObject("DATUM_CSYS(0) XY plane")\n    datumCsys1 = workPart.Features.FindObject("DATUM_CSYS(0)")\n    point1 = datumCsys1.FindObject("POINT 1")\n    xform1 = workPart.Xforms.CreateXformByPlaneXDirPoint(datumPlane1, direction1, point1, NXOpen.SmartObject.UpdateOption.WithinModeling, 0.625, False, False)\n    \n    cartesianCoordinateSystem1 = workPart.CoordinateSystems.CreateCoordinateSystem(xform1, NXOpen.SmartObject.UpdateOption.WithinModeling)\n    \n    sketchInPlaceBuilder1.Csystem = cartesianCoordinateSystem1\n\n    origin3 = NXOpen.Point3d(0.0, 0.0, 0.0)\n    normal3 = NXOpen.Vector3d(0.0, 0.0, 1.0)\n    plane3 = workPart.Planes.CreatePlane(origin3, normal3, NXOpen.SmartObject.UpdateOption.WithinModeling)\n    \n    plane3.SetMethod(NXOpen.PlaneTypes.MethodType.Coincident)\n    \n    geom2 = [NXOpen.NXObject.Null] * 1 \n    geom2[0] = datumPlane1\n    plane3.SetGeometry(geom2)\n    \n    plane3.SetAlternate(NXOpen.PlaneTypes.AlternateType.One)\n    \n    plane3.Evaluate()\n\n    # ----------------------------------------------\n    #   Menu: Insert->Sketch Curve->Rectangle...\n    # ----------------------------------------------\n\n    markId3 = theSession.SetUndoMark(NXOpen.Session.MarkVisibility.Invisible, "Create Sketch")\n\n    nXObject1 = sketchInPlaceBuilder1.Commit()\n    \n    sketch1 = nXObject1\n    feature1 = sketch1.Feature\n    \n    sketch1.Activate(NXOpen.Sketch.ViewReorient.TrueValue)\n    \n    theSession.DeleteUndoMark(markId3, None)\n    \n    theSession.SetUndoMarkName(markId1, "Create Sketch")\n    \n    sketchInPlaceBuilder1.Destroy()\n    \n    sketchAlongPathBuilder1.Destroy()\n        \n    plane3.DestroyPlane()\n    \n    markId5 = theSession.SetUndoMark(NXOpen.Session.MarkVisibility.Invisible, "Profile short list")\n    \n    markId6 = theSession.SetUndoMark(NXOpen.Session.MarkVisibility.Invisible, "Create Rectangle")\n    \n    theSession.SetUndoMarkVisibility(markId6, "Create Rectangle", NXOpen.Session.MarkVisibility.Visible)\n    \n    # ----------------------------------------------\n    # Creating rectangle using By 2 Points method \n    # ----------------------------------------------\n    startPoint1 = NXOpen.Point3d(-52.0, 42.0, 0.0)\n    endPoint1 = NXOpen.Point3d(44.0, 42.0, 0.0)\n    line1 = workPart.Curves.CreateLine(startPoint1, endPoint1)\n    \n    startPoint2 = NXOpen.Point3d(44.0, 42.0, 0.0)\n    endPoint2 = NXOpen.Point3d(44.0, -42.0, 0.0)\n    line2 = workPart.Curves.CreateLine(startPoint2, endPoint2)\n    \n    startPoint3 = NXOpen.Point3d(44.0, -42.0, 0.0)\n    endPoint3 = NXOpen.Point3d(-52.0, -42.0, 0.0)\n    line3 = workPart.Curves.CreateLine(startPoint3, endPoint3)\n    \n    startPoint4 = NXOpen.Point3d(-52.0, -42.0, 0.0)\n    endPoint4 = NXOpen.Point3d(-52.0, 42.0, 0.0)\n    line4 = workPart.Curves.CreateLine(startPoint4, endPoint4)\n    \n    theSession.ActiveSketch.AddGeometry(line1, NXOpen.Sketch.InferConstraintsOption.InferNoConstraints)\n    \n    theSession.ActiveSketch.AddGeometry(line2, NXOpen.Sketch.InferConstraintsOption.InferNoConstraints)\n    \n    theSession.ActiveSketch.AddGeometry(line3, NXOpen.Sketch.InferConstraintsOption.InferNoConstraints)\n    \n    theSession.ActiveSketch.AddGeometry(line4, NXOpen.Sketch.InferConstraintsOption.InferNoConstraints)\n\n    theSession.ActiveSketch.Update()\n    \n    theSession.Preferences.Sketch.AutoDimensionsToArcCenter = True\n    \n    geoms1 = [NXOpen.SmartObject.Null] * 4 \n    geoms1[0] = line1\n    geoms1[1] = line2\n    geoms1[2] = line3\n    geoms1[3] = line4\n    theSession.ActiveSketch.UpdateConstraintDisplay(geoms1)\n    # ----------------------------------------------\n    #   Menu: File->Finish Sketch\n    # ----------------------------------------------\n    sketch2 = theSession.ActiveSketch\n    # ----------------------------------------------\n    #   Menu: Insert->Design Feature->Extrude...\n    # ----------------------------------------------\n    markId8 = theSession.SetUndoMark(NXOpen.Session.MarkVisibility.Visible, "Start")\n    \n    extrudeBuilder1 = workPart.Features.CreateExtrudeBuilder(NXOpen.Features.Feature.Null)\n    \n    section1 = workPart.Sections.CreateSection(0.0094999999999999998, 0.01, 0.5)\n    \n    extrudeBuilder1.Section = section1\n    \n    extrudeBuilder1.AllowSelfIntersectingSection(True)\n    \n    unit2 = extrudeBuilder1.Draft.FrontDraftAngle.Units\n  \n    features1 = [NXOpen.Features.Feature.Null] * 1 \n    sketchFeature1 = feature1\n    features1[0] = sketchFeature1\n    curveFeatureRule1 = workPart.ScRuleFactory.CreateRuleCurveFeature(features1)\n    \n    section1.AllowSelfIntersection(True)\n    \n    rules1 = [None] * 1 \n    rules1[0] = curveFeatureRule1\n    helpPoint1 = NXOpen.Point3d(-52.0, 18.603986789941445, 3.5527136788005009e-15)\n    section1.AddToSection(rules1, line4, NXOpen.NXObject.Null, NXOpen.NXObject.Null, helpPoint1, NXOpen.Section.Mode.Create, False)\n\n    direction2 = workPart.Directions.CreateDirection(sketch2, NXOpen.Sense.Forward, NXOpen.SmartObject.UpdateOption.WithinModeling)\n    \n    extrudeBuilder1.Direction = direction2\n    \n    extrudeBuilder1.Limits.EndExtend.Value.RightHandSide = "50"\n\n    extrudeBuilder1.ParentFeatureInternal = False\n    \n    feature2 = extrudeBuilder1.CommitFeature()\n\n    # ----------------------------------------------\n    #   Menu: Tools->Journal->Stop Recording\n    # ----------------------------------------------\n    \nif __name__ == \'__main__\':\n    main() \n bounding_box.py \n import NXOpen\nimport NXOpen.UF\n\ntheSession = NXOpen.Session.GetSession()\ntheLw = theSession.ListingWindow\ntheUI = NXOpen.UI.GetUI()\ntheUfSession = NXOpen.UF.UFSession.GetUFSession()\n\ndef main(*args): \n\n    workPart = theSession.Parts.BaseWork\n\n    bodies = workPart.Bodies\n\n    for body in bodies:\n\n        (min_corner, directions, distances) = theUfSession.ModlGeneral.AskBoundingBoxExact(body.Tag, 0)\n\n        theLw.Open()\n        theLw.WriteLine("Bounding box for " + body.JournalIdentifier)\n\n        theLw.WriteLine("  Min Corner: ")\n        theLw.WriteLine("    X: " + str(min_corner[0]))\n        theLw.WriteLine("    Y: " + str(min_corner[1]))\n        theLw.WriteLine("    Z: " + str(min_corner[2]))\n\n        theLw.WriteLine("  Direction Vectors: ")\n        theLw.WriteLine("    X: (" + str(directions[0][0]) + ", " + str(directions[0][1]) + ", " + str(directions[0][2]) + ")")\n        theLw.WriteLine("    Y: (" + str(directions[1][0]) + ", " + str(directions[1][1]) + ", " + str(directions[1][2]) + ")")\n        theLw.WriteLine("    Z: (" + str(directions[2][0]) + ", " + str(directions[2][1]) + ", " + str(directions[2][2]) + ")")\n\n        theLw.WriteLine("  Distances: ")\n        theLw.WriteLine("    X: " + str(distances[0]))\n        theLw.WriteLine("    Y: " + str(distances[1]))\n        theLw.WriteLine("    Z: " + str(distances[2]))\n\n        theLw.WriteLine("")\n\n# Main program.\n\nif __name__ == "__main__":\n    main()\n \n 上述 NXOpen Python Journal 程式必須在 NX12 GUI 模式下執行, 若需要直接透過 Non-GUI 的模式執行 NXOpen Python Journal 程式, 則必須提供程式執行對應檔案, 並在執行完成後將結果存檔. \n 下列程式, 可以在隨身 NX12 程式可執行的環境中, 提供空白的 newPart.prt 檔案, 然後在命令列透過 run_journal create_cube.py, 建立所需的 cube.prt 立方體檔案. \n # NX 12.0.2.9\n# 提供空檔案 newPart.prt\n# 利用 run_journal journal_newpart.py 以 Non-GUI 的模式執行 NX12, 將可直接建立 cube.prt\n\n#\nimport math\nimport NXOpen\nimport NXOpen.Annotations\nimport NXOpen.Features\nimport NXOpen.GeometricUtilities\nimport NXOpen.Preferences\nimport NXOpen.UF\n\ndef main() : \n    \n    theUI = NXOpen.UI.GetUI()\n    theMsgBox = theUI.NXMessageBox\n    theMsgBox.Show("簡要說明", NXOpen.NXMessageBox.DialogType.Information,"以下流程將建立一個簡單的長方體")\n    \n    theSession  = NXOpen.Session.GetSession()#try to open new part file to edit (different than assemblyFile)\n    NXFile = \'C:/python_journal/newPart.prt\'\n    #use class method to open new session/workPart\n    basepart1, partLoadStatus1 = theSession.Parts.OpenBaseDisplay(NXFile)\n    partLoadStatus1.Dispose()\n    workPart    = theSession.Parts.Work\n    displayPart = theSession.Parts.Display\n\n    # 以下利用 ListingWindow 列出相關資訊, 可用於程式除錯\n    theLw = theSession.ListingWindow\n    # 開啟 console 將資料印出\n    theLw.Open()\n    theLw.WriteLine("theSession 變數目前為: "+str(theSession))\n    \n    # 若直接在 NX12 中執行\n    #workPart = theSession.Parts.Work\n    # ----------------------------------------------\n    #   Menu: Insert->Sketch...\n    # ----------------------------------------------\n    markId1 = theSession.SetUndoMark(NXOpen.Session.MarkVisibility.Visible, "Start")\n    \n    sketchInPlaceBuilder1 = workPart.Sketches.CreateSketchInPlaceBuilder2(NXOpen.Sketch.Null)\n    \n    origin1 = NXOpen.Point3d(0.0, 0.0, 0.0)\n    normal1 = NXOpen.Vector3d(0.0, 0.0, 1.0)\n    plane1 = workPart.Planes.CreatePlane(origin1, normal1, NXOpen.SmartObject.UpdateOption.WithinModeling)\n    \n    sketchInPlaceBuilder1.PlaneReference = plane1\n    \n    unit1 = workPart.UnitCollection.FindObject("MilliMeter")\n    \n    sketchAlongPathBuilder1 = workPart.Sketches.CreateSketchAlongPathBuilder(NXOpen.Sketch.Null)\n\n    datumAxis1 = workPart.Datums.FindObject("DATUM_CSYS(0) X axis")\n    direction1 = workPart.Directions.CreateDirection(datumAxis1, NXOpen.Sense.Forward, NXOpen.SmartObject.UpdateOption.WithinModeling)\n    \n    datumPlane1 = workPart.Datums.FindObject("DATUM_CSYS(0) XY plane")\n    datumCsys1 = workPart.Features.FindObject("DATUM_CSYS(0)")\n    point1 = datumCsys1.FindObject("POINT 1")\n    xform1 = workPart.Xforms.CreateXformByPlaneXDirPoint(datumPlane1, direction1, point1, NXOpen.SmartObject.UpdateOption.WithinModeling, 0.625, False, False)\n    \n    cartesianCoordinateSystem1 = workPart.CoordinateSystems.CreateCoordinateSystem(xform1, NXOpen.SmartObject.UpdateOption.WithinModeling)\n    \n    sketchInPlaceBuilder1.Csystem = cartesianCoordinateSystem1\n\n    origin3 = NXOpen.Point3d(0.0, 0.0, 0.0)\n    normal3 = NXOpen.Vector3d(0.0, 0.0, 1.0)\n    plane3 = workPart.Planes.CreatePlane(origin3, normal3, NXOpen.SmartObject.UpdateOption.WithinModeling)\n    \n    plane3.SetMethod(NXOpen.PlaneTypes.MethodType.Coincident)\n    \n    geom2 = [NXOpen.NXObject.Null] * 1 \n    geom2[0] = datumPlane1\n    plane3.SetGeometry(geom2)\n    \n    plane3.SetAlternate(NXOpen.PlaneTypes.AlternateType.One)\n    \n    plane3.Evaluate()\n\n    # ----------------------------------------------\n    #   Menu: Insert->Sketch Curve->Rectangle...\n    # ----------------------------------------------\n\n    markId3 = theSession.SetUndoMark(NXOpen.Session.MarkVisibility.Invisible, "Create Sketch")\n\n    nXObject1 = sketchInPlaceBuilder1.Commit()\n    \n    sketch1 = nXObject1\n    feature1 = sketch1.Feature\n    \n    sketch1.Activate(NXOpen.Sketch.ViewReorient.TrueValue)\n    \n    theSession.DeleteUndoMark(markId3, None)\n    \n    theSession.SetUndoMarkName(markId1, "Create Sketch")\n    \n    sketchInPlaceBuilder1.Destroy()\n    \n    sketchAlongPathBuilder1.Destroy()\n        \n    plane3.DestroyPlane()\n    \n    markId5 = theSession.SetUndoMark(NXOpen.Session.MarkVisibility.Invisible, "Profile short list")\n    \n    markId6 = theSession.SetUndoMark(NXOpen.Session.MarkVisibility.Invisible, "Create Rectangle")\n    \n    theSession.SetUndoMarkVisibility(markId6, "Create Rectangle", NXOpen.Session.MarkVisibility.Visible)\n    \n    # ----------------------------------------------\n    # Creating rectangle using By 2 Points method \n    # ----------------------------------------------\n    startPoint1 = NXOpen.Point3d(-52.0, 42.0, 0.0)\n    endPoint1 = NXOpen.Point3d(44.0, 42.0, 0.0)\n    line1 = workPart.Curves.CreateLine(startPoint1, endPoint1)\n    \n    startPoint2 = NXOpen.Point3d(44.0, 42.0, 0.0)\n    endPoint2 = NXOpen.Point3d(44.0, -42.0, 0.0)\n    line2 = workPart.Curves.CreateLine(startPoint2, endPoint2)\n    \n    startPoint3 = NXOpen.Point3d(44.0, -42.0, 0.0)\n    endPoint3 = NXOpen.Point3d(-52.0, -42.0, 0.0)\n    line3 = workPart.Curves.CreateLine(startPoint3, endPoint3)\n    \n    startPoint4 = NXOpen.Point3d(-52.0, -42.0, 0.0)\n    endPoint4 = NXOpen.Point3d(-52.0, 42.0, 0.0)\n    line4 = workPart.Curves.CreateLine(startPoint4, endPoint4)\n    \n    theSession.ActiveSketch.AddGeometry(line1, NXOpen.Sketch.InferConstraintsOption.InferNoConstraints)\n    \n    theSession.ActiveSketch.AddGeometry(line2, NXOpen.Sketch.InferConstraintsOption.InferNoConstraints)\n    \n    theSession.ActiveSketch.AddGeometry(line3, NXOpen.Sketch.InferConstraintsOption.InferNoConstraints)\n    \n    theSession.ActiveSketch.AddGeometry(line4, NXOpen.Sketch.InferConstraintsOption.InferNoConstraints)\n\n    theSession.ActiveSketch.Update()\n    \n    theSession.Preferences.Sketch.AutoDimensionsToArcCenter = True\n    \n    geoms1 = [NXOpen.SmartObject.Null] * 4 \n    geoms1[0] = line1\n    geoms1[1] = line2\n    geoms1[2] = line3\n    geoms1[3] = line4\n    theSession.ActiveSketch.UpdateConstraintDisplay(geoms1)\n    # ----------------------------------------------\n    #   Menu: File->Finish Sketch\n    # ----------------------------------------------\n    sketch2 = theSession.ActiveSketch\n    # ----------------------------------------------\n    #   Menu: Insert->Design Feature->Extrude...\n    # ----------------------------------------------\n    markId8 = theSession.SetUndoMark(NXOpen.Session.MarkVisibility.Visible, "Start")\n    \n    extrudeBuilder1 = workPart.Features.CreateExtrudeBuilder(NXOpen.Features.Feature.Null)\n    \n    section1 = workPart.Sections.CreateSection(0.0094999999999999998, 0.01, 0.5)\n    \n    extrudeBuilder1.Section = section1\n    \n    extrudeBuilder1.AllowSelfIntersectingSection(True)\n    \n    unit2 = extrudeBuilder1.Draft.FrontDraftAngle.Units\n  \n    features1 = [NXOpen.Features.Feature.Null] * 1 \n    sketchFeature1 = feature1\n    features1[0] = sketchFeature1\n    curveFeatureRule1 = workPart.ScRuleFactory.CreateRuleCurveFeature(features1)\n    \n    section1.AllowSelfIntersection(True)\n    \n    rules1 = [None] * 1 \n    rules1[0] = curveFeatureRule1\n    helpPoint1 = NXOpen.Point3d(-52.0, 18.603986789941445, 3.5527136788005009e-15)\n    section1.AddToSection(rules1, line4, NXOpen.NXObject.Null, NXOpen.NXObject.Null, helpPoint1, NXOpen.Section.Mode.Create, False)\n\n    direction2 = workPart.Directions.CreateDirection(sketch2, NXOpen.Sense.Forward, NXOpen.SmartObject.UpdateOption.WithinModeling)\n    \n    extrudeBuilder1.Direction = direction2\n    \n    extrudeBuilder1.Limits.EndExtend.Value.RightHandSide = "50"\n\n    extrudeBuilder1.ParentFeatureInternal = False\n    \n    feature2 = extrudeBuilder1.CommitFeature()\n    # 將 basepart1 存檔\n    newNXFile = \'C:/python_journal/cube.prt\'\n    basepart1.SaveAs(newNXFile)\n\n    # ----------------------------------------------\n    #   Menu: Tools->Journal->Stop Recording\n    # ----------------------------------------------\n    \nif __name__ == \'__main__\':\n    main()\n \n 參考資料 \n NXOpen VB 轉為 Python: \n https://community.sw.siemens.com/s/question/0D54O000061xRnYSAU/convert-vb-to-python', 'tags': '', 'url': 'NX12 程式.html'}, {'title': 'TeX', 'text': 'http://texdoc.net/texmf-dist/doc/plain/gentle/gentle.pdf \n https://bitbucket.org/VictorEijkhout/tex-by-topic/src/default/ \n http://makingtexwork.sourceforge.net/mtw/ \n ftp://tug.org/tex/impatient/book.pdf \xa0 \n https://yihui.name/tinytex/', 'tags': '', 'url': 'TeX.html'}, {'title': 'Open CAX', 'text': 'Code-aster Windows \n https://code-aster-windows.com/ \n PyCAM \n https://github.com/SebKuzminsky/pycam', 'tags': '', 'url': 'Open CAX.html'}, {'title': 'Bond Graphs', 'text': 'https://github.com/mdecourse/BondGraphTools \n', 'tags': '', 'url': 'Bond Graphs.html'}, {'title': 'Tasks', 'text': 'Task1 \n 參數式繪圖軟體 Solvespace 編譯、零組件繪圖與應用. \n Task2 \n MCAD 套件安裝與設定, 零組件繪圖、轉檔與 CAE 工程分析. \n Task3 \n Rover 零組件轉入 \xa0 V-rep \xa0 與 \xa0 Webots \xa0 執行機電控制系統設計. \n Project \n 機電資整合分組專案執行. \n \n', 'tags': '', 'url': 'Tasks.html'}, {'title': '分組名單', 'text': 'cad 2a 分組結果 \n ==================== \n ag1 分組倉儲與網站: \n https://github.com/s40723148/cad2019ag1 \n https://s40723148.github.io/cad2019ag1/ \n  第 1 組成員:   40523120 倉儲  |  40523120 網站   40723102 倉儲  |  40723102 網站   40723110 倉儲  |  40723110 網站   40723112 倉儲  |  40723112 網站   40723115 倉儲  |  40723115 網站   40723120 倉儲  |  40723120 網站   40723127 倉儲  |  40723127 網站   40723136 倉儲  |  40723136 網站   40723140 倉儲  |  40723140 網站   40723143 倉儲  |  40723143 網站   40723146 倉儲  |  40723146 網站   40723148 倉儲  |  40723148 網站  ==================== \n ag2 分組倉儲與網站: \n https://github.com/s40723145/cad2019ag2 \n https://s40723145.github.io/cad2019ag2/ \n  第 2 組成員:   40523148 倉儲  |  40523148 網站   40523241 倉儲  |  40523241 網站   40723118 倉儲  |  40723118 網站   40723129 倉儲  |  40723129 網站   40723132 倉儲  |  40723132 網站   40723135 倉儲  |  40723135 網站   40723138 倉儲  |  40723138 網站   40723139 倉儲  |  40723139 網站   40723141 倉儲  |  40723141 網站   40723144 倉儲  |  40723144 網站   40723145 倉儲  |  40723145 網站   40723153 倉儲  |  40723153 網站  ==================== \n ag3 分組倉儲與網站: \n https://github.com/s40723104/cad2019ag3 \n https://s40723104.github.io/cad2019ag3/ \n  第 3 組成員: 40423208 倉儲  |  40423208 網站 40523142 倉儲  |  40523142 網站   40723104 倉儲  |  40723104 網站   40723106 倉儲  |  40723106 網站   40723108 倉儲  |  40723108 網站   40723111 倉儲  |  40723111 網站   40723121 倉儲  |  40723121 網站   40723123 倉儲  |  40723123 網站   40723126 倉儲  |  40723126 網站   40723128 倉儲  |  40723128 網站   40723130 倉儲  |  40723130 網站   40723133 倉儲  |  40723133 網站  ==================== \n ag4 分組倉儲與網站: \n https://github.com/s40723147/cad2019ag4 \n https://s40723147.github.io/cad2019ag4/ \n  第 4 組成員:   40423218 倉儲  |  40423218 網站   40623123 倉儲  |  40623123 網站   40623143 倉儲  |  40623143 網站   40723134 倉儲  |  40723134 網站   40723137 倉儲  |  40723137 網站   40723142 倉儲  |  40723142 網站   40723147 倉儲  |  40723147 網站   40723149 倉儲  |  40723149 網站   40723150 倉儲  |  40723150 網站   40723151 倉儲  |  40723151 網站   40723154 倉儲  |  40723154 網站  ==================== \n ag5 分組倉儲與網站: \n https://github.com/s40723125/cad2019ag5 \n https://s40723125.github.io/cad2019ag5/ \n  第 5 組成員:   40523113 倉儲  |  40523113 網站   40623252 倉儲  |  40623252 網站   40723101 倉儲  |  40723101 網站   40723103 倉儲  |  40723103 網站   40723107 倉儲  |  40723107 網站   40723114 倉儲  |  40723114 網站   40723119 倉儲  |  40723119 網站   40723122 倉儲  |  40723122 網站   40723124 倉儲  |  40723124 網站   40723125 倉儲  |  40723125 網站   40723152 倉儲  |  40723152 網站   40723155 倉儲  |  40723155 網站 \n [[40523120, 40723102, 40723110,\xa040723112, 40723115, 40723120, 40723127, 40723136, 40723140, 40723143, 40723146, 40723148], [40523148, 40523241, 40723118, 40723129, 40723132, 40723135,\xa040723138, 40723139, 40723141, 40723144, 40723145, 40723153], [40423208, 40523142, 40723104, 40723106, 40723108, 40723111, 40723121, 40723123, 40723126, 40723128, 40723130, 40723133], [40423218, 40623123, 40623143, 40723134, 40723137, 40723142, 40723147, 40723149, 40723150, 40723151, 40723154], [40523113,  40623252,\xa0 40723101, 40723103, 40723107, 40723114, 40723119, 40723122, 40723124, 40723125, 40723152, 40723155]] \n 排序程式 \n cad 2b 分組結果 \n ==================== \n bg1 分組倉儲與網站: \n https://github.com/s40723212/cad2019bg1 \n https://s40723212.github.io/cad2019bg1/ \n  第 1 組成員:   40723212 倉儲  |  40723212 網站   40723222 倉儲  |  40723222 網站   40723223 倉儲  |  40723223 網站   40723225 倉儲  |  40723225 網站   40723227 倉儲  |  40723227 網站   40723230 倉儲  |  40723230 網站   40723234 倉儲  |  40723234 網站   40723244 倉儲  |  40723244 網站   40723249 倉儲  |  40723249 網站   40732331 倉儲  |  40732331 網站  ==================== \n bg2 分組倉儲與網站: \n https://github.com/s40723221/cad2019bg2 \xa0 \n https://s40723221.github.io/cad2019bg2/ \n  第 2 組成員:   40723205 倉儲  |  40723205 網站   40723221 倉儲  |  40723221 網站   40723224 倉儲  |  40723224 網站   40723228 倉儲  |  40723228 網站   40723229 倉儲  |  40723229 網站   40723235 倉儲  |  40723235 網站   40723240 倉儲  |  40723240 網站   40723246 倉儲  |  40723246 網站   40723247 倉儲  |  40723247 網站   40723250 倉儲  |  40723250 網站  ==================== \n bg3 分組倉儲與網站: \n https://github.com/s40723206/cad2019bg3 \n https://s40723206.github.io/cad2019bg3/ \xa0\xa0 \n  第 3 組成員:   40723203 倉儲  |  40723203 網站   40723206 倉儲  |  40723206 網站   40723208 倉儲  |  40723208 網站   40723209 倉儲  |  40723209 網站   40723214 倉儲  |  40723214 網站   40723233 倉儲  |  40723233 網站   40723238 倉儲  |  40723238 網站   40723239 倉儲  |  40723239 網站   40723241 倉儲  |  40723241 網站   40739214 倉儲  |  40739214 網站  ==================== \n bg4 分組倉儲與網站: \n https://github.com/s40723204/cad2019bg4 \n https://s40723204.github.io/cad2019bg4 \xa0 \n  第 4 組成員:   40723201 倉儲  |  40723201 網站   40723204 倉儲  |  40723204 網站   40723213 倉儲  |  40723213 網站   40723215 倉儲  |  40723215 網站   40723218 倉儲  |  40723218 網站   40723219 倉儲  |  40723219 網站   40723237 倉儲  |  40723237 網站   40723242 倉儲  |  40723242 網站   40723243 倉儲  |  40723243 網站   40723245 倉儲  |  40723245 網站  ==================== \n bg5 分組倉儲與網站: \n https://github.com/s40723210/cad2019bg5 \n https://s40723210.github.io/cad2019bg5/ \n  第 5 組成員:   40523252 倉儲  |  40523252 網站   40723207 倉儲  |  40723207 網站   40723210 倉儲  |  40723210 網站   40723216 倉儲  |  40723216 網站   40723226 倉儲  |  40723226 網站   40723232 倉儲  |  40723232 網站   40723236 倉儲  |  40723236 網站   40732319 倉儲  |  40732319 網站 \n  [[40723212, 40723222, 40723223, 40723225, 40723227, 40723230, 40723234, 40723244, 40723249, 40732331], [40723205, 40723221, 40723224, 40723228, 40723229, 40723235, 40723240, 40723246, 40723247, 40723250], [40723203, 40723206, 40723208, 40723209, 40723214, 40723233, 40723238, 40723239, 40723241, 40739214], [40723201, 40723204, 40723213, 40723215, 40723218, 40723219, 40723237, 40723242, 40723243, 40723245], [40523252, 40723207, 40723210, 40723216, 40723226, 40723232, 40723236, 40732319]]', 'tags': '', 'url': '分組名單.html'}, {'title': 'Task1', 'text': '參考資料 \n V-REP Lecture.pdf \n 感知與作動智能機器人 ( Sensorimotor  Intelligence Robot) \n the-playful-machine.pdf \xa0( http://robot.informatik.uni-leipzig.de/software/ ,\xa0 https://github.com/georgmartius/lpzrobots \xa0and  https://github.com/Larsg7/lpzrobots-install-script ) \n Sensorimotor Contingencies in Artificial Intelligence and Robotics.pdf \n PyRep - Bringing V-REP to deep robot learning.pdf \n https://github.com/clamesc/Training-Neural-Networks-for-Event-Based-End-to-End-Robot-Control \n https://github.com/Troxid/vrep-api-python \n https://ctmakro.github.io/site/on_learning/rl/vrep.html \n 3D Simulated Robot Manipulation Using Deep Reinforcement Learning.pdf \n \n 參數式繪圖軟體 Solvespace 編譯、零組件繪圖與應用. \n \n \n 利用\xa0 2019Fall可攜套件.7z \xa0學習如何完成\xa0 https://github.com/solvespace/solvespace \xa0原始碼的編譯, 並透過\xa0 http://solvespace.com \xa0學習如何建立  web_rep2.zip \xa0中所需的行走車. \n 其中必須將所建立的零組件轉入\xa0 V-rep 3.6.1 rev 4.7z \xa0進行運動組立後, 以 Lua 或 Python 進行控制. \n 網際 V-rep 模型控制:  web_vrep2.zip \xa0( local ) \n \n app.py \n from flask import Flask, render_template, redirect\nfrom vrep_linefollower import VrepLineFollower\n\nline_follower = VrepLineFollower()\n\napp = Flask(__name__)\n\n@app.route("/")\ndef index():\n  return render_template(\'controls.html\')\n\n@app.route(\'/do/<direction>\')\ndef do(direction):\n  global line_follower\n  line_follower.to_direction(direction)\n  return redirect(\'/\')\n\n\nif __name__ == \'__main__\':\n  app.run(host=\'127.0.0.1\')\n \n vrep_linefollower.py \n import vrep\n\nclass VrepLineFollower:\n  def __init__(self):\n    vrep.simxFinish(-1) # just in case, close all opened connections\n    self.clientID = vrep.simxStart(\'127.0.0.1\', 19997, True, True, 5000, 5)\n\n    self.wheelRadius = 0.027\n    self.linearVelocityLeft  = 0.1\n    self.linearVelocityRight = 0.1\n\n    # vectors [left, right]\n    self.direction_v = {\n     \'up\':    [ 0.01,  0.01],\n     \'down\':  [-0.01, -0.01],\n     \'left\':  [-0.01,  0.01],\n     \'right\': [ 0.01, -0.01]\n    }\n\n    res, self.leftJointDynamic  = vrep.simxGetObjectHandle(self.clientID, "DynamicLeftJoint",  vrep.simx_opmode_oneshot_wait)\n    res, self.rightJointDynamic = vrep.simxGetObjectHandle(self.clientID, "DynamicRightJoint", vrep.simx_opmode_oneshot_wait)\n\n  # direction = \'up\' | \'down\' | \'left\' | \'right\'\n  def to_direction(self, direction):\n    direction_vector = self.direction_v[direction]\n    self.linearVelocityLeft  += direction_vector[0]\n    self.linearVelocityRight += direction_vector[1]\n    self.set_motors()\n\n  # private\n  def set_motors(self):\n    t_left  = self.linearVelocityLeft  / self.wheelRadius\n    t_right = self.linearVelocityRight / self.wheelRadius\n    vrep.simxSetJointTargetVelocity(self.clientID, self.leftJointDynamic,  t_left,  vrep.simx_opmode_oneshot_wait)\n    vrep.simxSetJointTargetVelocity(self.clientID, self.rightJointDynamic, t_right, vrep.simx_opmode_oneshot_wait)\n\n \n', 'tags': '', 'url': 'Task1.html'}, {'title': 'Solvespace 編譯', 'text': '分組作業: \n 請各組組員分別完成 Solvespace 編譯流程後, 建立一個帶有字幕說明的導引影片, 上傳至 Youtube 並內嵌至各分組網站中. \n 下載可攜程式系統: \n 2019Fall可攜套件.7z \n 參考資料: \n https://2019wcm.blogspot.com/2019/03/msys2-solvespace.html \n https://github.com/solvespace/solvespace \n 編譯步驟: \n 先將 Y:\\portablegit\\bin\\sh.exe 改名為 sh_rename_for_solvespace.exe (透過 MSYS2 執行 shell 指令, 而非 portablegit 中的 sh.exe) \n git version 查驗 git 版本 \n git 2.13 版本以上, 可以使用下列 git clone  --recurse-submodules 取得所有子模組資料 \n git clone --recurse-submodules https://github.com/solvespace/solvespace.git solvespace \n 上述指令同: \n git clone\xa0 https://github.com/solvespace/solvespace.git \xa0 \n cd solvespace \n git submodule init \n git submodule update \n edit Y:\\tmp\\solvespace\\extlib\\angle\\CMakeLists.txt comment out line 713 and 714 \n #list(APPEND ANGLE_DEFINITIONS #"-DANGLE_PRELOADED_D3DCOMPILER_MODULE_NAMES={ \\"d3dcompiler_47.dll\\", \\"d3dcompiler_46.dll\\", \\"d3dcompiler_43.dll\\" }") endif() \n 接著需要手動進行 libpng.dll.a 的編譯, 並改名為 libpng_static.a, 並放到編譯系統的 lib 目錄中 (即隨身系統的 msys64\\mingw64\\lib 目錄): \n cd solvespace \n cd extlib \n cd libpng \n mkdir build \n cd build \n cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release mingw32-make \n (mingw32-make -Wl,-static) \n rename libpng.dll.a to libpng_static.a and copy to Y:\\msys64\\mingw64\\lib \n 接著回到 solvespace 原始碼目錄, 建立 build 目錄後進入 build 目錄, 執行: \n cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release mingw32-make \n 編譯完成後, 可以在 build\\bin 目錄中建立 solvespace.exe, 配合相關 dll 檔案後, 即可執行. \n 下載 Solvesapce.exe 所需的 dlls  (登入 @gm 後下載) \n 下載官方使用 Visual Studio 編譯的 Solvespace.exe  (登入 @gm 後下載) \n 下載 Solvespace  986da7d 版本 \n 下載 Solvespace 22e4011 版本 \n 利用  WebAssembly  製作的 瀏覽器上的 Solvespace \n Solvespace C++ 程式延伸 \n 位於 exposed 目錄中有一個範例 CDemo.c \n /*-----------------------------------------------------------------------------\n * Some sample code for slvs.dll. We draw some geometric entities, provide\n * initial guesses for their positions, and then constrain them. The solver\n * calculates their new positions, in order to satisfy the constraints.\n *\n * Copyright 2008-2013 Jonathan Westhues.\n *---------------------------------------------------------------------------*/\n#ifdef WIN32\n#   include <windows.h>\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\n#include <slvs.h>\n\nstatic Slvs_System sys;\n\nstatic void *CheckMalloc(size_t n)\n{\n    void *r = malloc(n);\n    if(!r) {\n        printf("out of memory!\\n");\n        exit(-1);\n    }\n    return r;\n}\n\n/*-----------------------------------------------------------------------------\n * An example of a constraint in 3d. We create a single group, with some\n * entities and constraints.\n *---------------------------------------------------------------------------*/\nvoid Example3d()\n{\n    /* This will contain a single group, which will arbitrarily number 1. */\n    Slvs_hGroup g = 1;\n\n    /* A point, initially at (x y z) = (10 10 10) */\n    sys.param[sys.params++] = Slvs_MakeParam(1, g, 10.0);\n    sys.param[sys.params++] = Slvs_MakeParam(2, g, 10.0);\n    sys.param[sys.params++] = Slvs_MakeParam(3, g, 10.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint3d(101, g, 1, 2, 3);\n    /* and a second point at (20 20 20) */\n    sys.param[sys.params++] = Slvs_MakeParam(4, g, 20.0);\n    sys.param[sys.params++] = Slvs_MakeParam(5, g, 20.0);\n    sys.param[sys.params++] = Slvs_MakeParam(6, g, 20.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint3d(102, g, 4, 5, 6);\n    /* and a line segment connecting them. */\n    sys.entity[sys.entities++] = Slvs_MakeLineSegment(200, g,\n                                        SLVS_FREE_IN_3D, 101, 102);\n\n    /* The distance between the points should be 30.0 units. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            1, g,\n                                            SLVS_C_PT_PT_DISTANCE,\n                                            SLVS_FREE_IN_3D,\n                                            30.0,\n                                            101, 102, 0, 0);\n\n    /* Let\'s tell the solver to keep the second point as close to constant\n     * as possible, instead moving the first point. */\n    sys.dragged[0] = 4;\n    sys.dragged[1] = 5;\n    sys.dragged[2] = 6;\n\n    /* Now that we have written our system, we solve. */\n    Slvs_Solve(&sys, g);\n\n    if(sys.result == SLVS_RESULT_OKAY) {\n        printf("okay; now at (%.3f %.3f %.3f)\\n"\n               "             (%.3f %.3f %.3f)\\n",\n                sys.param[0].val, sys.param[1].val, sys.param[2].val,\n                sys.param[3].val, sys.param[4].val, sys.param[5].val);\n        printf("%d DOF\\n", sys.dof);\n    } else {\n        printf("solve failed");\n    }\n}\n\n/*-----------------------------------------------------------------------------\n * An example of a constraint in 2d. In our first group, we create a workplane\n * along the reference frame\'s xy plane. In a second group, we create some\n * entities in that group and dimension them.\n *---------------------------------------------------------------------------*/\nvoid Example2d()\n{\n    Slvs_hGroup g;\n    double qw, qx, qy, qz;\n\n    g = 1;\n    /* First, we create our workplane. Its origin corresponds to the origin\n     * of our base frame (x y z) = (0 0 0) */\n    sys.param[sys.params++] = Slvs_MakeParam(1, g, 0.0);\n    sys.param[sys.params++] = Slvs_MakeParam(2, g, 0.0);\n    sys.param[sys.params++] = Slvs_MakeParam(3, g, 0.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint3d(101, g, 1, 2, 3);\n    /* and it is parallel to the xy plane, so it has basis vectors (1 0 0)\n     * and (0 1 0). */\n    Slvs_MakeQuaternion(1, 0, 0,\n                        0, 1, 0, &qw, &qx, &qy, &qz);\n    sys.param[sys.params++] = Slvs_MakeParam(4, g, qw);\n    sys.param[sys.params++] = Slvs_MakeParam(5, g, qx);\n    sys.param[sys.params++] = Slvs_MakeParam(6, g, qy);\n    sys.param[sys.params++] = Slvs_MakeParam(7, g, qz);\n    sys.entity[sys.entities++] = Slvs_MakeNormal3d(102, g, 4, 5, 6, 7);\n\n    sys.entity[sys.entities++] = Slvs_MakeWorkplane(200, g, 101, 102);\n\n    /* Now create a second group. We\'ll solve group 2, while leaving group 1\n     * constant; so the workplane that we\'ve created will be locked down,\n     * and the solver can\'t move it. */\n    g = 2;\n    /* These points are represented by their coordinates (u v) within the\n     * workplane, so they need only two parameters each. */\n    sys.param[sys.params++] = Slvs_MakeParam(11, g, 10.0);\n    sys.param[sys.params++] = Slvs_MakeParam(12, g, 20.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint2d(301, g, 200, 11, 12);\n\n    sys.param[sys.params++] = Slvs_MakeParam(13, g, 20.0);\n    sys.param[sys.params++] = Slvs_MakeParam(14, g, 10.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint2d(302, g, 200, 13, 14);\n\n    /* And we create a line segment with those endpoints. */\n    sys.entity[sys.entities++] = Slvs_MakeLineSegment(400, g,\n                                        200, 301, 302);\n\n    /* Now three more points. */\n    sys.param[sys.params++] = Slvs_MakeParam(15, g, 100.0);\n    sys.param[sys.params++] = Slvs_MakeParam(16, g, 120.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint2d(303, g, 200, 15, 16);\n\n    sys.param[sys.params++] = Slvs_MakeParam(17, g, 120.0);\n    sys.param[sys.params++] = Slvs_MakeParam(18, g, 110.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint2d(304, g, 200, 17, 18);\n\n    sys.param[sys.params++] = Slvs_MakeParam(19, g, 115.0);\n    sys.param[sys.params++] = Slvs_MakeParam(20, g, 115.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint2d(305, g, 200, 19, 20);\n\n    /* And arc, centered at point 303, starting at point 304, ending at\n     * point 305. */\n    sys.entity[sys.entities++] = Slvs_MakeArcOfCircle(401, g, 200, 102,\n                                    303, 304, 305);\n\n    /* Now one more point, and a distance */\n    sys.param[sys.params++] = Slvs_MakeParam(21, g, 200.0);\n    sys.param[sys.params++] = Slvs_MakeParam(22, g, 200.0);\n    sys.entity[sys.entities++] = Slvs_MakePoint2d(306, g, 200, 21, 22);\n\n    sys.param[sys.params++] = Slvs_MakeParam(23, g, 30.0);\n    sys.entity[sys.entities++] = Slvs_MakeDistance(307, g, 200, 23);\n\n    /* And a complete circle, centered at point 306 with radius equal to\n     * distance 307. The normal is 102, the same as our workplane. */\n    sys.entity[sys.entities++] = Slvs_MakeCircle(402, g, 200,\n                                    306, 102, 307);\n\n\n    /* The length of our line segment is 30.0 units. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            1, g,\n                                            SLVS_C_PT_PT_DISTANCE,\n                                            200,\n                                            30.0,\n                                            301, 302, 0, 0);\n\n    /* And the distance from our line segment to the origin is 10.0 units. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            2, g,\n                                            SLVS_C_PT_LINE_DISTANCE,\n                                            200,\n                                            10.0,\n                                            101, 0, 400, 0);\n    /* And the line segment is vertical. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            3, g,\n                                            SLVS_C_VERTICAL,\n                                            200,\n                                            0.0,\n                                            0, 0, 400, 0);\n    /* And the distance from one endpoint to the origin is 15.0 units. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            4, g,\n                                            SLVS_C_PT_PT_DISTANCE,\n                                            200,\n                                            15.0,\n                                            301, 101, 0, 0);\n#if 0\n    /* And same for the other endpoint; so if you add this constraint then\n     * the sketch is overconstrained and will signal an error. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            5, g,\n                                            SLVS_C_PT_PT_DISTANCE,\n                                            200,\n                                            18.0,\n                                            302, 101, 0, 0);\n#endif /* 0 */\n\n    /* The arc and the circle have equal radius. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            6, g,\n                                            SLVS_C_EQUAL_RADIUS,\n                                            200,\n                                            0.0,\n                                            0, 0, 401, 402);\n    /* The arc has radius 17.0 units. */\n    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(\n                                            7, g,\n                                            SLVS_C_DIAMETER,\n                                            200,\n                                            17.0*2,\n                                            0, 0, 401, 0);\n\n    /* If the solver fails, then ask it to report which constraints caused\n     * the problem. */\n    sys.calculateFaileds = 1;\n\n    /* And solve. */\n    Slvs_Solve(&sys, g);\n\n    if(sys.result == SLVS_RESULT_OKAY) {\n        printf("solved okay\\n");\n        printf("line from (%.3f %.3f) to (%.3f %.3f)\\n",\n                sys.param[7].val, sys.param[8].val,\n                sys.param[9].val, sys.param[10].val);\n\n        printf("arc center (%.3f %.3f) start (%.3f %.3f) finish (%.3f %.3f)\\n",\n                sys.param[11].val, sys.param[12].val,\n                sys.param[13].val, sys.param[14].val,\n                sys.param[15].val, sys.param[16].val);\n\n        printf("circle center (%.3f %.3f) radius %.3f\\n",\n                sys.param[17].val, sys.param[18].val,\n                sys.param[19].val);\n        printf("%d DOF\\n", sys.dof);\n    } else {\n        int i;\n        printf("solve failed: problematic constraints are:");\n        for(i = 0; i < sys.faileds; i++) {\n            printf(" %d", sys.failed[i]);\n        }\n        printf("\\n");\n        if(sys.result == SLVS_RESULT_INCONSISTENT) {\n            printf("system inconsistent\\n");\n        } else {\n            printf("system nonconvergent\\n");\n        }\n    }\n}\n\nint main()\n{\n    sys.param      = CheckMalloc(50*sizeof(sys.param[0]));\n    sys.entity     = CheckMalloc(50*sizeof(sys.entity[0]));\n    sys.constraint = CheckMalloc(50*sizeof(sys.constraint[0]));\n\n    sys.failed  = CheckMalloc(50*sizeof(sys.failed[0]));\n    sys.faileds = 50;\n\n    /*Example3d();*/\n    for(;;) {\n        Example2d();\n        sys.params = sys.constraints = sys.entities = 0;\n        break;\n    }\n    return 0;\n}\n\n \n 編譯 CDemo.c 流程: \n 首先將 solvespace/include/slvs.h 複製到 Y:\\msys64\\mingw64\\include \n 接著將先前 build 目錄中的 libslvs.dll 複製到 Y:\\msys64\\mingw64\\lib \n 然後在 solvespace\\exposed\\ 目錄中建立 build 目錄, 然後以指令模式進入此一 build 目錄後, 執行: \n cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release mingw32-make \n 就可以完成 CDemo.exe 的編譯, 必須配合 libslvs.dll 與 libwinpthread-1.dll 執行. \n 設計原理: \n Solvespace 首次提交到 Github \n 來源 ,  Watertight Trimmed NURBS.pdf \n SolveSpace represents curves and surfaces in a form equivalent to NURBS, by their rational polynomial parametric equations. That can represent a lot of geometry exactly, but not everything (for example, not the general intersection curve of two cylinders). When no exact representation of that form exists, SolveSpace approximates. This is the same approach that commercial libraries (Parasolid, Solids++, etc.) take. \n There\'s just a lot of cases, and a lot of work to test that you\'ve covered them all. As far as I know, the highest-quality commercial libraries get their robustness mostly from exhaustive enumeration of special cases, or trying multiple differently-broken algorithms until something works, and less from anything that\'s mathematically interesting in isolation. \n A trimming curve is typically a degree-three NURBS curve defined in the parameter domain of a NURBS surface. The image of such a trimming curve on a bicubic patch (i.e., the curve on the bicubic patch in R3 that the trimming curve maps to) is degree ≤ 18 and algebraic genus zero. However, a generic intersection curve of two bicubic surfaces is degree 324 in R3 and algebraic genus 433. Hence, intersection curves can only be approximated by parametric trimming curves. \n', 'tags': '', 'url': 'Solvespace 編譯.html'}, {'title': 'Solvespace 操作', 'text': '分組作業: \n 請各組在了解如何利用 Solvespace 執行零組件繪圖後, 以協同模式製作一個帶有中文說明字幕的 Solvespace 零組件操作導引影片, 並上傳至 Youtube 且內嵌至各分組網站. \n Solvespace Learning Guide.pdf \n https://www.youtube.com/watch?v=1Em_XESnqUM&list=PLEvJVXu3VfGMSOdpA0jrGRzoM7NlNOl5s \n \n \n                      ', 'tags': '', 'url': 'Solvespace 操作.html'}, {'title': '機構設計與模擬', 'text': '分組任務, 請利用  Solvespace ,  V-rep  與  Pyslvs  等系統功能, 完成  Jansen 行走機構 的零組件繪製、組合、2D 模擬與3D 系統模擬 . \n \n 問題討論: \n 當多連桿行走機構的 設計目標變更 時, 能否透過程式方法,  快速 完成機電資系統的零組件以及系統模擬的 設計因應變更 ? \n 根據 網際 V-rep 模型控制:\xa0 web_vrep2.zip \xa0( local ) 任務的執行, 已知 V-rep 可以啟動多網路埠號接受遠端連線控制. 意即, 使用者可以透過 Remote API 的 Python 程式控制並監控遠端 V-rep 系統的模擬內容. \n 完成上述任務執行後, 是否能夠根據設計目標要求, 以參數式表單完成行走機構零件繪製與自動組立, 並據以修改動態模擬系統內容, 快速完成系統模擬與驗證? \n 問題: 能否 透過 V-rep 的 Python Remote API 流程 , 完成多連桿行走機構的 模型建立 ? 假如 Python 程式希望執行 Remote API 並未提供的系統功能, 可以如\xa0programming\\remoteApiBindings\\python\\python\\complexCommandTest.py 中的說明, 以間接的方式完成. (下載  vrep_python_remote_command_test_.7z \xa0範例) \n 參考資料: \n 2000 -\xa0 The A-Design Invention Machine.pdf \n 2001 -  OPTIMAL.SYNTHESIS.OF.PLANAR.FIVE-LINK.MECHANISMS.FOR.THE.PRODUCTION.OF.NONLINEAR.MECHANICAL.ADVANTAGE.pdf \n 2008 -  computer-aided.mechanism.design-now.and.the.future.pdf \n 2010 -  A graph grammar scheme for representing and evaluating planar mechanisms.pdf \n 2011 -\xa0 https://github.com/mdecourse/pmks_firefox \n 2011 -\xa0  Computer-Based_design_synthesis_research-_An_overview.pdf \n 2013 -  Development of educational software for beam loading analysis using pen-based user interfaces.pdf \n 2014 -  Automated design of planar mechanisms_2014.pdf \n 2015 -  Automated Synthesis of Planar Mechanisms with Revolute Prismatic and Pin-In-Slot Joints.pdf \n 2015 -  Automatic.Structural.Synthesis.of.Planar.Mechanisms.and.Its.Application.to.Creative.Design.pdf \n 2016 -  M.Sketch: Prototyping Tool for Linkage-Based Mechanism Design \n 2018 -  Creative.mechanism.design.of.magnetic.gears.integrated.with.continuously.variable.transmissions.pdf \n 2019 -  PMKS_plus.pdf \xa0( PMKS+ )', 'tags': '', 'url': '機構設計與模擬.html'}, {'title': 'GCS', 'text': "Solvespace 的 Geometric Constraint Solver 程式庫原始碼: \n constraint.cpp: \n Implementation of the Constraint menu, to create new constraints in the sketch. \n constrainteq.cpp \n Given a constraint, generate one or more equations in our symbolic algebra system to represent that constraint; also various geometric helper functions for that. \n entity.cpp \n The implementation of our entities in the symbolic algebra system, methods to return a symbolic representation of the entity (line by its endpoints, circle by center and radius, etc.). \n expr.cpp \n The symbolic algebra system used to write our constraint equations; routines to build expressions in software or from a user-provided string, and to compute the partial derivatives that we'll use when write our Jacobian matrix. \n lib.cpp \n A library wrapper around SolveSpace, to permit someone to use its constraint solver without coupling their program too much to SolveSpace's internals. \n system.cpp \n Once we've written our constraint equations in the symbolic algebra system, these routines linearize them, and solve by a modified Newton's method. This also contains the routines to detect non-convergence or inconsistency, and report diagnostics to the user. \n 透過\xa0 https://github.com/KmolYuan/Pyslvs-UI \xa0取得 GCS 動態程式庫: \n git clone\xa0 https://github.com/KmolYuan/Pyslvs-UI .git\xa0 \n cd Pyslvs-UI \n git submodule update --init --recursive \n mingw32-make build-kernel", 'tags': '', 'url': 'GCS.html'}, {'title': 'Task2', 'text': '分組作業: \n 請各組在實際安裝與操作 Inventor 2019、NX12、Solidworks 2017 Solidworks 2017 、Creo 6.0 與 Onshape 之後, 以協同模式製作一個帶有中文字幕的影片, 說明各套系統的安裝、認證設定與基本零組件繪圖功能後, 上傳至 Youtube 並內嵌至各分組網站中. \n NX12.0.2_release_notes.pdf \n NX12_Sketching.pdf \n NX 12_CAD_新功能介紹.pdf \n NX 12_CAM_新功能介紹.pdf \n NX 12 For Engineering Design.pdf \n nx_flomcad_flotherm_macro.pdf \n SIEMENS_PLM_SOFTWARE_polarion_today.pdf \n SIEMENS_AG_implementation_of_techpub_studio_at_siemens_pg.pdf \n SIEMENS_PLM_delving_into_electro_mechanical_integration_for_nx_users.pdf \n SIEMENS_PLM_mechatronics_concept_designer.pdf \n c01_NX_12.0_eval.pdf \n c15_NX_12.0_fdwd.pdf \n MCAD 套件安裝與設定, 零組件繪圖、轉檔與 CAE 工程分析. \n 請所有組員根據\xa0 https://2019wcm.blogspot.com/2019/07/autodesk-inventor-professional.html \xa0中的說明, 在個人的桌上型電腦或筆電上安裝 AutoDesk Inventor Professional 2019. 並將詳細安裝與設定過程加以整理, 放入個人網頁中. \n 參考電子書: \n Learn Autodesk Inventor 2018 Basics - 3D Modeling, 2D Graphics, and Assembly Design \n 請每位組員 登入 @gm 電子郵箱, \xa0 下載 NX 12.0.2 安裝光碟 , 或者 下載 NX12.0.2 虛擬主機板本 , 或者 下載 NX12 可攜版本 . 以便利用 NX12 執行下列專案的零組件設計繪圖與工程分析. \n 請每位學員參考\xa0 https://github.com/nasa-jpl/open-source-rover \xa0(提供 Solidworks 零組件檔案) 與 \xa0 https://github.com/mdecourse/Sawppy_Rover \xa0(提供 \xa0 Onshape 零組件檔案 ) 中的 Rover 設計, 分別利用\xa0 Inventor 2019 與 NX12 進行 Rover 零組件的設計與繪圖. \n 參考電子書: \n 2015 Space Modeling with SolidWorks and NX \n 登入 @gm 電子郵箱後,  下載上述 Inventor_nx_sw_onshape_ebooks.7z \n \n', 'tags': '', 'url': 'Task2.html'}, {'title': '導入 GitExtensions', 'text': '為了讓參與 Github 或 Gitlab 協同設計的成員能夠更方便使用 git 指令, 在此導入\xa0 https://github.com/gitextensions/gitextensions . \n 目前推薦使用 GitExtensions 的可攜版本: \n GitExtensions.7z \xa0或目前 最新版本 . \n GitExtensions 的 Tools->Settings 包含Git->Path: \n 必須提供 portablegit 的 bin 路徑以及可攜系統啟動時所使用的 home 位置. \n Git Extensions->SSH 則選擇使用 putty \n 由於 GitExtensions 3.0.2 版尚無法新增提交以中文命名的檔案, 因此必須透過 Tools-> Git GUI 執行新增提交與推送的指令. \n 使用 Git GUI 的好處是, 使用者可以較方便採用中文說明提交訊息.', 'tags': '', 'url': '導入 GitExtensions.html'}, {'title': 'Task3', 'text': '分組作業: \n 請各組將 Task1 所完成的行走車, 轉入 Webots, 並設法利用 Python 程式驅動行走, 完成後, 以協同模式製作一個帶有中文字幕的流程教學導引影片, 上傳至 Youtube 並內嵌至各分組網站中. \n Webots_2019b_rev1.7z \xa0 (登入 gm.nfu.edu.tw 後下載) \n Rover 零組件轉入  V-rep  與  Webots  執行機電控制系統設計 \n Webots 範例:\xa0 https://www.cyberbotics.com/doc/guide/sojourner \n 參考資料: \n 登入 @gm 電子郵箱後, \n 下載\xa0 Webots_reference_pdfs.7z \n 下載  Webots_2012_guide.pdf \n 下載  Vrep_reference_pdfs.7z \n', 'tags': '', 'url': 'Task3.html'}, {'title': 'Project', 'text': '機電資整合分組專案執行 \n 請各組參考先前已完成之 多段式頂球機構與循環鋼球運動系統 (例如: \xa0 1 , \xa0 2 , \xa0 3 ), 每組在 V-rep 或 Webots 中建立一個鋼球運動系統站, 並 結合 Task2 所完成的 Rover, 以執行各站鋼球搬運 \xa0 AS/RS \xa0 工作, 以組為單位, 完成結合機械設計、電子感測配置、電機驅動與程式控制的機電資整合專案. \n 完成後請 將相關過程與心得整理在分組網站, 製作一個帶有中文字幕的說明影片, 上傳至 Youtube 並內嵌至各分組網站, 過程中請利用 Blogger 網誌紀錄各階段心得, 最後再利用 Reveal 於 Week 17 進行期末分組簡報. \n Reference \n 機電資整合設計報告參考:\xa0 Mechanical Design Report DARPA BOSS Program.pdf \n Robotics.pdf \n Mars Exploration Rover Mobility Assembly Design Test and Performance.pdf \n Lunar Rover Motion Planning and Commands.pdf \n The Challenges of Designing the Rocker-Bogie Suspension for the Mars Exploration Rover.pdf \n Kinematic State Estimation For A Mars Rover.pdf \n ATHLETE_Scene_1_After Resp Masks.ttt.7z \xa0 (V-rep Scene) \n http://mde.tw/cadp2018/content/%E5%AF%A6%E7%BF%92%E6%93%8D%E4%BD%9C.html', 'tags': '', 'url': 'Project.html'}, {'title': 'Reference', 'text': '機電資系統整合專案 \n Mechanism \n Open Chain \n Pinball Machine \n Fosball Table \n \n Closed Chain \n Leg Mechanism \n https://github.com/Rhoban/Metabot \n https://github.com/poppy-project/poppy-humanoid \n A NOVEL WALKER WITH MECHANICALLY ESTABLISHED WALKING and Standing Mechanism.pdf \n The Design and Optimization of a Crank-Based Leg Mechanism.pdf \n A_Bipedal_Mechanical_Walker_with_Balancing_Mechani.pdf \n Adjustable Power Modulation for a leg mechanism suitable for running.pdf \n Marble Machine \n \n Claw Crane \n 3D Printing \n Elevator \n Robots \n Delta Robot \n Articulated Robot \n \n ( https://hackaday.io/project/3800-3d-printable-robot-arm ) \n https://hackaday.com/2017/01/17/3d-printed-strain-wave-gear-needs-your-help/ \n \n https://github.com/BCN3D/BCN3D-Moveo \n diy_printed_robot_arm_bom.txt \xa0( source ) \n Mobil Robot \n https://linorobot.org/ \n Mars Rover (火星漫遊車) \n July 4, 1997 -  Sojourner Rover \xa0降落火星, 漫遊車長度為 65 公分, 重量 11.5 公斤, 原始設計目標漫遊 7 日, 實際運行 85 天,\xa0 \n Jan., 2004 -  Spirit and Opportunity  降落火星, 漫遊車尺寸為 L 1.6 m X W 2.3m X H 1.5m, 重量 180 公斤, 原始設計目標漫遊火星日 90 天, Spirit 實際運作了 6 年 2 個月, 而 Opportunity 則持續運作了 15 年 3 個月. \n Aug. 6, 2012 (UTC) -  Curiosity  降落火星, 漫遊車尺寸為 L 2.9m X W 2.7m X H 2.2m, 重量為 899 公斤, 原始設計預計運作 2 年, 截至 July 15, 2019 仍持續運作中. \n Mars Rover 尺寸比較: \n \n 前方為 65 公分的  Sojourner , 左側為 1.6m 長的  Spirit  與  Opportunity  同尺寸漫遊車, 而右側為 2.9m 長的  Curiosity . \n 下一輛漫遊車 ( Mars 2020 計畫 ) 預計在 2021 年 2 月 18 日降落火星, 漫遊車尺寸 L 3m X W 2.7m X H 2.2m, 重量 1050 公斤. \n Automatic Guided Vehicle \n AS/RS \n', 'tags': '', 'url': 'Reference.html'}, {'title': 'Ebooks', 'text': '本課程所採用的兩本電子書, 第一本主要用於 Solidworks 2017 與 NX 12 執行零組件繪圖時參考, 而第二本則說明電腦輔助繪圖與設計程式發展歷史,\xa0 其中牽涉到許多套件間的開發細節與背景, 這些資料主要用於參考用. \n 1) 2015- Space Modeling with SolidWorks and NX \n https://link.springer.com/book/10.1007/978-3-319-03862-9 \n 2) 2008- The Engineering Design Revolution \n The Engineering Design Revolution \xa0(a.k.a. cad_history.pdf) \n 導讀: \n 第一本電子書標題的所謂 Space 指的是\xa0modeling of objects in 3D space\xa0 中的三度空間, 因此標題可以翻為: Solidworks 與 NX (套件)的(三度)空間(零組件)模擬. \n 有關 Solidworks 的開發緣起, 可以參考\xa0 The Engineering Design Revolution \xa0書中的第十八章. \n Solidworks 的前身是 2D 概念設計套件: DesignView, 由1983 年從 MIT 機械碩士畢業的\xa0Jon Hirschtick 於 1987 年取得資金 (150 萬美金) 後著手開發, 公司名稱為 Premise. 一開始 DesignView 就設定在當時剛萌芽的 IBM 相容個人電腦上執行. 當時一套 DesignView 商業版定價 1895 美元.\xa0 \n 之後 Premise 被 ComputerVision 公司併購, 1993 年 Jon Hirschtick 離開 ComputerVision, 隔年一月起便著手與與\xa0Bob Zuffante, Scott Harris, Constantine Dokos 與 Tommy Li 開發 Solidworks: 一套能夠在 PC 上運作的低價 CAD 套件. \n 1994 年 8 月 PTC 公司草創時編號 3 號的\xa0Michael Payne 離開 PTC, 加入開發 SolidWorks 的團隊. 期間參與投資者還包括日本的\xa0Kubota 公司. \n 1995 年 10 月 Solidworks 正式推出, 商業版定價每套 3995 美元. \n Solidworks 起始開發時採用 ACIS核心, 但正式發表前已經換為 Parasolid 核心, 1997 年 6 月法國達梭公司以 3 億美元併購 Solidworks. \n 有關  NX  (Unigraphics) 的詳細開發緣起, 可以參考\xa0 \xa0 The Engineering Design Revolution \xa0書中的第十九章. \n NX  套件的前身為 Unigraphics 早在 1973 年就啟動開發. 2001 年在  EDS  旗下與  SDRC  合併後進行 Unigraphics, I-DEAS 與 SDRC 整合, 產品名稱為  NX , 公司名稱為  UGS , 最終在 2007 年被德國  Siemens  以 35 億美元併購. \n 2015- Space Modeling with SolidWorks and NX  電子書中的第一章提到在三度空間建立零組件模型的主題包含: \n Role and meaning of modelling for engineering \n Making a sketch and extrude \n Making a sketch and revolve \n Auxiliary shapes of modelling Fillet, chamfer \n Assessment—combined models \n Complex shapes—sweep, loft \n Welded structures \n Sheet-metal products \n Measuring a physical model, digitising, parameterisation \n Assessment—physical models \n Assemblies of structures with models—bottom-up technique \n Assemblies of structures with models—top-down technique \n Documentation—assembly drawing \n Documentation—working drawing \n Assessment—examples as finished units Seminar work. \n \n \n \n \n 第一章第一節提到有關電腦教室的相關配置規劃. 以及產品開發流程: \n innovative loop (創新迴圈) \n The innovative loop is of key importance for recognizing a problem and placing it in space. In the innovation loop we specify the task, the requirements and the wishes that play a part in defining a problem or a technological process \n System engineering loop (系統工程迴圈) \n The system-engineering loop places an expected result (innovation, a high-quality product)—vital for the materialization of a product logically into space and time. \n Application research loop (應用研究迴圈) \n The application research loop is important in order to define the parameters that provide an optimum choice of function in the material, the conceptual and the user’s\xa0environment. \n Golden loop \n The golden loop in the development process defines a product in all its details, supplements fundamental researches for all key parameters that define the details and quality materialization of a product.', 'tags': '', 'url': 'Ebooks.html'}, {'title': 'Planar Linkage', 'text': 'linkages.pdf \n 平面機構表示法 \n 2010 年類似鍵結圖 ( Bond Graph ) 的平面機構表示法: \n A graph grammar scheme for representing and evaluating planar mechanisms.pdf \xa0( source ) \n 2019 年\xa0 https://github.com/KmolYuan/Pyslvs-UI \xa0採用\xa0\xa0 https://github.com/lark-parser/lark \xa0表示平面機構組成 \n PetitParser.pdf \xa0( http://kevmoo.github.io/PetitParserDart/petitparser.html ,\xa0 https://github.com/petitparser/dart-petitparser ,\xa0 https://github.com/moosetechnology/PetitParser ,\xa0 https://github.com/kursjan/petitparser2 ) \n PetitParser應用.pdf \xa0( https://github.com/freewind/SharkDart ,  1 ,  2 ,  3 ,  4 ,  5 ,  6 ,\xa0 7 ,  8 ) \n pmks_plus.pdf \xa0( http://mde.tw/cad2019/downloads/pmksplus/ ) \n pmks_firefox:\xa0 https://github.com/mdecourse/pmks_firefox \n M.Sketch.7z \xa0(登入 @gm 後下載) \n Modeling linkages using linkR v1.1.pdf \n https://github.com/KmolYuan/Pyslvs-UI \n https://github.com/mdecourse/Stagger \n Computational Design of Linkage-Based Characters.pdf \n Computational Design and Motion Control for Characters in the Real World.pdf \n Computational Design of Mechanical Characters.pdf \n Computational Design of Wind-up Toys.pdf \n Design of Linkages \n https://link.springer.com/book/10.1007/978-1-4419-7892-9 \n https://link.springer.com/book/10.1007/b98861 \n https://link.springer.com/content/pdf/10.1007%2F978-3-642-38448-6.pdf \n https://link.springer.com/book/10.1007/978-3-319-32922-2 \n https://link.springer.com/book/10.1007/978-90-481-9689-0 \n A graph grammar scheme for representing and evaluating planar mechanisms.pdf \xa0( source ) \n Automated design of planar mechanisms_2014.pdf \xa0( source ) \n Automated Synthesis of Planar Mechanisms with Revolute Prismatic and Pin-In-Slot Joints.pdf \n The A-Design Invention Machine.pdf \n Deep Learning \n https://link.springer.com/book/10.1007/978-3-319-99223-5 \n https://link.springer.com/book/10.1007/978-3-030-11479-4', 'tags': '', 'url': 'Planar Linkage.html'}, {'title': 'Design of Machinary', 'text': 'Kinematics - the study of motion without regard to forces \n Kinetics - the study of forces on systems in motion \n Mechanism - \n a device that transforms motion to some desirable pattern and typically develops very low forces and transmits little power. \n a means of transmitting, controlling or constraining relative movement \n a system of elements arranged to transmit motion in a predetermined fashion. \n Machine - contains mechanisms that are designed to provide significant forces and transmit significant power. \n The number of pairs of links or the number of instantaneous centres is the number of combinations of n links taken two at a time. Mathematically, number of instantaneous centres, n(n-1)/2. \n The Aronhold Kennedy’s theorem states that if three bodies move relatively to each other, they have three instantaneous centres and lie on a straight line. \n Fixed instantaneous centres remain in the same place for all configurations of the mechanism.', 'tags': '', 'url': 'Design of Machinary.html'}, {'title': 'Graph Grammar', 'text': '2010 \n A graph grammar scheme for representing and evaluating planar mechanisms.pdf \xa0( source ) \n Abstract \n There are different phases in any design activity, one of them being  concept generation . \n Research in  automating the conceptual design process in planar mechanisms  is always challenging due to the existence of many different elements and their endless combinations.  \n There may be instances where designers arrive at a concept without considering all the alternatives. Computational synthesis aims to arrive at a design by considering the entire space of valid designs.  \n Different researchers have adopted various methods to automate the design process that includes existence of similar graph grammar approaches. But few methods replicate the way humans’ design.  \n An attempt is being made in the thesis in this direction and as a first step, we focus on  representing and evaluating planar mechanisms designed using graph grammars . Graph grammars have been used to represent planar mechanisms but there are disadvantages in the methods currently available. This is due to the lack of information in understanding the details of a mechanism represented by the graph since the graphs do not include information about the type of joints and components such as revolute links, prismatic blocks, gears and cams.  \n In order to overcome drawbacks in the existing methods, a novel representation scheme has been developed. In this method,  labels and x, y position information in the nodes are used to represent the different mechanism types .  A set of sixteen grammar rules that construct different mechanisms from the basic seed is developed , which implicitly represents a tree of candidate solutions.  \n The scheme is tested to determine its capability in capturing the entire set of feasible planar mechanisms of one degree of freedom including Stephenson and double butterfly linkages. In addition to the representation, another important consideration is the need for an accurate and generalized evaluator for kinematic analysis of mechanisms which, given the lack of information, may not be possible with current design automation schemes.  \n The approach employed for analysis is purely kinematic and hence  the instantaneous center of rotation method is employed  in this research.  The velocities of pivots and links are obtained using the instant center method .  Once velocities are determined, the vector polygon approach is used to obtain accelerations and geometrical intersection to determine positions of pivots .  \n The graph grammar based analysis module is implemented in an existing object-oriented grammar framework  and the results have found this to be superior to or equivalent to existing commercial packages such as Working Model and SAM for topologies consisting of four-bar loop chain with single degree of freedom. \n Chapter 1 \n A design process is comprised of various activities such as gathering user requirements, generating concepts, analyzing properties of those concepts, building prototype and finally testing and refining to get the final outcome. In all the aforementioned activities, each of which are equally important, the concept generation phase is one that brings out the unique feature of the design. A concept may refer to the form (physical design) or the technology used in the functioning of the product. The concept generation process is generally a manual and time-consuming process. Different researchers have attempted computerization of the concept generation process in various domains including the design of planar mechanisms \n Reference: \n Optimum exact/approximate point synthesis of planar mechanisms \n Design of planar articulated mechanisms using branch and bound \n Chebychev–Grübler–Kutzbach criterion \n \n The correction to Grubler criterion for calculating the Degrees of Freedoms of Mechanisms.pdf', 'tags': '', 'url': 'Graph Grammar.html'}, {'title': 'PMKS', 'text': 'http://project.mde.tw/blog/planar-mechanism-kinematic-simulator-tuo-pu-fa-jian-jie.html \n https://github.com/mdecourse/pmks_firefox \n http://designengrlab.github.io/GraphSynth/ \n https://github.com/IDEALLab/design-data-list \n 從 \n https://github.com/mdecourse/pmks_firefox/blob/master/PKMS_source_codes/PlanarMechanismSimulator/PlanarMechanismKinematicSimulator.csproj \n 可以發現, PMKS 編譯時必須導入\xa0OOOT_Functions\\LineSearch\\Objective Function Constraint Classes\\Interfaces.cs \n 先根據 \n https://github.com/mdecourse/pmks_firefox/blob/master/PKMS_source_codes/PlanarMechanismSimulator/OOOT_Functions/OptMethods/abstractOptMethod.cs \n 中將數值分析解題分為六大類: \n IOptFunction \xa0 \xa0 IInequality \xa0 \xa0 IEquality \xa0 \xa0 IObjectiveFunction IDependentAnalysis abstractLineSearch abstractSearchDirection abstractMeritFunction abstractConvergence \n 其中主要運算則導向 \n inequality, equality, objectiveFunction, abstractLineSearch 以及abstractSearchDirection 等運算方法. \n 而各點計算位置, 速度與加速度的程式碼, 位於: \n https://github.com/mdecourse/pmks_firefox/blob/master/PKMS_source_codes/PlanarMechanismSimulator/Simulator%20Classes/PlanarMechanismSimulator.Numerical.cs \n 平面機構任一時間點的位置計算: \n         static double FindPositionatTime(double tau, double deltaTime, double posPrevious, double posNext, double vPrevious,\n               double vNext, double aPrevious, double aNext)\n        {\n            var tauSquared = tau * tau;\n            var tauCubed = tau * tauSquared;\n            var tauToThe4th = tau * tauCubed;\n            var tauToThe5th = tau * tauToThe4th;\n            var deltaTimeSquared = deltaTime * deltaTime;\n            var deltaTimeCubed = deltaTime * deltaTimeSquared;\n            return posPrevious + vPrevious * tau + aPrevious * tauSquared / 2\n                   + tauCubed * (10 * (posNext - posPrevious) / deltaTimeSquared - 6 * vPrevious / deltaTime - 4 * vNext / deltaTime\n                   - 1.5 * aPrevious + aNext / 2) / deltaTime\n                   + tauToThe4th * (15 * (posPrevious - posNext) / deltaTimeSquared + 8 * vPrevious / deltaTime + 7 * vNext / deltaTime\n                   + 1.5 * aPrevious - aNext) / deltaTimeSquared\n                   + tauToThe5th * (6 * (posPrevious - posNext) / deltaTimeSquared + 3 * (vPrevious + vNext) / deltaTime + 0.5 * (aPrevious - aNext))\n                   / deltaTimeCubed;\n        } \n 各點的速度計算: \n         static double FindVelocityatTime(double tau, double deltaTime, double vPrevious, double vNext, double aPrevious, double aNext)\n        {\n            if (deltaTime == 0.0) return vPrevious;\n            var tauSquared = tau * tau;\n            var tauCubed = tau * tauSquared;\n            var deltaTimeSquared = deltaTime * deltaTime;\n            var deltaTimeCubed = deltaTime * deltaTimeSquared;\n            return vPrevious\n                   + (vPrevious - vNext) * (2 * tauCubed / deltaTimeCubed - 3 * tauSquared / deltaTimeSquared)\n                   + aNext * (tauCubed / deltaTimeSquared - tauSquared / deltaTime)\n                   + aPrevious * (tauCubed / deltaTimeSquared - 2 * tauSquared / deltaTime + tau);\n        } \n 各點的加速度計算: \n         static double FindAccelerationatTime(double tau, double deltaTime, double aPrevious, double aNext)\n        {\n            if (deltaTime == 0.0) return aPrevious;\n            return aPrevious + (aNext - aPrevious) * tau / deltaTime;\n        } \n 利用 Dart 執行矩陣運算: \n http://mde.tw/c16278af1d23579b5f5d5dca5b7e090e', 'tags': '', 'url': 'PMKS.html'}, {'title': 'CAD2CAE', 'text': '1  autodesk_inventor_tutorial.7z \n \n Solvespace:  cad2cae_1_solvespace.slvs \n FreeCAD: \n NX12: \n Solidworks: \n Inventor: \n Onshape: \n 2 \n \n 3 \n \n 4 \n \n 5 \n \n 6 \n \n 7 \n \n 8 \n \n 9 \n \n 10 \n \n 11 \n \n 12 \n \n 13 \n \n 14 \n \n 15 \n \n 16 \n \n ex16.slvs \n \n 17 \n \n 18 \n', 'tags': '', 'url': 'CAD2CAE.html'}]};