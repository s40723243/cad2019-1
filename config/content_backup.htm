<h1>About</h1>
<p>本電腦輔助機械設計實習課程, 除了教導學生使用電腦輔助設計套件 ( <a href="https://www.solidworks.com/">Solidworks</a>, <a href="https://www.plm.automation.siemens.com/global/en/products/nx/">NX</a>) 中, 各種參數式 3D 零組件設計與繪圖功能外, 也導入開源的 <a href="http://solvespace.com">Solvespace</a>, <a href="https://www.freecadweb.org/">FreeCAD</a>, <a href="http://www.coppeliarobotics.com/">V-rep</a> 與 <a href="https://cyberbotics.com/">Webots</a>, 讓學員了解這些中高端套件的底層所包含的各種數學原理與程式技術. 並且透過全雲端 <a href="https://www.onshape.com/">Onshape</a> 的協同設計, 引領學員一窺未來全球協同產品開發流程可能呈現的架構與風貌.</p>
<p>電腦輔助設計實習課程承接計算機程式與網際內容管理課程, 並與協同產品設計實習採用相同工具與理念, 希望所有學員能夠在電腦軟硬體與網路系統的充分整合應用下, 有能力透過程式方法與網際內容管理的架構, 執行創新產品開發.</p>
<h4>課程工具套件:</h4>
<p style="padding-left: 30px;"><a href="https://drive.google.com/file/d/1fxMdqdCoCL__O1IpZ-Sv-A_4-c77Wx4E/view?usp=sharing">2019Fall可攜套件.7z</a> (編譯  Solvespace 用)</p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/file/d/1lNCUsmRtsl5K128Oa2lbN2ZmriXynrQP/view?usp=sharing">dartpad_based.7z</a> (登入 @gm 帳號後下載)</p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/file/d/1oUbvEWYbWAZM6nIfhQqC8oCcb9fcCJ5F/view?usp=sharing">GitExtensions.7z</a></p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/file/d/13-ByKlFCsScF3xHi1SZrsJ1ZOejzFXZo/view?usp=sharing">FreeCAD 0.18.7z</a></p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/file/d/1cZFSsLEoGOBYojzKzFEf4YH2l--pbS-9/view?usp=sharing">V-rep 3.6.1 rev 4.7z</a></p>
<p style="padding-left: 30px;"><span><a href="https://drive.google.com/file/d/1o8cAv-pSUyp69TUGhC7NvEznGrdNP5AC/view?usp=sharing">Webot 2019a.7z</a></span></p>
<p style="padding-left: 30px;"><span>登入 @gm 帳號後, <a href="https://drive.google.com/drive/folders/1d304eHPWVSS-LKm6k3dNa0pArotPF6PK?usp=sharing">下載課程教學影片</a></span></p>
<p><span>請登入 @gm 帳號後, <a href="https://forms.gle/NhyRQTxCUSqQBH3n7">填寫選課學員基本資料</a></span></p>
<h4>電腦輔助設計室與協同設計室行事曆</h4>
<p><a href="https://calendar.google.com/calendar/embed?src=mde.nfu.edu.tw_3439313938333136353439%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei&amp;mode=week&amp;src=mde.nfu.edu.tw_35303530373431313438%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei">全頁檢視</a></p>
<p><iframe height="600" src="https://calendar.google.com/calendar/embed?src=mde.nfu.edu.tw_3439313938333136353439%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei&amp;mode=week&amp;src=mde.nfu.edu.tw_35303530373431313438%40resource.calendar.google.com&amp;ctz=Asia%2FTaipei" width="800"></iframe></p>
<h4>2019 Fall 學期教育目標:</h4>
<p>使用可攜程式系統與網際內容管理系統, 管理各學員與分組學習內容, 同時利用 <a href="https://www.solidworks.com/">Solidworks</a>, <a href="https://www.plm.automation.siemens.com/global/en/products/nx/">NX</a>,<span> </span><a href="https://www.onshape.com/">Onshape</a>, <a href="http://solvespace.com">Solvespace</a>, <a href="https://www.freecadweb.org/">FreeCAD</a>, <a href="https://cyberbotics.com/">Webots</a><span> </span>與<span> </span><a href="http://www.coppeliarobotics.com/">V-rep</a><span> </span>執行機電資整合產品開發, 當面臨各種電腦輔助機械設計階段所遭遇問題時, 各學員可利用客製化程式加以解決.</p>
<h4>Textbooks:</h4>
<p style="padding-left: 30px;">1) 2015- Space Modeling with SolidWorks and NX</p>
<p style="padding-left: 60px;"><a href="https://link.springer.com/book/10.1007/978-3-319-03862-9">https://link.springer.com/book/10.1007/978-3-319-03862-9</a></p>
<p style="padding-left: 30px;">2) 2008- The Engineering Design Revolution</p>
<p style="padding-left: 60px;"><a href="/downloads/cad_history.pdf">The Engineering Design Revolution</a> (a.k.a. cad_history.pdf)</p>
<h4>達成學期教育目標之評量方式與標準:</h4>
<p>評分比例 <span>(包含學員自評、同組互評與教師評分等三項)</span>:</p>
<hr/>
<p><span>請注意:</span></p>
<ol>
<li style="padding-left: 30px;"><span>建議各學員針對課程所指定之作業或課題時, 務必先在個人網頁與網誌登錄相關搜尋結果, 初步完成之個人操作影片, 以及個人擬解決問題的想法後, 再參與分組討論與任務執行.</span></li>
<li style="padding-left: 30px;"><span>除第一週外, 每位組員必須在次週上課前完成個人倉儲的資料維護, 並至<a href="https://forms.gle/raTtrfjv8cMMVSZd6">課程評量表單</a>完成自評與同組組員互評.</span></li>
<li style="padding-left: 30px;"><span>任何課程相關問題可以至 <a href="https://github.com/mdecourse/cad2019/issues/5">Q&amp;A</a> (需登入) 或<a href="https://forms.gle/39mqLTmso6JfHuD27">回饋表單</a> (無需登入) 提出.</span></li>
</ol>
<hr/>
<p style="padding-left: 30px;">學員出席 (10%)</p>
<p style="padding-left: 30px;">個人倉儲與網站查驗 (20%)</p>
<p style="padding-left: 30px;">Task1: 參數式繪圖軟體 Solvespace 編譯、零組件繪圖與應用 (10%)</p>
<p style="padding-left: 30px;">Task2: MCAD 套件安裝與設定, 零組件繪圖、轉檔與 CAE 工程分析 (10%)</p>
<p style="padding-left: 30px;">Task3: <span>Rover 零組件轉入<a href="http://www.coppeliarobotics.com/"><span> </span>V-rep</a><span> </span>與<span> </span><a href="https://cyberbotics.com/">Webots</a><span> </span>執行機電控制系統設計 (20%)</span></p>
<p style="padding-left: 30px;">Project: <span>機電資整合分組專案執行 (30%)</span></p>
<p>評分方式:</p>
<p style="padding-left: 30px;">電腦輔助設計實習每週自評與互評表單: <a href="https://forms.gle/raTtrfjv8cMMVSZd6">https://forms.gle/raTtrfjv8cMMVSZd6</a> </p>
<p>教學方式:</p>
<p style="padding-left: 30px;">課堂講授</p>
<p style="padding-left: 30px;">操作錄影</p>
<p style="padding-left: 30px;">學員實習</p>
<p style="padding-left: 30px;">分組報告</p>
<p>參考資料:</p>
<p><a href="https://open.umn.edu/opentextbooks/subjects/engineering">https://open.umn.edu/opentextbooks/subjects/engineering</a> </p><h2>Evaluation</h2>
<p><span>電腦輔助設計實習每週自評與互評表單: </span><a href="https://forms.gle/raTtrfjv8cMMVSZd6">https://forms.gle/raTtrfjv8cMMVSZd6</a><span> </span></p>
<h4>課程計分流程:</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">'''
根據評分表單中的 自評分數, 互評得分, 教師評分, 計算學員課程成績
'''
 
def diff(自評分數, 互評得分):
    return abs(自評分數 - 互評得分)
     
def max(自評分數, 互評得分):
    if 自評分數 &gt; 互評得分:
        return 自評分數
    else:
        return 互評得分
 
def 分組比分(自評分數, 互評得分):
    if diff(自評分數, 互評得分) &lt; 5:
        學員得分 = max(自評分數, 互評得分)
    else:
        學員得分 = 互評得分 - diff(自評分數, 互評得分)
    return 學員得分
     
def 全班比分(學員得分, 教師評分):
    if diff(學員得分, 教師評分) &lt; 5:
        學員成績 = max(學員得分, 教師評分)
    else:
        學員成績 = 教師評分 - diff(學員得分, 教師評分)/4
    return 學員成績
 
def 學員成績(自評分數, 互評得分, 教師評分):
    學員分組得分 = 分組比分(自評分數, 互評得分)
    學員課程成績 = 全班比分(學員分組得分, 教師評分)
    return 學員課程成績
     
print(學員成績(80, 70, 60))
print(學員成績(60, 70, 80))</pre><h2>課程表單</h2>
<p><span>電腦輔助設計實習每週自評與互評表單: </span><a href="https://forms.gle/raTtrfjv8cMMVSZd6">https://forms.gle/raTtrfjv8cMMVSZd6</a><span> (必須登入 @gm 帳號)</span></p>
<p><span><a href="https://github.com/mdecourse/cad2019/issues/5">電腦輔助設計實習課程 Q and A</a> (需登入 Github 帳號)</span></p>
<p><a href="https://forms.gle/S5omHaKXR8HvDsmy5">課程反應表單</a> (無需登入 @gm 帳號)</p>
<p></p><h2>Theories</h2>
<p><a href="https://link.springer.com/book/10.1007/978-3-030-02399-7">Advanced CAD Modeling</a></p>
<p><a href="https://github.com/deadsy/sdfx">https://github.com/deadsy/sdfx</a> </p>
<p><a href="https://link.springer.com/book/10.1007/978-3-319-74594-7">Solid Modeling and Applications</a></p>
<p><a href="https://link.springer.com/book/10.1007/978-0-85729-259-9">Solid Modeling and CAD Systems</a></p>
<p><span><a href="http://mde.tw/cadp2018/downloads/intro_cad.pdf">http://mde.tw/cadp2018/downloads/intro_cad.pdf</a></span></p>
<p><span><a href="http://mde.tw/cadp2018/downloads/cadbook.pdf">http://mde.tw/cadp2018/downloads/cadbook.pdf</a> (<a href="/downloads/CAD_book.pdf">CAD_Book.pdf</a>)</span></p>
<p><a href="/downloads/3D-Modelling-with-the-ACIS-Kernel-and-Toolkit.pdf">3D-Modelling-with-the-ACIS-Kernel-and-Toolkit.pdf</a></p>
<p><span><a href="http://mde.tw/cadp2018/downloads/mit_intro_cad.pdf">http://mde.tw/cadp2018/downloads/mit_intro_cad.pdf</a></span></p>
<p><span><a href="http://mde.tw/cadp2018/downloads/robot_kinematics_and_dynamics.pdf">http://mde.tw/cadp2018/downloads/robot_kinematics_and_dynamics.pdf</a></span></p>
<p><span><a href="http://mde.tw/cadp2018/downloads/Kinematics%20of%20Machines.pdf">http://mde.tw/cadp2018/downloads/Kinematics%20of%20Machines.pdf</a></span></p>
<p><span><a href="http://mde.tw/cadp2018/gears/Gear%20Drawing%20with%20Bezier%20Curves.pdf">http://mde.tw/cadp2018/gears/Gear%20Drawing%20with%20Bezier%20Curves.pdf</a></span></p>
<p><span><a href="http://mde.tw/cadp2018/content/%E7%A8%8B%E5%BC%8F%E5%BA%AB%E7%AF%84%E4%BE%8B.html">http://mde.tw/cadp2018/content/%E7%A8%8B%E5%BC%8F%E5%BA%AB%E7%AF%84%E4%BE%8B.html</a></span></p>
<p><span><a href="http://mde.tw/cadp2018/content/%E8%BC%94%E5%8A%A9%E8%A8%AD%E8%A8%88%E5%A5%97%E4%BB%B6.html">http://mde.tw/cadp2018/content/%E8%BC%94%E5%8A%A9%E8%A8%AD%E8%A8%88%E5%A5%97%E4%BB%B6.html</a></span></p>
<p><a href="http://mde.tw/cadp2018/downloads/intro_curves.pdf">http://mde.tw/cadp2018/downloads/intro_curves.pdf</a></p>
<p><a href="http://verbnurbs.com/">http://verbnurbs.com/</a> (<a href="https://github.com/pboyer/verb">https://github.com/pboyer/verb</a>) (<a href="https://haxe.org/">https://haxe.org/</a>)</p>
<p><a href="https://pomax.github.io/bezierinfo/">https://pomax.github.io/bezierinfo/</a></p>
<p><a href="https://github.com/bluecube/codecad">https://github.com/bluecube/codecad</a></p>
<p><a href="https://github.com/DLR-SC/tigl">https://github.com/DLR-SC/tigl</a></p><h3>Foundations</h3>
<p><a href="/downloads/Mechanical Design Report DARPA BOSS Program.pdf">Mechanical Design Report DARPA BOSS Program.pdf</a></p>
<p><a href="/downloads/4a_Coordinate_system_and_transformations.pdf">Coordinate_system_and_transformations.pdf</a></p>
<p><a href="/downloads/6a_Optimization.pdf">Optimization.pdf</a></p>
<p><a href="/downloads/6b_Optimization_search.pdf">Optimization_search.pdf</a></p>
<p><a href="/downloads/8a_Curves.pdf">Curves.pdf</a></p>
<p><a href="/downloads/8b_b-spline_examples.pdf">b-spline_examples.pdf</a></p>
<p><a href="/downloads/10b_CAD_Data_Exchange.pdf">CAD_Data_Exchange.pdf</a></p>
<h3>Design Theory</h3>
<p><a href="/downloads/Computer-Based Design Synthesis Research - An Overview.pdf">Computer-Based Design Synthesis Research - An Overview.pdf</a></p>
<p><a href="/downloads/Implications of designer behavior for design synthesis tool interaction design.pdf">Implications of designer behavior for design synthesis tool interaction design.pdf</a></p>
<p><a href="/downloads/A method based on C-K Theory for fast STCR development - The case of a drilling robot design.pdf">A method based on C-K Theory for fast STCR development - The case of a drilling robot design.pdf</a></p>
<p><a href="/downloads/Product Design and Development 2.0 Applied C-K theory -to innovate in a digital age.pdf">Product Design and Development 2.0 Applied C-K theory -to innovate in a digital age.pdf</a></p>
<p><a href="/downloads/IDEA GENERATION IN ENGINEERING DESIGN APPLICATION OF A MEMORY SEARCH PERSPECTIVE AND SOME EXPERIMENTAL STUDIES.pdf">IDEA GENERATION IN ENGINEERING DESIGN APPLICATION OF A MEMORY SEARCH PERSPECTIVE AND SOME EXPERIMENTAL STUDIES.pdf</a></p>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/K0kLeycHT4s" width="560"></iframe></p>
<p><a href="https://github.com/mdecourse/cd2018/issues/3">https://github.com/mdecourse/cd2018/issues/3</a></p>
<p>Design Theory - Methods and Organization for Innovation</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-3-319-50277-9">https://link.springer.com/book/10.1007/978-3-319-50277-9</a></p>
<p>Theory and Design of CNC Systems</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-84800-336-1">https://link.springer.com/book/10.1007/978-1-84800-336-1</a></p>
<p>An Anthology of Theories and Models of Design - Philosophy, Approaches and Empirical Explorations</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4471-6338-1">https://link.springer.com/book/10.1007/978-1-4471-6338-1</a></p>
<p>Control Systems Design - A New Framework</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/1-84628-215-2">https://link.springer.com/book/10.1007/1-84628-215-2</a></p>
<h3>Optimal Design</h3>
<p>Mechanical Design Optimization Using Advanced Optimization Techniques</p>
<p><a href="https://link.springer.com/book/10.1007/978-1-4471-2748-2">https://link.springer.com/book/10.1007/978-1-4471-2748-2</a> </p>
<p>Optimization Methods for Engineering Design</p>
<p><a href="http://apmonitor.com/me575/uploads/Main/optimization_book.pdf">http://apmonitor.com/me575/uploads/Main/optimization_book.pdf</a>  or<span> </span><a href="http://mde.tw/cadp2018/downloads/optimization_book.pdf">local</a></p>
<p><a href="https://github.com/williamhunter/topy">https://github.com/williamhunter/topy</a> </p>
<p><a href="http://www.analyzemath.com/calculus.html#Calculus_Problems">http://www.analyzemath.com/calculus.html#Calculus_Problems</a></p>
<p>以<span> </span><a href="https://en.wikipedia.org/wiki/Differential_evolution">Differential Evolution</a><span> </span>algorithm 解題:</p>
<p>以總面積 80 cm^2 的鐵皮所能焊出最大容量的方形容器:</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">// 必須在演算過程中, 設法限制各變數的上下限!
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;memory.h&gt;
#include &lt;time.h&gt;
  
// 最大族群數, NP
#define MAXPOP  5000
// 最大向量維度, D
#define MAXDIM  35
// MAXIMAPROBLEM =1 最大化 0 最小化
#define MAXIMAPROBLEM 1
// 最大化時 PENALITY 必須為負值, 否則為正值
#define PENALITY -1000
/*
#define MAXIMAPROBLEM 0
#define PENALITY 1000
*/
  
/*------Constants for rnd_uni()--------------------------------------------*/
  
#define IM1 2147483563
#define IM2 2147483399
#define AM (1.0/IM1)
#define IMM1 (IM1-1)
#define IA1 40014
#define IA2 40692
#define IQ1 53668
#define IQ2 52774
#define IR1 12211
#define IR2 3791
#define NTAB 32
#define NDIV (1+IMM1/NTAB)
#define EPS 1.2e-7
#define RNMX (1.0-EPS)
  
/*------------------------Globals---------------------------------------*/
  
long  rnd_uni_init;                 /* serves as a seed for rnd_uni()   */
double c[MAXPOP][MAXDIM], d[MAXPOP][MAXDIM];
double (*pold)[MAXPOP][MAXDIM], (*pnew)[MAXPOP][MAXDIM], (*pswap)[MAXPOP][MAXDIM];
  
/*---------Function declarations----------------------------------------*/
  
void  assignd(int D, double a[], double b[]);
double rnd_uni(long *idum);    /* uniform pseudo random number generator */
double extern evaluate(int D, double tmp[], long *nfeval); /* obj. funct. */
  
/*---------Function definitions-----------------------------------------*/
// 指定向量 b 為 a
void  assignd(int D, double a[], double b[])
{
   int j;
   for (j=0; j&lt;D; j++)
   {
      a[j] = b[j];
   }
}
  
// 產生 0 ~ 1 間的亂數
double rnd_uni(long *idum)
{
  long j;
  long k;
  static long idum2=123456789;
  static long iy=0;
  static long iv[NTAB];
  double temp;
  
  if (*idum &lt;= 0)
  {
    if (-(*idum) &lt; 1) *idum=1;
    else *idum = -(*idum);
    idum2=(*idum);
    for (j=NTAB+7;j&gt;=0;j--)
    {
      k=(*idum)/IQ1;
      *idum=IA1*(*idum-k*IQ1)-k*IR1;
      if (*idum &lt; 0) *idum += IM1;
      if (j &lt; NTAB) iv[j] = *idum;
    }
    iy=iv[0];
  }
  k=(*idum)/IQ1;
  *idum=IA1*(*idum-k*IQ1)-k*IR1;
  if (*idum &lt; 0) *idum += IM1;
  k=idum2/IQ2;
  idum2=IA2*(idum2-k*IQ2)-k*IR2;
  if (idum2 &lt; 0) idum2 += IM2;
  j=iy/NDIV;
  iy=iv[j]-idum2;
  iv[j] = *idum;
  if (iy &lt; 1) iy += IMM1;
  if ((temp=AM*iy) &gt; RNMX) return RNMX;
  else return temp;
  
}/*------End of rnd_uni()--------------------------*/
  
// 將上下限轉為全域變數
double inibound_h;      /* upper parameter bound              */
double inibound_l;      /* lower parameter bound              */
// 與機構合成相關的全域變數
// 宣告一個座標結構
struct Coord {
    double x;
    double y;
  // 這裡保留 double z;
};
  
main(int argc, char *argv[])
{
   char  chr;             /* y/n choice variable                */
   char  *strat[] =       /* strategy-indicator                 */
   {
            "",
            "DE/best/1/exp",
            "DE/rand/1/exp",
            "DE/rand-to-best/1/exp",
            "DE/best/2/exp",
            "DE/rand/2/exp",
            "DE/best/1/bin",
            "DE/rand/1/bin",
            "DE/rand-to-best/1/bin",
            "DE/best/2/bin",
            "DE/rand/2/bin"
   };
  
   int   i, j, L, n;      /* counting variables                 */
   int   r1, r2, r3, r4;  /* placeholders for random indexes    */
   int   r5;              /* placeholders for random indexes    */
   int   D;               /* Dimension of parameter vector      */
   int   NP;              /* number of population members       */
   int   imin;            /* index to member with lowest energy */
   int   refresh;         /* refresh rate of screen output      */
   int   strategy;        /* choice parameter for screen output */
   int   gen, genmax, seed;   
  
   long  nfeval;          /* number of function evaluations     */
  
   double trial_cost;      /* buffer variable                    */
   // 將上下限轉為全域變數, 可能要根據各變數加以設定
   //double inibound_h;      /* upper parameter bound              */
   //double inibound_l;      /* lower parameter bound              */
   double tmp[MAXDIM], best[MAXDIM], bestit[MAXDIM]; /* members  */
   double cost[MAXPOP];    /* obj. funct. values                 */
   double cvar;            /* computes the cost variance         */
   double cmean;           /* mean cost                          */
   double F,CR;            /* control variables of DE            */
   double cmin;            /* help variables                     */
  
   FILE  *fpin_ptr;
   FILE  *fpout_ptr;
  
// 計算執行過程所需時間起點, 需要導入 time.h
  clock_t start = clock();
  
/*------Initializations----------------------------*/
  
// 將結果寫入 out.dat
 fpout_ptr = fopen("out.dat","w");          /* open output file for reading,    */
// 目前已經採用 strategy 3 可以得到最佳結果
  strategy = 3;
  genmax = 2000;
  refresh = 100;
  // 配合機構尺寸合成, 每一個體有 9 個機構尺寸值與 5 個通過點角度值
  D = 2;
  NP = 200;
  inibound_h = 50.;
  inibound_l = 0.;
/*得到最佳解
  F = 0.85;
CR 必須介於 0 to 1. 之間
  CR = 1.;
*/
  F = 0.85;
  CR = 1.;
  seed = 3;
  
 //fclose(fpin_ptr);
  
/*-----Checking input variables for proper range----------------------------*/
  
  if (D &gt; MAXDIM)
  {
     printf("\nError! D=%d &gt; MAXDIM=%d\n",D,MAXDIM);
     exit(1);
  }
  if (D &lt;= 0)
  {
     printf("\nError! D=%d, should be &gt; 0\n",D);
     exit(1);
  }
  if (NP &gt; MAXPOP)
  {
     printf("\nError! NP=%d &gt; MAXPOP=%d\n",NP,MAXPOP);
     exit(1);
  }
  if (NP &lt;= 0)
  {
     printf("\nError! NP=%d, should be &gt; 0\n",NP);
     exit(1);
  }
  if ((CR &lt; 0) || (CR &gt; 1.0))
  {
     printf("\nError! CR=%f, should be ex [0,1]\n",CR);
     exit(1);
  }
  if (seed &lt;= 0)
  {
     printf("\nError! seed=%d, should be &gt; 0\n",seed);
     exit(1);
  }
  if (refresh &lt;= 0)
  {
     printf("\nError! refresh=%d, should be &gt; 0\n",refresh);
     exit(1);
  }
  if (genmax &lt;= 0)
  {
     printf("\nError! genmax=%d, should be &gt; 0\n",genmax);
     exit(1);
  }
  if ((strategy &lt; 0) || (strategy &gt; 10))
  {
     printf("\nError! strategy=%d, should be ex {1,2,3,4,5,6,7,8,9,10}\n",strategy);
     exit(1);
  }
  if (inibound_h &lt; inibound_l)
  {
     printf("\nError! inibound_h=%f &lt; inibound_l=%f\n",inibound_h, inibound_l);
     exit(1);
  }
  
/*-----Initialize random number generator-----------------------------*/
  
 rnd_uni_init = -(long)seed;  /* initialization of rnd_uni() */
 nfeval       =  0;  /* reset number of function evaluations */
  
/*------Initialization------------------------------------------------*/
/*------Right now this part is kept fairly simple and just generates--*/
/*------random numbers in the range [-initfac, +initfac]. You might---*/
/*------want to extend the init part such that you can initialize-----*/
/*------each parameter separately.------------------------------------*/
  
   for (i=0; i&lt;NP; i++)
   {
      for (j=0; j&lt;D; j++) /* spread initial population members */
      {
        c[i][j] = inibound_l + rnd_uni(&amp;rnd_uni_init)*(inibound_h - inibound_l);
      }
      cost[i] = evaluate(D,c[i],&amp;nfeval); /* obj. funct. value */
   }
   cmin = cost[0];
   imin = 0;
   for (i=1; i&lt;NP; i++)
   {
     if(MAXIMAPROBLEM == 1)
     {
       // 改為最大化
        if (cost[i]&gt;cmin)
        {
          cmin = cost[i];
          imin = i;
        }
      }
      else
      {
        // 最小化問題
        if (cost[i]&lt;cmin)
        {
          cmin = cost[i];
          imin = i;
        }
      }
   }
  
   assignd(D,best,c[imin]);            /* save best member ever          */
   assignd(D,bestit,c[imin]);          /* save best member of generation */
  
   pold = &amp;c; /* old population (generation G)   */
   pnew = &amp;d; /* new population (generation G+1) */
  
/*=======================================================================*/
/*=========Iteration loop================================================*/
/*=======================================================================*/
  
   gen = 0;                          /* generation counter reset */
   while ((gen &lt; genmax) /*&amp;&amp; (kbhit() == 0)*/) /* remove comments if conio.h */
   {                                            /* is accepted by compiler    */
      gen++;
      imin = 0;
  
      for (i=0; i&lt;NP; i++)         /* Start of loop through ensemble  */
      {
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 2 !!!     */
       r1 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while(r1==i);            
  
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 3 !!!     */
       r2 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r2==i) || (r2==r1));
  
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 4 !!!     */
       r3 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r3==i) || (r3==r1) || (r3==r2));
  
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 5 !!!     */
       r4 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r4==i) || (r4==r1) || (r4==r2) || (r4==r3));
  
     do                        /* Pick a random population member */
     {                         /* Endless loop for NP &lt; 6 !!!     */
       r5 = (int)(rnd_uni(&amp;rnd_uni_init)*NP);
     }while((r5==i) || (r5==r1) || (r5==r2) || (r5==r3) || (r5==r4));
  
/*=======EXPONENTIAL CROSSOVER============================================================*/
  
/*-------DE/best/1/exp--------------------------------------------------------------------*/
/*-------Our oldest strategy but still not bad. However, we have found several------------*/
/*-------optimization problems where misconvergence occurs.-------------------------------*/
     if (strategy == 1) /* strategy DE0 (not in our paper) */
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D);
       L = 0;
       do
       {                       
         tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/rand/1/exp-------------------------------------------------------------------*/
/*-------This is one of my favourite strategies. It works especially well when the-------*/
/*-------"bestit[]"-schemes experience misconvergence. Try e.g. F=0.7 and CR=0.5---------*/
/*-------as a first guess.---------------------------------------------------------------*/
     else if (strategy == 2) /* strategy DE1 in the techreport */
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D);
       L = 0;
       do
       {                       
         tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/rand-to-best/1/exp-----------------------------------------------------------*/
/*-------This strategy seems to be one of the best strategies. Try F=0.85 and CR=1.------*/
/*-------If you get misconvergence try to increase NP. If this doesn't help you----------*/
/*-------should play around with all three control variables.----------------------------*/
     else if (strategy == 3) /* similiar to DE2 but generally better */
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
       L = 0;
       do
       {                       
         tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/best/2/exp is another powerful strategy worth trying--------------------------*/
     else if (strategy == 4)
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
       L = 0;
       do
       {                           
         tmp[n] = bestit[n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
/*-------DE/rand/2/exp seems to be a robust optimizer for many functions-------------------*/
     else if (strategy == 5)
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
       L = 0;
       do
       {                           
         tmp[n] = (*pold)[r5][n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         n = (n+1)%D;
         L++;
       }while((rnd_uni(&amp;rnd_uni_init) &lt; CR) &amp;&amp; (L &lt; D));
     }
  
/*=======Essentially same strategies but BINOMIAL CROSSOVER===============================*/
  
/*-------DE/best/1/bin--------------------------------------------------------------------*/
     else if (strategy == 6) 
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = bestit[n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         }
         n = (n+1)%D;
           }
     }
/*-------DE/rand/1/bin-------------------------------------------------------------------*/
     else if (strategy == 7) 
     {
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = (*pold)[r1][n] + F*((*pold)[r2][n]-(*pold)[r3][n]);
         }
         n = (n+1)%D;
           }
     }
/*-------DE/rand-to-best/1/bin-----------------------------------------------------------*/
     else if (strategy == 8) 
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = tmp[n] + F*(bestit[n] - tmp[n]) + F*((*pold)[r1][n]-(*pold)[r2][n]);
         }
         n = (n+1)%D;
           }
     }
/*-------DE/best/2/bin--------------------------------------------------------------------*/
     else if (strategy == 9)
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = bestit[n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         }
         n = (n+1)%D;
           }
     }
/*-------DE/rand/2/bin--------------------------------------------------------------------*/
     else
     { 
       assignd(D,tmp,(*pold)[i]);
       n = (int)(rnd_uni(&amp;rnd_uni_init)*D); 
           for (L=0; L&lt;D; L++) /* perform D binomial trials */
           {
         if ((rnd_uni(&amp;rnd_uni_init) &lt; CR) || L == (D-1)) /* change at least one parameter */
         {                       
           tmp[n] = (*pold)[r5][n] + 
              ((*pold)[r1][n]+(*pold)[r2][n]-(*pold)[r3][n]-(*pold)[r4][n])*F;
         }
         n = (n+1)%D;
           }
     }
  
  
/*=======Trial mutation now in tmp[]. Test how good this choice really was.==================*/
  
     trial_cost = evaluate(D,tmp,&amp;nfeval);  /* Evaluate new vector in tmp[] */
   if(MAXIMAPROBLEM == 1)
   {
    // 改為最大化
       if (trial_cost &gt;= cost[i])   /* improved objective function value ? */
       {                                  
          cost[i]=trial_cost;         
          assignd(D,(*pnew)[i],tmp);
          if (trial_cost&gt;cmin)          /* Was this a new minimum? */
          {                               /* if so...*/
             cmin=trial_cost;           /* reset cmin to new low...*/
             imin=i;
             assignd(D,best,tmp);           
          }                           
       }                            
       else
       {
          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
       }
    }
    else
    {
          // 最小化問題
       if (trial_cost &lt;= cost[i])   /* improved objective function value ? */
       {                                  
          cost[i]=trial_cost;         
          assignd(D,(*pnew)[i],tmp);
          if (trial_cost&lt;cmin)          /* Was this a new minimum? */
          {                               /* if so...*/
             cmin=trial_cost;           /* reset cmin to new low...*/
             imin=i;
             assignd(D,best,tmp);           
          }                           
       }                            
       else
       {
          assignd(D,(*pnew)[i],(*pold)[i]); /* replace target with old value */
       }
    }
  
      }   /* End mutation loop through pop. */
  
      assignd(D,bestit,best);  /* Save best population member of current iteration */
  
      /* swap population arrays. New generation becomes old one */
  
      pswap = pold;
      pold  = pnew;
      pnew  = pswap;
  
/*----Compute the energy variance (just for monitoring purposes)-----------*/
  
      cmean = 0.;          /* compute the mean value first */
      for (j=0; j&lt;NP; j++)
      {
         cmean += cost[j];
      }
      cmean = cmean/NP;
  
      cvar = 0.;           /* now the variance              */
      for (j=0; j&lt;NP; j++)
      {
         cvar += (cost[j] - cmean)*(cost[j] - cmean);
      }
      cvar = cvar/(NP-1);
  
  
/*----Output part----------------------------------------------------------*/
  
      if (gen%refresh==1)   /* display after every refresh generations */
      { /* ABORT works only if conio.h is accepted by your compiler */
    printf("\n\n                         PRESS ANY KEY TO ABORT"); 
    printf("\n\n\n Best-so-far cost funct. value=%-15.10g\n",cmin);
  
    for (j=0;j&lt;D;j++)
    {
      printf("\n best[%d]=%-15.10g",j,best[j]);
    }
    printf("\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
    printf("\n NP=%d    F=%-4.2g    CR=%-4.2g   cost-variance=%-10.5g\n",
               NP,F,CR,cvar);
      }
  
      fprintf(fpout_ptr,"%ld   %-15.10g\n",nfeval,cmin);
   }
/*=======================================================================*/
/*=========End of iteration loop=========================================*/
/*=======================================================================*/
  
/*-------Final output in file-------------------------------------------*/
  
  
   fprintf(fpout_ptr,"\n\n\n Best-so-far obj. funct. value = %-15.10g\n",cmin);
  
   for (j=0;j&lt;D;j++)
   {
     fprintf(fpout_ptr,"\n best[%d]=%-15.10g",j,best[j]);
   }
   fprintf(fpout_ptr,"\n\n Generation=%d  NFEs=%ld   Strategy: %s    ",gen,nfeval,strat[strategy]);
   fprintf(fpout_ptr,"\n NP=%d    F=%-4.2g    CR=%-4.2g    cost-variance=%-10.5g\n",
           NP,F,CR,cvar); 
  
  fclose(fpout_ptr);
  
  /* Code you want timed here */
  printf("Time elapsed: %f\n", ((double)clock() - start) / CLOCKS_PER_SEC);
   return(0);
}
  
/*-----------End of main()------------------------------------------*/
  
// 適應函式 fittness function (cost function)
double evaluate(int D, double tmp[], long *nfeval)
{
   double result=0, surface = 80.0, z, volume, penality;
   (*nfeval)++;
   z = (surface-tmp[0]*tmp[1])/(2.0*(tmp[0]+tmp[1]));
   volume = tmp[0]*tmp[1]*z;
  
  if(volume &lt;= 0){
    return PENALITY;
  }
// 只限制長度與寬度必須大於 0
  if(tmp[0] &lt;= inibound_l){
    return PENALITY;
  }
  
  if(tmp[1] &lt;= inibound_l){
    return PENALITY;
  }
/*
  if((tmp[0] &lt;= inibound_l)|| (tmp[0] &gt;inibound_h)){
    return PENALITY;
  }
  
  if((tmp[1] &lt;= inibound_l) || (tmp[1] &gt;inibound_h)){
    return PENALITY;
  }
  */
  // volume must &gt;0 and max volume
  // 目前為最小化問題
   //return 1+1/(volume*volume);
  return volume;
}</pre>
<p><span>Python </span><a href="https://en.wikipedia.org/wiki/Differential_evolution">Differential Evolution</a><span><span> </span>algorithm:</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import random
 
class Chromosome(object):
 
    """
    just copy the idea of genetic algorithm, pretty similar..
    """
    def __init__(self, n):
        """
        int n, dimension of question
        """
        # dimension
        self.n = n
        # the gene
        self.v = [0] * n
        # the fitness value
        self.f = 0
 
    def assign(self, obj):
        """
        Chromosome obj
 
        copy all attribute from obj to itself
        """
        self.n = obj.n
        self.v = obj.v[:]
        self.f = obj.f
 
 
class DiffertialEvolution(object):
 
    def __init__(self,Func, pType, strategy, D, NP, F, CR, lower, upper, maxGen, report):
        # if pType = 1 it is maximization  otherwise is minimization problem
        self.pType = pType
        # strategy 1~10, choice what strategy to generate new member in temporary
        self.strategy = strategy
        # dimesion of quesiton
        self.D = D
        # population size
        # To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence
        self.NP = NP
        # weight factor
        # F is usually between 0.5 and 1 (in rare cases &gt; 1)
        self.F = F
        # crossover possible
        # CR in [0,1]
        self.CR = CR
        # lower bound array
        self.lb = lower[:]
        # upper bound array
        self.ub = upper[:]
        # maximum generation
        self.maxGen = maxGen
        # how many generation report once
        self.rpt = report
        # object function, or enviorment
        self.f = Func
        # check parameter is set properly
        self.checkParameter()
 
        # generation pool, depend on population size
        self.pop = [Chromosome(D) for i in range(NP)]
        # last generation best member
        self.lastgenbest = Chromosome(D)
        # current best member
        self.currentbest = Chromosome(D)
        # the generation count
        self.gen = 0
        # the vector
        self.r1 = 0
        self.r2 = 0
        self.r3 = 0
        self.r4 = 0
        self.r5 = 0
 
    def checkParameter(self):
        """
        check parameter is set properly
        """
        if (type(self.D) is not int) and self.D &lt;= 0:
            raise Exception('D shoud be integer and larger than 0')
        if (type(self.NP) is not int) and self.NP &lt;= 0:
            raise Exception('NP shoud be integer and larger than 0')
        if self.CR &lt; 0 or self.CR &gt; 1:
            raise Exception('CR should be [0,1]')
        if self.maxGen &lt;= 0:
            raise Exception('generation should larger than 0')
        if self.rpt &lt;= 0 or self.rpt &gt; self.maxGen:
            raise Exception('report should be larger than 0 and less than max genration')
        if self.strategy &lt; 1 or self.strategy &gt; 10:
            raise Exception('strategy should be [1,10]')
        for lower, upper in zip(self.lb, self.ub):
            if lower &gt; upper:
                raise Exception('upper bound should be larger than lower bound')
 
    def init(self):
        """
        init population
        """
        for i in range(self.NP):
            for j in range(self.D):
                self.pop[i].v[j] = self.lb[j] + random.random()*(self.ub[j] - self.lb[j])
            self.pop[i].f = self.evalute(self.pop[i])
 
    def evalute(self, p):
        """
        evalute the member in enviorment
        """
        return self.f(p.v)
 
    def findBest(self):
        """
        find member that have minimum fitness value from pool
        """
        if self.pType == 1:
            return max(self.pop, key=lambda chrom:chrom.f)
        else:
            return min(self.pop, key=lambda chrom:chrom.f)
 
    def generateRandomVector(self, i):
        """
        generate new vector
        """
        while True:
            self.r1 = int(random.random() * self.NP)
            if not (self.r1 == i):
                break
 
        while True:
            self.r2 = int(random.random() * self.NP)
            if not ((self.r2 == i) or (self.r2 == self.r1)):
                break
 
        while True:
            self.r3 = int(random.random() * self.NP)
            if not ((self.r3 == i) or (self.r3 == self.r1) or (self.r3 == self.r2)):
                break
 
        while True:
            self.r4 = int(random.random() * self.NP)
            if not ((self.r4 == i) or (self.r4 == self.r1) or (self.r4 == self.r2) or (self.r4 == self.r3)):
                break
 
        while True:
            self.r5 = int(random.random() * self.NP)
            if not ((self.r5 == i) or (self.r5 == self.r1) or (self.r5 == self.r2) or (self.r5 == self.r3) or (self.r5 == self.r4)):
                break
 
    def recombination(self, i):
        """
        use new vector, recombination the new one member to tmp
        """
        tmp = Chromosome(self.D)
 
        if self.strategy == 1:
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            L = 0
            while True:
                tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
                n = (n + 1) % self.D
                L += 1
                if not ((random.random() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif self.strategy == 2:
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            L = 0
            while True:
                tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
                n = (n + 1) % self.D
                L += 1
                if not ((random.random() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 3):
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            L = 0
            while True:
                tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])
                n = (n + 1) % self.D
                L += 1
                if not ((random.random() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 4):
            tmp.assign(self.pop[i])
 
            n = int(random.random() * self.D)
 
            L = 0
            while True:
                tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
                n = (n + 1) % self.D
                L += 1
                if not ((random.random() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 5):
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            L = 0
            while True:
                tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
                n = (n + 1) % self.D
                L += 1
                if not ((random.random() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 6):
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            for L in range(self.D):
                if ((random.random() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
                n = (n + 1) % self.D
 
        elif (self.strategy == 7):
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            for L in range(self.D):
                if ((random.random() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
 
                n = (n + 1) % self.D
 
        elif (self.strategy == 8):
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            for L in range(self.D):
                if ((random.random() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])
 
                n = (n + 1) % self.D
 
        elif (self.strategy == 9):
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            for L in range(self.D):
                if ((random.random() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
 
                n = (n + 1) % self.D
 
        else:
            tmp.assign(self.pop[i])
            n = int(random.random() * self.D)
            for L in range(self.D):
                if ((random.random() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
                n = (n + 1) % self.D
        return tmp
 
    def report(self):
        """
        report current generation status
        """
        if self.gen == 0:
            print("DiffertialEvolution results - init pop")
        elif self.gen == self.maxGen:
            print("Final DiffertialEvolution results at", self.gen, "generations")
        else:
            print("DiffertialEvolution results after", self.gen, "generations")
        print("Function : %.6f" % (self.currentbest.f))
        for i, v in enumerate(self.currentbest.v, start=1):
            print("Var", i, ":", v)
 
    def overbound(self, member):
        """
        check the member's chromosome that is out of bound?
        """
        for i in range(self.D):
            if member.v[i] &gt; self.ub[i] or member.v[i] &lt; self.lb[i]:
                return True
        return False
 
    def run(self):
        """
        run the algorithm...
        """
        # initial step
        # generation 0
        self.gen = 0
        # init the member's chromsome
        self.init()
        # find the best one(smallest fitness value)
        tmp = self.findBest()
        # copy to lastgenbest
        self.lastgenbest.assign(tmp)
        # copy to currentbest
        self.currentbest.assign(tmp)
        # report status
        self.report()
        # end initial step
 
        # the evolution journey is beggin...
        for self.gen in range(1, self.maxGen + 1):
            for i in range(self.NP):
                # generate new vector
                self.generateRandomVector(i)
                # use the vector recombine the member to temporary
                tmp = self.recombination(i)
                # check the one is out of bound?
                if self.overbound(tmp):
                    # if it is, then ignore
                    continue
                # is not out of bound, that mean it's quilify of enviorment
                # then evalute the one
                tmp.f = self.evalute(tmp)
                # if temporary one is better than origin(fitness value is larger or smaller)
                # pType is 1, the problem is maximization type
                if self.pType == 1:
                    if tmp.f &gt;= self.pop[i].f:
                        # copy the temporary one to origin member
                        self.pop[i].assign(tmp)
                        # check the temporary one is better than the currentbest
                        if tmp.f &gt; self.currentbest.f:
                            # copy the temporary one to currentbest
                            self.currentbest.assign(tmp)
                else:
                    if tmp.f &lt;= self.pop[i].f:
                        # copy the temporary one to origin member
                        self.pop[i].assign(tmp)
                        # check the temporary one is better than the currentbest
                        if tmp.f &lt; self.currentbest.f:
                            # copy the temporary one to currentbest
                            self.currentbest.assign(tmp)
            # copy the currentbest to lastgenbest
            self.lastgenbest.assign(self.currentbest)
            # if report generation is set, report
            if self.rpt != 0:
                if self.gen % self.rpt == 0:
                    self.report()
        # the evolution journey is done, report the final status
        self.report()
 
#fittness function (cost function)
def evaluate(designVariablel):
    surface = 80.0
    # if pType is 1, the penality is negative (maximization problem)
    # if pType is 0, the penality is positive (minimization problem)
    penality = -1000
 
    z = (surface-designVariablel[0]*designVariablel[1])/(2.0*(designVariablel[0]\
         +designVariablel[1]))
    volume = designVariablel[0]*designVariablel[1]*z
   
    if(volume &lt;= 0):
        return penality
 
    # box length and width need to be larger than 0
    if(designVariablel[0] &lt;= 0):
        return penality
 
    if(designVariablel[1] &lt;= 0):
        return penality
    return volume
#volume = DiffertialEvolution((self,Func, max, strategy, D, NP, F, CR, lower, upper, maxGen, report)
volume = DiffertialEvolution(evaluate, 1, 3, 2, 100, 0.6, 0.85, [0, 0], [50, 50], 100, 10)
volume.run()</pre>
<p><span>為了提升運算速度, 將上述 Python 程式轉為 <a href="https://cython.org/">Cython</a> 格式:</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#import random
from cpython cimport bool
#from array import array
import numpy as np
cimport numpy as np
from libc.stdlib cimport rand, RAND_MAX, srand
from libc.time cimport time
 
# make true it is random everytime
srand(time(NULL))
 
cdef double randV():
    return rand()*1.0 / RAND_MAX
 
cdef class Chromosome(object):
    """
    just copy the idea of genetic algorithm, pretty similar..
    """
    cdef public int n
    cdef public double f
    cdef public np.ndarray v
 
    def __cinit__(self, int n):
        """
        int n, dimension of question
        """
        # dimension
        self.n = n
        # the gene
        self.v = np.zeros(n)
        # the fitness value
        self.f = 0
 
    def assign(self, Chromosome obj):
        """
        Chromosome obj
        copy all attribute from obj to itself
        """
        self.n = obj.n
        self.v[:] = obj.v
        self.f = obj.f
 
 
cdef class DiffertialEvolution(object):
 
    cdef:
        int strategy, D, NP, maxGen, rpt, gen, r1, r2, r3, r4, r5
        double F, CR
        np.ndarray lb, ub, pop
        object f
        Chromosome lastgenbest, currentbest
 
    def __cinit__(self, object Func, int strategy, int D, int NP, double F, double CR, object lower, object upper, int maxGen, int report):
        # strategy 1~10, choice what strategy to generate new member in temporary
        self.strategy = strategy
        # dimesion of quesiton
        self.D = D
        # population size
        # To start off NP = 10*D is a reasonable choice. Increase NP if misconvergence
        self.NP = NP
        # weight factor
        # F is usually between 0.5 and 1 (in rare cases &gt; 1)
        self.F = F
        # crossover possible
        # CR in [0,1]
        self.CR = CR
        # low bound
        self.lb = np.array(lower[:])
        # up bound
        self.ub = np.array(upper[:])
        # maximum generation
        self.maxGen = maxGen
        # how many generation report once
        self.rpt = report
        # object function, or enviorment
        self.f = Func
        # check parameter is set properly
        self.checkParameter()
 
        # generation pool, depend on population size
        #self.pop = [Chromosome(self.D) for i in range(self.NP)]
        self.pop = np.ndarray((NP,),dtype=np.object)
        for i in range(NP):
            self.pop[i] = Chromosome(self.D)
        # last generation best member
        self.lastgenbest = Chromosome(D)
        # current best member
        self.currentbest = Chromosome(D)
        # the generation count
        self.gen = 0
        # the vector
        self.r1 = 0
        self.r2 = 0
        self.r3 = 0
        self.r4 = 0
        self.r5 = 0
 
    cdef void checkParameter(self):
        """
        check parameter is set properly
        """
        if (type(self.D) is not int) and self.D &lt;= 0:
            raise Exception('D shoud be integer and larger than 0')
        if (type(self.NP) is not int) and self.NP &lt;= 0:
            raise Exception('NP shoud be integer and larger than 0')
        if self.CR &lt; 0 or self.CR &gt; 1:
            raise Exception('CR should be [0,1]')
        if self.maxGen &lt;= 0:
            raise Exception('generation should larger than 0')
        if self.rpt &lt;= 0 or self.rpt &gt; self.maxGen:
            raise Exception('report should be larger than 0 and less than max genration')
        if self.strategy &lt; 1 or self.strategy &gt; 10:
            raise Exception('strategy should be [1,10]')
        for lower, upper in zip(self.lb, self.ub):
            if lower &gt; upper:
                raise Exception('upper bound should be larger than lower bound')
 
    cdef void init(self):
        """
        init population
        """
        cdef int i, j
 
        for i in range(self.NP):
            for j in range(self.D):
                self.pop[i].v[j] = self.lb[j] + randV()*(self.ub[j] - self.lb[j])
            self.pop[i].f = self.evalute(self.pop[i])
 
    cdef double evalute(self, Chromosome member):
        """
        evalute the member in enviorment
        """
        return self.f(member.v)
 
    cdef Chromosome findBest(self):
        """
        find member that have minimum fitness value from pool
        """
        return min(self.pop, key=lambda chrom:chrom.f)
 
    cdef void generateRandomVector(self, i):
        """
        generate new vector
        """
        while True:
            self.r1 = int(randV() * self.NP)
            if not (self.r1 == i):
                break
 
        while True:
            self.r2 = int(randV() * self.NP)
            if not ((self.r2 == i) or (self.r2 == self.r1)):
                break
 
        while True:
            self.r3 = int(randV() * self.NP)
            if not ((self.r3 == i) or (self.r3 == self.r1) or (self.r3 == self.r2)):
                break
 
        while True:
            self.r4 = int(randV() * self.NP)
            if not ((self.r4 == i) or (self.r4 == self.r1) or (self.r4 == self.r2) or (self.r4 == self.r3)):
                break
 
        while True:
            self.r5 = int(randV() * self.NP)
            if not ((self.r5 == i) or (self.r5 == self.r1) or (self.r5 == self.r2) or (self.r5 == self.r3) or (self.r5 == self.r4)):
                break
 
    cdef Chromosome recombination(self, int i):
        """
        use new vector, recombination the new one member to tmp
        """
        cdef Chromosome tmp
        cdef int n, L
 
        tmp = Chromosome(self.D)
 
        if self.strategy == 1:
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            L = 0
            while True:
                tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
                n = (n + 1) % self.D
                L += 1
                if not ((randV() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif self.strategy == 2:
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            L = 0
            while True:
                tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
                n = (n + 1) % self.D
                L += 1
                if not ((randV() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 3):
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            L = 0
            while True:
                tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])
                n = (n + 1) % self.D
                L += 1
                if not ((randV() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 4):
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            L = 0
            while True:
                tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
                n = (n + 1) % self.D
                L += 1
                if not ((randV() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 5):
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            L = 0
            while True:
                tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
                n = (n + 1) % self.D
                L += 1
                if not ((randV() &lt; self.CR) and (L &lt; self.D)):
                    break
 
        elif (self.strategy == 6):
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            for L in range(self.D):
                if ((randV() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.lastgenbest.v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
                n = (n + 1) % self.D
 
        elif (self.strategy == 7):
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            for L in range(self.D):
                if ((randV() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.pop[self.r1].v[n] + self.F*(self.pop[self.r2].v[n] - self.pop[self.r3].v[n])
                n = (n + 1) % self.D
 
        elif (self.strategy == 8):
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            for L in range(self.D):
                if ((randV() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = tmp.v[n] + self.F*(self.lastgenbest.v[n] - tmp.v[n]) + self.F*(self.pop[self.r1].v[n] - self.pop[self.r2].v[n])
                n = (n + 1) % self.D
 
        elif (self.strategy == 9):
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            for L in range(self.D):
                if ((randV() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.lastgenbest.v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
                n = (n + 1) % self.D
 
        else:
            tmp.assign(self.pop[i])
            n = int(randV() * self.D)
            for L in range(self.D):
                if ((randV() &lt; self.CR) or L == (self.D - 1)):
                    tmp.v[n] = self.pop[self.r5].v[n] + (self.pop[self.r1].v[n] + self.pop[self.r2].v[n] - self.pop[self.r3].v[n] - self.pop[self.r4].v[n]) * self.F
                n = (n + 1) % self.D
        return tmp
 
    cdef void report(self):
        """
        report current generation status
        """
        cdef int i
        cdef double v
 
        if self.gen == 0:
            print("DiffertialEvolution results - init pop")
        elif self.gen == self.maxGen:
            print("Final DiffertialEvolution results at %d generations"%(self.gen,))
        else:
            print("DiffertialEvolution results after %d generations"%(self.gen,))
        print("Function : %.6f" % (self.currentbest.f))
        for i, v in enumerate(self.currentbest.v.flat, start=1):
            print("Var %d : %.4f"%(i, v))
 
    cdef bool overbound(self, Chromosome member):
        """
        check the member's chromosome that is out of bound?
        """
        cdef int i
 
        for i in range(self.D):
            if member.v[i] &gt; self.ub[i] or member.v[i] &lt; self.lb[i]:
                return True
        return False
 
    cdef void run(self):
        """
        run the algorithm...
        """
        cdef Chromosome tmp
        cdef int i
 
        # initial step
        # generation 0
        self.gen = 0
        # init the member's chromsome
        self.init()
        # find the best one(smallest fitness value)
        tmp = self.findBest()
        # copy to lastgenbest
        self.lastgenbest.assign(tmp)
        # copy to currentbest
        self.currentbest.assign(tmp)
        # report status
        self.report()
        # end initial step
 
        # the evolution journey is beggin...
        for self.gen in range(1, self.maxGen + 1):
            for i in range(self.NP):
                # generate new vector
                self.generateRandomVector(i)
                # use the vector recombine the member to temporary
                tmp = self.recombination(i)
                # check the one is out of bound?
                if self.overbound(tmp):
                    # if it is, then abandon it
                    continue
                # is not out of bound, that mean it's quilify of enviorment
                # then evalute the one
                tmp.f = self.evalute(tmp)
                # if temporary one is better than origin(fitness value is smaller)
                if tmp.f &lt;= self.pop[i].f:
                    # copy the temporary one to origin member
                    self.pop[i].assign(tmp)
                    # check the temporary one is better than the currentbest
                    if tmp.f &lt; self.currentbest.f:
                        # copy the temporary one to currentbest
                        self.currentbest.assign(tmp)
            # copy the currentbest to lastgenbest
            self.lastgenbest.assign(self.currentbest)
            # if report generation is set, report
            if self.rpt != 0:
                if self.gen % self.rpt == 0:
                    self.report()
        # the evolution journey is done, report the final status
        self.report()</pre>
<p><span>使用 Real-coded Genetic algorithm 解題:</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import time
import math
 
 
class Chromosome(object):
 
    def __init__(self, n=None):
        self.np = n if n &gt; 0 else 2
        self.f = 0.0
        self.v = [0.0] * n
 
    def cp(self, obj):
        """
        copy all atribute from another chromsome object
        """
        self.np = obj.np
        self.f = obj.f
        self.v = obj.v[:]
 
    def get_v(self, i):
        return self.v[i]
 
    def is_self(self, obj):
        """
        check the object is self?
        """
        return obj is self
 
    def assign(self, obj):
        if not self.is_self(obj):
            self.cp(obj)
 
 
class Genetic(object):
 
    def __init__(self, func, pType, nParm, nPop, pCross, pMute, pWin, bDelta, upper, lower):
        """
        init(function func)
        """
        self.func=func
        self.pType = pType
        self.nParm=nParm
        self.nPop=nPop
        self.pCross=pCross
        self.pMute=pMute
        self.pWin=pWin
        self.bDelta=bDelta
 
        self.chrom = [Chromosome(nParm) for i in range(nPop)]
        self.newChrom = [Chromosome(nParm) for i in range(nPop)]
        self.babyChrom = [Chromosome(nParm) for i in range(3)]
        self.chromElite = [Chromosome(nParm)]
        self.chromBest = [Chromosome(nParm)]
        self.maxLimit = upper[:]
        self.minLimit = lower[:]
 
        self.maxGen = None
        self.gen = None
 
        self.seed = 0.0
        self.iseed = 470211272.0
        self.mask = 2147483647
 
    def check(self, i, v):
        """
        If a variable is out of bound,
        replace it with a random value
        """
        if (v &gt; self.maxLimit[i]) or (v &lt; self.minLimit[i]):
            return self.randVal(self.minLimit[i], self.maxLimit[i])
        return v
 
    def crossOver(self):
        for i in range(0, self.nPop-1, 2):
            # crossover
            if(self.rnd() &lt; self.pCross):
                for s in range(self.nParm):
                    # first baby, half father half mother
                    self.babyChrom[0].v[s] = 0.5 * self.chrom[i].v[s] + 0.5*self.chrom[i+1].v[s];
                    # second baby, three quaters of fater and quater of mother
                    self.babyChrom[1].v[s] = self.check(s, 1.5 * self.chrom[i].v[s] - 0.5*self.chrom[i+1].v[s])
                    # third baby, quater of fater and three quaters of mother
                    self.babyChrom[2].v[s] = self.check(s,-0.5 * self.chrom[i].v[s] + 1.5*self.chrom[i+1].v[s]);
 
                for j in range(3):
                    self.babyChrom[j].f = self.func(self.babyChrom[j].v)
                # maximization
                if self.pType == 1:
                     
                    if self.babyChrom[1].f &gt; self.babyChrom[0].f:
                        self.babyChrom[0], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[0]
 
                    if self.babyChrom[2].f &gt; self.babyChrom[0].f:
                        self.babyChrom[2], self.babyChrom[0] = self.babyChrom[0], self.babyChrom[2]
 
                    if self.babyChrom[2].f &gt; self.babyChrom[1].f:
                        self.babyChrom[2], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[2]
 
                else:
                     
                    if self.babyChrom[1].f &lt; self.babyChrom[0].f:
                        self.babyChrom[0], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[0]
 
                    if self.babyChrom[2].f &lt; self.babyChrom[0].f:
                        self.babyChrom[2], self.babyChrom[0] = self.babyChrom[0], self.babyChrom[2]
 
                    if self.babyChrom[2].f &lt; self.babyChrom[1].f:
                        self.babyChrom[2], self.babyChrom[1] = self.babyChrom[1], self.babyChrom[2]
 
                # replace first two baby to parent, another one will be
                self.chrom[i].assign(self.babyChrom[0])
                self.chrom[i+1].assign(self.babyChrom[1])
 
    def delta(self, y):
        r = float(self.gen) / self.maxGen;
        return y*self.rnd()*math.pow(1.0-r, self.bDelta)
 
    def fitness(self):
        for j in range(self.nPop):
            self.chrom[j].f = self.func(self.chrom[j].v)
 
        self.chromBest[0].assign(self.chrom[0])
 
        for j in range(self.nPop):
            if self.pType == 1:
                if(self.chrom[j].f &gt; self.chromBest[0].f):
                    self.chromBest[0].assign(self.chrom[j])
            else:
                if(self.chrom[j].f &lt; self.chromBest[0].f):
                    self.chromBest[0].assign(self.chrom[j])
        if self.pType == 1:
            if(self.chromBest[0].f &gt; self.chromElite[0].f):
                self.chromElite[0].assign(self.chromBest[0])
        else:
            if(self.chromBest[0].f &lt; self.chromElite[0].f):
                self.chromElite[0].assign(self.chromBest[0])
 
    def initialPop(self):
        for j in range(self.nPop):
            for i in range(self.nParm):
                self.chrom[j].v[i] = self.randVal(self.minLimit[i], self.maxLimit[i])
 
    def mutate(self):
        for i in range(self.nPop):
            if self.rnd() &lt; self.pMute:
                s = self.random(self.nParm)
                if (self.random(2) == 0):
                    self.chrom[i].v[s] += self.delta(self.maxLimit[s]-self.chrom[i].v[s])
                else:
                    self.chrom[i].v[s] -= self.delta(self.chrom[i].v[s]-self.minLimit[s])
 
    def report(self):
        if self.gen == 0:
            print("Genetik results - Initial population")
        elif self.gen == self.maxGen:
            print("Final Genetik results at", self.gen, "generations")
        else:
            print("Genetik results after", self.gen, "generations")
 
        print("Function : %.6f" % (self.chromElite[0].f))
        for i, p in enumerate(self.chromElite[0].v):
            print("Var", i+1, ":", p)
 
    def select(self):
        """
        roulette wheel selection
        """
        for i in range(self.nPop):
            j = self.random(self.nPop)
            k = self.random(self.nPop)
            self.newChrom[i].assign(self.chrom[j])
            if self.pType == 1:
                if(self.chrom[k].f &gt; self.chrom[j].f) and (self.rnd() &gt; self.pWin):
                    self.newChrom[i].assign(self.chrom[k])
            else:
                if(self.chrom[k].f &lt; self.chrom[j].f) and (self.rnd() &lt; self.pWin):
                    self.newChrom[i].assign(self.chrom[k])
        # in this stage, newChrom is select finish
        # now replace origin chrom
        for i in range(self.nPop):
            self.chrom[i].assign(self.newChrom[i])
 
        # select random one chrom to be best chrom, make best chrom still exist
        j = self.random(self.nPop);
        self.chrom[j].assign(self.chromElite[0])
 
    def run(self, mxg, rp):
        """
        // **** Init and run GA for maxGen times
        // **** mxg : maximum generation
        // **** rp  : report cycle, 0 for final report or
        // ****       report each mxg modulo rp
        """
        self.maxGen = mxg
        self.rpt = rp
 
        self.randomize()
        self.initialPop()
        self.chrom[0].f = self.func(self.chrom[0].v)
        self.chromElite[0].assign(self.chrom[0])
 
        self.gen = 0
        self.fitness()
        self.report()
 
        for self.gen in range(1, self.maxGen + 1):
            self.select()
            self.crossOver()
            self.mutate()
            self.fitness()
            if rp != 0:
                if self.gen % self.rpt == 0:
                    self.report()
        self.report()
 
    def newSeed(self):
        if(self.seed == 0.0):
            self.seed=self.iseed
        else:
            self.seed *= 16807.0
            self.seed = math.fmod(self.seed, self.mask)
 
    def rnd(self):
        self.newSeed()
        return self.seed/self.mask
 
    def randomize(self):
        self.seed = time.time()
 
    def random(self, k):
        return int(self.rnd()*k)
 
    def randVal(self, low, high):
        number_types = (int, float)
        if isinstance(low, number_types) and isinstance(high, number_types):
            return self.rnd()*(high-low)+low
        raise ValueError
         
#fittness function (cost function)
def evaluate(designVariablel):
    surface = 80.0
    # if pType is 1, the penality is negative (maximization problem)
    # if pType is 0, the penality is positive (minimization problem)
    penality = -1000
 
    z = (surface-designVariablel[0]*designVariablel[1])/(2.0*(designVariablel[0]\
         +designVariablel[1]))
    volume = designVariablel[0]*designVariablel[1]*z
   
    if(volume &lt;= 0):
        return penality
 
    # box length and width need to be larger than 0
    if(designVariablel[0] &lt;= 0):
        return penality
 
    if(designVariablel[1] &lt;= 0):
        return penality
    #return 1+1/(volume*volume)
    return volume
 
#volume = Genetic(self, func, pType, nParm, nPop, pCross, pMute, pWin, bDelta, upper, lower):
volume = Genetic(evaluate, 1, 2, 1000, 0.95, 0.05, 0.95, 5, [0, 0], [50, 50])
volume.run(1000, 50)</pre>
<p></p>
<h3>Cloud MCAD</h3>
<p><a href="http://mde.tw/cadp2018/content/%E9%9B%B2%E7%AB%AF%20CAD.html">http://mde.tw/cadp2018/content/%E9%9B%B2%E7%AB%AF%20CAD.html</a></p>
<h4>University</h4>
<p><a href="http://mde.tw/cadp2018/content/%E5%A4%A7%E5%AD%B8.html">http://mde.tw/cadp2018/content/%E5%A4%A7%E5%AD%B8.html</a></p>
<h3>Generative Design</h3>
<p><a href="/downloads/Solving Engineering Design Problems through a Combination of Generative Grammars and Simulations.pdf">Solving Engineering Design Problems through a Combination of Generative Grammars and Simulations.pdf</a></p>
<p><a href="/downloads/Generative Programming.pdf">Generative Programming.pdf</a></p>
<p><a href="/downloads/generative representations for evoluationary design automation.pdf">generative representations for evoluationary design automation.pdf</a></p>
<p></p>
<h1>CMS</h1>
<p>請注意: 由於自 <a href="https://github.com/mdecourse/cmsimde/blob/5acf7403a8e4615edc93711dcb17a5a56438e0bc/flaskapp.py">https://github.com/mdecourse/cmsimde/blob/5acf7403a8e4615edc93711dcb17a5a56438e0bc/flaskapp.py</a> 版本開始, 納入 flask_cors, 因此先前所下載的可攜程式系統需要安裝 flask_cors, 否則無法啟動 CMSiMDE.</p>
<p>安裝 flask_cors</p>
<p style="padding-left: 30px;">python -m pip install flask_cors</p>
<p><a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443 就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容.</p>
<p>cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版.</p>
<p>init.py 位於  up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.</p>
<h4>利用 cmsimde 建立靜態網誌方法:</h4>
<p>1. 在 github 建立倉儲, git clone 到近端</p>
<p>2. 參考 <a href="https://github.com/mdecourse/newcms">https://github.com/mdecourse/newcms</a>, 加入除了 cmsimde 目錄外的所有內容</p>
<p>以 git submodule add <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> cmsimde</p>
<p>建立 cmsimde 目錄, 並從 github 取下子模組內容.</p>
<p>3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器.</p>
<p>動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端.</p>
<p>4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行:</p>
<p>git clone --recurse-submodules <a href="https://github.com/mdecourse/newcms.git">https://github.com/mdecourse/newcms.git</a></p>
<h2>CMSiMDE</h2>
<p><a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 是一套以 Python 加上 flask, bs4, lxml, mardown, pelican, flask_cors, leo 等模組所建構的網際內容管理系統.</p>
<p>flask 模組是一套網際程式框架, CMSiMDE 利用此一框架編寫網際相關的函式, 用來執行動態的內容管理系統.</p>
<p>bs4 在 CMSiMDE 擔任解析 config/content.htm 超文件檔案的工作, 根據 h1, h2 與 h3 標註, 對 content.htm 進行分頁, 因此使用者可以透過 3 個階次的內容架構進行編輯.</p>
<p>lxml 模組主要用來將 content.htm 逐一轉換為 content 目錄中的個別檔案, 也就是在 CMSiMDE 動態系統中, 點擊 generate_pages 之後, 呼叫 lxml 模組中的分頁方法, 將動態內容轉為靜態內容.</p>
<p>markdown 與 pelican 在 CMSiMDE 主要用來產生靜態網誌, 而網誌的設計與編輯則透過 Leo Editor 進行, 此外 CMSiMDE 除了網際內容管理與網誌之外, 還透過 Leo Editor 管理 reveal.js 網際簡報系統.</p>
<p>flask_cors 模組, 在 CMSiMDE 是為了配合 Dartpad 程式編寫過程, 需要跨網站擷取資料的需求而加入, 在舊版的可攜系統中若無此模組, 執行 CMSiMDE 之前必須透過</p>
<p style="padding-left: 30px;">python -m pip install flask_cors </p>
<p>安裝.</p><h2>STL</h2>
<p>CMSiMDE 引用 ASCII STL方法:</p>
<p>將 ascii.stl 檔案上傳至 downloads 目錄後, 利用 File List 功能, 後列出 ascii.stl, 以滑鼠點擊會出現顯示 stl 檔案的頁面, 導入頁面時, 以 iframe 標註之 src 對應至顯示 stl 檔案的 html 連結即可, 例如:  &lt;iframe width="600" height="400" src="/static/viewstl.html?src=./../../downloads/spikeball.stl"&gt;&lt;/iframe&gt;</p>
<p><iframe height="400" src="/static/viewstl.html?src=./../../downloads/spikeball.stl" width="600"></iframe></p>
<p>將 Solvespace 轉出的 Binary STL 零組件轉為 ASCII STL 程式碼:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import struct
normals = []
points = []
triangles = []
triangle_number = 0
def load_binary_stl(fp):
    '''
    二位元 STL 檔案格式如下:
    檔案標頭共有 80 個字元(bytes), 內容通常省略, 但是內容不可使用 solid, 以免與文字檔案 STL 混淆
    UINT8[80] – Header
    UINT32 – Number of triangles (I:佔 4 bytes 的 unsigned integer)
  
    foreach triangle
    REAL32[3] – Normal vector (f:每一座標分量為一佔 4 bytes 的 float, 共佔 12 bytes)
    REAL32[3] – Vertex 1
    REAL32[3] – Vertex 2
    REAL32[3] – Vertex 3
    UINT16 – Attribute byte count (H:兩個 bytes 的 unsigned short, 表示 attribute byte count)
    end
  
    '''
    # 已經在外部開檔
    #fp=open(filename,'rb')
    header=fp.read(80)
    triangle_number = struct.unpack('I',fp.read(4))[0]
    #print(triangle_number)
    count=0
    while True:
        try:
            p=fp.read(12)
            if len(p)==12:
                n=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                normals.append(n)
                l = len(points)
                #print(n)
            p=fp.read(12)
            if len(p)==12:
                p1=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                points.append(p1)
                #print(p1)
            p=fp.read(12)
            if len(p)==12:
                p2=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                points.append(p2)
            p=fp.read(12)
            if len(p)==12:
                p3=[struct.unpack('f',p[0:4])[0],struct.unpack('f',p[4:8])[0],struct.unpack('f',p[8:12])[0]]
                points.append(p3)
                triangles.append((l, l+1, l+2))
            # 使用 count 來計算三角形平面個數
            # triangle_number 為 STL 檔案中的三角形個數
            count += 1
            #print(count)
            # 在前面 12*4 個 bytes 的 normal 與三個點資料後, 為
            # 一個 2 bytes 長的 unsigned short, 其值為零, 為 attribute
            fp.read(2)
            # 讀完所有三角平面後, 即跳出 while
            if count &gt; triangle_number:
                break
        except EOFError:
            break
    #fp.close()
def read_length(f):
    length = struct.unpack("@i", f.read(4))
    return length[0]
def read_header(f):
    f.seek(f.tell()+80)
def write_as_ascii(outfilename):
    f = open(outfilename, "w")
    f.write ("solid "+outfilename+"\n")
    for n  in range(len(triangles)):
        f.write ("facet normal {} {} {}\n".format(normals[n][0],normals[n][1],normals[n][2]))
        f.write ("outer loop\n")
        f.write ("vertex {} {} {}\n".format(points[triangles[n][0]][0],points[triangles[n][0]][1],points[triangles[n][0]][2]))
        f.write ("vertex {} {} {}\n".format(points[triangles[n][1]][0],points[triangles[n][1]][1],points[triangles[n][1]][2]))
        f.write ("vertex {} {} {}\n".format(points[triangles[n][2]][0],points[triangles[n][2]][1],points[triangles[n][2]][2]))
        f.write ("endloop\n")
        f.write ("endfacet\n")
    f.write ("endsolid "+outfilename+"\n")
    f.close()
def main():
    infilename = "binary.stl"
    outfilename = "ascii.stl"
    try:
        f = open(infilename, "rb")
        #read_header(f)
        #l = read_length(f)
        try:
            load_binary_stl(f)
            l = len(normals)
        except Exception as e:
            print("Exception",e)
        print(len(normals), len(points), len(triangles), l)
        write_as_ascii(outfilename)
        print("done")
    except Exception as e:
        print(e)
if __name__ == '__main__':
    main()</pre>
<p></p><h1>Tools</h1>
<p>從未使用 Solidworks, Inventor 或 Solid Edge 等中端 MCAD 者:</p>
<p style="padding-left: 30px;">請<span>登入 @gm 電子郵箱, </span><a href="https://drive.google.com/file/d/1KPpXzumzBIvMCovZdBYh0s468uFO277k/view">下載 SolidWorks 2017 SP2 安裝光碟</a><span>, 或下載已經安裝好的<span> </span></span><a href="https://drive.google.com/file/d/1VB30WUbfKEH3BX3ftLlOWWZ_aQIZzZVx/view?usp=sharing">SolidWorks 2017 SP2 虛擬主機版本</a>, 從熟悉 Solidworks 參數繪圖與零組件設計操作開始. (參考資料: <a href="https://github.com/mdecourse/cad2019/tree/master/downloads">https://github.com/mdecourse/cad2019/tree/master/downloads</a>)</p>
<p>曾經使用過中端 MCAD 者:</p>
<p style="padding-left: 30px;">請<span>登入 @gm 電子郵箱, </span><a href="https://drive.google.com/file/d/1fEZtGVCXp2vtILUZZ8vTTdtYHsbBpf7j/view?usp=sharing">下載 NX 12.0.2 安裝光碟</a><span>, 或者</span><a href="https://drive.google.com/file/d/1UyDUGc2ytn-EVHCw-bNqanV6Jw11yvUg/view?usp=sharing">下載 NX12.0.2 虛擬主機板本</a><span>. 隨後的零組件設計繪圖可以使用 Solidworks, Inventor 或 NX. (參考資料: <a href="https://github.com/mdecourse/cad2019/tree/master/downloads">https://github.com/mdecourse/cad2019/tree/master/downloads</a><span>)</span></span></p>
<p><span>所有學員需要以學號建立 <a href="https://www.onshape.com/">Onshape</a> 帳號, 自行下載 <a href="https://github.com/solvespace/solvespace">Solvespace</a> 原始碼,  根據 <a href="http://mde.tw/cp2019">http://mde.tw/cp2019</a> 中有關編譯 Solvespace 的步驟說明, 完成 Solvespace 工具的編譯, 並學習如何利用 Solvespace 建立簡單的零組件. 並嘗試從 <a href="https://github.com/KmolYuan/solvespace">https://github.com/KmolYuan/solvespace</a> 中建立能讓 Python 3 程式呼叫的 Geometric Constraint Solver 動態連結程式庫, 以便利用程式方法進行平面機構設計.</span></p>
<p><span>所有學員都必須下載:</span></p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/file/d/13-ByKlFCsScF3xHi1SZrsJ1ZOejzFXZo/view?usp=sharing">FreeCAD 0.18.7z</a><span> </span>(登入 gm.nfu.edu.tw 後下載) - 電腦輔助設計實習課程專用</p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/file/d/1cZFSsLEoGOBYojzKzFEf4YH2l--pbS-9/view?usp=sharing">V-rep 3.6.1 rev 4.7z</a><span> </span>(登入 gm.nfu.edu.tw 後下載) - 電腦輔助設計實習課程專用</p>
<p style="padding-left: 30px;"><span><a href="https://drive.google.com/file/d/1o8cAv-pSUyp69TUGhC7NvEznGrdNP5AC/view?usp=sharing">Webot 2019a.7z</a><span> </span></span><span>(登入 gm.nfu.edu.tw 後下載) - 電腦輔助設計實習課程專用</span></p>
<p style="padding-left: 30px;"><span>並在各分組中探討這些工具能夠用來解決電腦輔助機械設計流程中的那些問題?</span></p>
<p><br/><span></span></p><h2>FFmpeg</h2>
<p>FFmpeg 手冊: <a href="http://ffmpeg.org/ffmpeg.html">http://ffmpeg.org/ffmpeg.html</a></p>
<h4>擷取 mp4 片段檔案</h4>
<p>從 origin.mp4 影片中的第一秒開始, 切出 15 分鐘的影片, 存為 new.mp4</p>
<p style="padding-left: 30px;">ffmpeg -i origin.mp4 -ss 00:00:01 -t 00:15:00 -async 1 new.mp4</p>
<h4>刪除影片中的聲音資料</h4>
<p style="padding-left: 30px;">ffmpeg -i origin.mp4 -c copy -an new.mp4</p>
<p>合併 mp4 檔案</p>
<p>建立 allmp4.txt 內容為<br/>file '/path/to/1.mp4'<br/>file '/path/to/2.mp4'<br/>file '/path/to/3.mp4'</p>
<p>將 1.mp4, 2.mp4 與 3.mp4 合併為 new.mp4</p>
<p style="padding-left: 30px;">ffmpeg -f concat -i allmp4.txt -c copy new.mp4</p>
<h4>影片中加入字幕</h4>
<p>利用 <a href="http://www.aegisub.org/">http://www.aegisub.org/</a> 可攜版本工具加入字幕</p>
<p>直接將 input.srt 字幕資料 burn 入 input.mp4</p>
<p style="padding-left: 30px;">ffmpeg -i input.mp4 -vf subtitles=input.srt output.mp4</p>
<h4>影片畫面中座標 x=5, y=950 位置中加入圖檔</h4>
<h4 style="padding-left: 30px;"><img alt="" height="30" src="/images/kmol_102x30_color.png" width="102"/></h4>
<p style="padding-left: 30px;">ffmpeg -i input.mp4 -i kmol_102x30_color.png -filter_complex "overlay=5:950" output.mp4</p>
<h4>其他圖形化工具:</h4>
<p style="padding-left: 30px;"><a href="http://www.aegisub.org/">http://www.aegisub.org/</a> (Font: SimSun, Size: 40, Bold, Primary, Color (255, 200, 5))</p>
<p style="padding-left: 30px;"><a href="http://www.avidemux.org/nightly/win64_support/">http://www.avidemux.org/nightly/win64_support/</a> (建立使用 2.6.21 版本, 可與 aegisub 配合使用)</p>
<p style="padding-left: 30px;"><a href="https://www.openshot.org/">https://www.openshot.org/</a> (必須分段輸入字幕, 無法與 aegisub 配合使用)</p>
<p>請登入 @gm 電子郵箱後, 下載 <a href="https://drive.google.com/file/d/1UdEVnmursZFgWrYTY1CqDOWSjt7nr84N/view?usp=sharing">aegisub_avidemux_openshot.7z</a></p>
<p style="padding-left: 30px;"></p>
<p></p><h2>GUI</h2>
<p><a href="https://github.com/TransmissionZero/MinGW-Win32-Application">https://github.com/TransmissionZero/MinGW-Win32-Application</a></p>
<p><a href="http://cq.cx/index.pl">http://cq.cx/index.pl</a> (for @gm user - <a href="https://drive.google.com/file/d/1awO1X82iflWodJ0ULUIm6Z71AxWkUiuR/view?usp=sharing">sketchflat_project.7z</a>)</p>
<p><a href="https://github.com/LDmicro/LDmicro">https://github.com/LDmicro/LDmicro</a></p><h2>Solvespace</h2>
<p><a href="http://solvespace.com/">http://solvespace.com</a></p>
<p><a href="https://github.com/solvespace/solvespace">https://github.com/solvespace/solvespace</a> </p>
<p><a href="https://www.youtube.com/channel/UCPwwPIXHMZYcVyJ2SuRJjuA/videos">https://www.youtube.com/channel/UCPwwPIXHMZYcVyJ2SuRJjuA/videos</a></p>
<h4>編譯步驟:</h4>
<p>先將 Y:\portablegit\bin\sh.exe 改名為 sh_rename_for_solvespace.exe</p>
<p>git version 查驗 git 版本</p>
<p>git 2.13 版本以上, 可以使用下列 git clone <span>--recurse-submodules 取得所有子模組資料</span></p>
<p style="padding-left: 30px;">git clone --recurse-submodules https://github.com/solvespace/solvespace.git solvespace</p>
<p>edit Y:\tmp\solvespace\extlib\angle\CMakeLists.txt comment out line 713 and 714</p>
<p>#list(APPEND ANGLE_DEFINITIONS<br/> #"-DANGLE_PRELOADED_D3DCOMPILER_MODULE_NAMES={ \"d3dcompiler_47.dll\", \"d3dcompiler_46.dll\", \"d3dcompiler_43.dll\" }")<br/>endif()</p>
<p>需要手動進行 libpng.dll.a 的編譯, 並改名為 libpng_static.a, 並放到編譯系統的 lib 目錄中:</p>
<p style="padding-left: 30px;">cd solvespace</p>
<p style="padding-left: 30px;">cd extlib</p>
<p style="padding-left: 30px;">cd libpng</p>
<p style="padding-left: 30px;">mkdir build</p>
<p style="padding-left: 30px;">cd build</p>
<p style="padding-left: 30px;">cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release<br/>mingw32-make</p>
<p style="padding-left: 30px;">rename libpng.dll.a to libpng_static.a and copy to Y:\msys64\mingw64\lib</p>
<p>接著回到 solvespace 原始碼目錄, 建立 build 目錄後進入 build 目錄, 執行:</p>
<p style="padding-left: 30px;"><span>cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release</span><br/><span>mingw32-make</span></p>
<p><span>登入 @gm 後:</span></p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/open?id=16bLBcVUXWW_nQ1ki-Mtsox1DsSI-2gIj"><span>下載 Solvespace </span>986da7d 版本</a></p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/file/d/11lSoROAP5swT1RqX-eR-6aMhmOwx3zt3/view?usp=sharing">下載自行編譯的  solvespace.exe</a></p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/file/d/18R3erVkzKdvJmQ-ni7YzSb_izwGUkkeo/view?usp=sharing">下載 Solvespace 22e4011 版本</a></p>
<p></p>
<h2>Pyslvs-UI</h2>
<p><a href="https://github.com/KmolYuan/Pyslvs-UI">https://github.com/KmolYuan/Pyslvs-UI</a></p>
<p>目前正將原先使用 PyQt 的使用者介面改寫為 <a href="https://github.com/mottosso/Qt.py">https://github.com/mottosso/Qt.py</a> 相容, </p>
<p>套件執行請下載 <a href="https://github.com/KmolYuan/Pyslvs-UI/releases">https://github.com/KmolYuan/Pyslvs-UI/releases</a> Windows 64 位元版本.</p>
<p>自行編譯核心程式碼:</p>
<p style="padding-left: 30px;">git clone <a href="https://github.com/KmolYuan/Pyslvs-UI">https://github.com/KmolYuan/Pyslvs-UI</a>.git </p>
<p style="padding-left: 30px;">cd Pyslvs-UI</p>
<p style="padding-left: 30px;">git submodule update --init --recursive</p>
<p style="padding-left: 30px;">cd depend/pyslvs</p>
<p style="padding-left: 30px;">python setup.py install</p>
<p style="padding-left: 30px;">cd ..</p>
<p style="padding-left: 30px;">cd solvespce/cython</p>
<p style="padding-left: 30px;">python setup.py install</p>
<p>接下來可直接利用 Python 程式呼叫位於 Lib/site-packages/pyslvs 與 <span>Lib/site-packages/python-solvespace 中的動態連結程式庫.</span></p>
<p><span>自行編譯 pyslvs.exe 套件時, 必須先檢查可攜系統是否已經安裝 requirements.txt 中所需的模組.</span></p>
<p style="padding-left: 30px;">cd Pyslvs-UI </p>
<p style="padding-left: 30px;">mingw32-make build</p><h2>Onshape</h2>
<p><a href="https://appstore.onshape.com/apps/Utilities/DFE73AMQ42NPMVAEQBQVP56QGLCWJ4ALJUBEBLA=/description">Link Tab</a></p>
<p>3DX Models</p>
<p style="padding-left: 30px;"><a href="https://3dx-us.com/onshape">https://3dx-us.com/onshape</a></p>
<p style="padding-left: 30px;"><a href="https://appstore.onshape.com/apps/Content/KAMXGDNGLR7APEHQNTPRS2CFEMW5AZL7JZG542I=/description">PartCommunity</a></p>
<p>Version manager</p>
<p style="padding-left: 30px;"><a href="https://cad.onshape.com/help/Content/versionmanager.htm">https://cad.onshape.com/help/Content/versionmanager.htm</a></p>
<p>Onshape and Simscale</p>
<p style="padding-left: 30px;"><a href="https://www.simscale.com/blog/2015/12/introducing-simscale-connector-app-for-onshape/">https://www.simscale.com/blog/2015/12/introducing-simscale-connector-app-for-onshape/</a></p>
<p style="padding-left: 30px;"><a href="https://appstore.onshape.com/apps/Simulation/QAE7WBN7FWMFELRRW774OLYYRFQBSZCQAMA2JMY=/description">Simright</a></p>
<p>Onshape and Kiri:Moto (CAM)</p>
<p style="padding-left: 30px;"><a href="https://forum.onshape.com/discussion/5081/kiri-moto-integration">https://forum.onshape.com/discussion/5081/kiri-moto-integration</a></p>
<p style="padding-left: 30px;"><a href="https://forum.onshape.com/discussion/8248/kiri-moto-video-guide-for-cnc-machining">https://forum.onshape.com/discussion/8248/kiri-moto-video-guide-for-cnc-machining</a></p>
<p>OpenBOM</p>
<p style="padding-left: 30px;"><a href="https://www.onshape.com/cad-blog/creating-a-bill-of-materials-using-openbom">https://www.onshape.com/cad-blog/creating-a-bill-of-materials-using-openbom</a></p><h2>V-rep</h2>
<p>登入 @gm 電子郵箱後, 可以下載 <a href="https://drive.google.com/file/d/1cZFSsLEoGOBYojzKzFEf4YH2l--pbS-9/view?usp=sharing">V-rep 3.6.1 rev4.7z</a> (139 MB)</p>
<p>目前最新版為 <a href="https://drive.google.com/file/d/1FG0Bpd7pcNLdk_WWFtooMaAxItbmSfgs/view?usp=sharing">V-rep 3.6.2 rev0.7z</a>, 必須比較 <a href="http://mde.tw/cd2019/content/%E5%8D%94%E5%90%8C%E8%A8%AD%E8%A8%88.html">cd2019</a> 所使用的  V-rep 版本後, 選擇一個版本.</p>
<p>reading and display vision sensor image using python remoate api (<a href="http://www.forum.coppeliarobotics.com/viewtopic.php?f=9&amp;t=7012#p27785">來源</a>)</p>
<p>改為 Python 3 相容</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># -*- coding: utf-8 -*-
"""
Created on Sun Jul 05 15:01:58 2015

@author: ACSECKIN

python -m pip install opencv-python
"""

import vrep
import time
import cv2
import numpy as np

vrep.simxFinish(-1)

clientID = vrep.simxStart('127.0.0.1', 19997, True, True, 5000, 5)

if clientID!=-1:
    print('Connected to remote API server')
    print('Vision Sensor object handling')
    res, v1 = vrep.simxGetObjectHandle(clientID, 'vs1', vrep.simx_opmode_oneshot_wait)
    print('Getting first image')
    err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v1, 0, vrep.simx_opmode_streaming)
    while (vrep.simxGetConnectionId(clientID) != -1):
        err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v1, 0, vrep.simx_opmode_buffer)
        if err == vrep.simx_return_ok:
            print("image OK!!!")
            img = np.array(image,dtype=np.uint8)
            img.resize([resolution[1],resolution[0],3])
            cv2.imshow('image',img)
            if cv2.waitKey(1) &amp; 0xFF == ord('q'):
                break
        elif err == vrep.simx_return_novalue_flag:
            print("no image yet")
            pass
        else:
          print(err)
else:
  print("Failed to connect to remote API Server")
  vrep.simxFinish(clientID)

cv2.destroyAllWindows()</pre>
<p><a href="/downloads/pythonBubbleRob.pdf">pythonBubbleRob.pdf</a></p>
<p><a href="/downloads/lua_one_link_remote_api.7z">lua_one_link_remote_api.7z</a></p>
<p>V-rep 系統目錄中的 remoteApiConnections.txt 可以同時啟動多個 port 允許多 client 連線:</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">// This file defines all the continuous remote API server services (started at remote API plugin initialization, i.e. V-REP start-up)
//
// Each remote API server service requires following 3 entries:
//
// portIndex@_port = xxxx               // where xxxx is the desired port number (below 19997 are preferred for server services starting at V-REP start-up)
// portIndex@_debug = xxxx              // where xxxx is true or false
// portIndex@_syncSimTrigger = xxxx     // where xxxx is true or false. When true, then the service will be pre-enabled for synchronous operation.
//
// In above strings, @ can be any number starting with 1. If more than one server service is required, then numbers need to be consecutive and starting with 1

// Let's start a continuous remote API server service on port 19997:
portIndex1_port             = 19997
portIndex1_debug            = false
portIndex1_syncSimTrigger   = true

portIndex2_port             = 19998
portIndex2_debug            = false
portIndex2_syncSimTrigger   = true
</pre>
<p></p>
<p>在遠端的多台電腦, 可以利用</p>
<p>clientID = vrep.simxStart('Server_IP', 19997, True, True, 5000, 5)</p>
<p>與</p>
<p><span>clientID = vrep.simxStart('Server_IP', 19998, True, True, 5000, 5)</span></p>
<p><span>同時對 rempte API server 進行操控, 各 client 並可以透過上述程式取得 rempte API Server 運作時的影像, 以便利用各 client 中的 python 程式對遠端 V-rep 模擬進行遠端操控.</span></p>
<p><span>例如: 兩名使用者分別在不同電腦上對同一台 rempte API Server 中的手足球模型進行操控競賽.</span></p>
<p><span>以下為另外一個參考程式:</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import vrep

print('Program started')
vrep.simxFinish(-1) # just in case, close all opened connections
clientID=vrep.simxStart('127.0.0.1',19999,True,True,5000,5)
if clientID!=-1:
    print('Connected to remote API server')
    res,v0=vrep.simxGetObjectHandle(clientID,'Vision_sensor',vrep.simx_opmode_oneshot_wait)
    res,v1=vrep.simxGetObjectHandle(clientID,'PassiveVision_sensor',vrep.simx_opmode_oneshot_wait)

    res,resolution,image=vrep.simxGetVisionSensorImage(clientID,v0,0,vrep.simx_opmode_streaming)
    while (vrep.simxGetConnectionId(clientID)!=-1):
        res,resolution,image=vrep.simxGetVisionSensorImage(clientID,v0,0,vrep.simx_opmode_buffer)
        if res==vrep.simx_return_ok:
            res=vrep.simxSetVisionSensorImage(clientID,v1,image,0,vrep.simx_opmode_oneshot)
    vrep.simxFinish(clientID)
else:
    print('Failed connecting to remote API server')
print('Program ended')</pre>
<p>此外 system 目錄下的 usrset.txt 可以進行客製化設定</p>
<p></p><h3>3D Printer</h3>
<p>Create Shape from path</p>
<p><a href="http://www.forum.coppeliarobotics.com/viewtopic.php?f=9&amp;t=7920">http://www.forum.coppeliarobotics.com/viewtopic.php?f=9&amp;t=7920</a></p>
<p>Question:</p>
<p>Can <a href="http://www.coppeliarobotics.com/helpFiles/en/regularApi/simCreateMeshShape.htm">http://www.coppeliarobotics.com/helpFiles/en/regularApi/simCreateMeshShape.htm</a> be used to create virtual printing function?</p>
<h3>Cyber-physical</h3>
<p>Virtual vs Real Controller</p>
<p><a href="http://www.forum.coppeliarobotics.com/viewtopic.php?f=9&amp;t=7906">http://www.forum.coppeliarobotics.com/viewtopic.php?f=9&amp;t=7906</a></p>
<p><a href="http://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm">http://www.coppeliarobotics.com/helpFiles/en/b0RemoteApiOverview.htm</a></p>
<h2>FreeCAD</h2>
<p><a href="https://drive.google.com/file/d/13-ByKlFCsScF3xHi1SZrsJ1ZOejzFXZo/view?usp=sharing">FreeCAD 0.18.7z</a><span> </span>(登入 gm.nfu.edu.tw 後下載) - 電腦輔助設計實習課程專用</p>
<h2>Webots</h2>
<p><span><a href="https://drive.google.com/file/d/1o8cAv-pSUyp69TUGhC7NvEznGrdNP5AC/view?usp=sharing">Webot 2019a.7z</a> </span><span>(登入 gm.nfu.edu.tw 後下載) - 電腦輔助設計實習課程專用</span></p>
<h2>Solidworks</h2>
<p>登入 @gm 電子郵箱, 可以<a href="https://drive.google.com/file/d/1KPpXzumzBIvMCovZdBYh0s468uFO277k/view">下載 SolidWorks 2017 SP2 安裝光碟</a>), 或是已經安裝好的 <a href="https://drive.google.com/file/d/1VB30WUbfKEH3BX3ftLlOWWZ_aQIZzZVx/view?usp=sharing">SolidWorks 2017 SP2 虛擬主機版本</a>.</p>
<p><a href="/downloads/solidworks_basics.pdf">solidworks_basics.pdf</a></p>
<p><a href="/downloads/Solidworks_EDU_Drawing_Exercises_2010_ENG.pdf">Solidworks_EDU_Drawing_Exercises_2010_ENG.pdf</a></p>
<p><a href="/downloads/Solidworks_tutorial_exercise.pdf">Solidworks_tutorial_exercise.pdf</a></p>
<p><a href="/downloads/SolidWorks_2010_軟體教師手冊.pdf">SolidWorks_2010_軟體教師手冊.pdf</a> (<a href="/downloads/Solidworks_2010_InstructorsGuide_ENG.pdf">英文版</a>) (<a href="/downloads/Solidworks_2013_InstructorsGuide_ENG.pdf">2013 版</a>)</p>
<p><a href="/downloads/SolidWorks_2010_ 軟體學生手冊.pdf">SolidWorks_2010_ 軟體學生手冊.pdf</a></p>
<p><a href="/downloads/SolidWorks_Tutorial08_BearingPuller_English_08_LR.pdf">SolidWorks_Tutorial08_BearingPuller_English_08_LR.pdf</a></p>
<p><a href="/downloads/SolidWorks_2010_軟體教師手冊.pdf"></a><a href="/downloads/SolidWorks_Simulation_執行應力分析簡介.pdf">SolidWorks_Simulation_執行應力分析簡介.pdf</a> (<a href="/downloads/Solidworks_Simulation_Student_2011_ENG.pdf">英文版</a>)</p>
<p><a href="/downloads/SolidWorks_Simulation_Instructor_Guide_2010_ENG.pdf">SolidWorks_Simulation_Instructor_Guide_2010_ENG.pdf</a></p>
<p><a href="/downloads/SolidWorks_Simulation_Instructor_Guide_2010_CHT.pdf">使用 SolidWorks Simulation 執行應力 分析的簡介 講師指南.pdf</a></p>
<p><a href="/downloads/Solidworks_Mountainboard_Design_Project_Student_2010_LR_ENG.pdf">Solidworks_Mountainboard_Design_Project_Student_2010_LR_ENG.pdf</a></p>
<p><a href="/downloads/Solidworks_SIM_2010_HOTD_ENG.pdf">Solidworks_SIM_2010_HOTD_ENG.pdf</a></p>
<p><a href="/downloads/Mountainboard_Student_WB_2011_ENG.pdf">Mountainboard_Student_WB_2011_ENG.pdf</a></p>
<p><a href="/downloads/Solidworks_2010_Bridge_Design_Project_ENG.pdf">Solidworks_2010_Bridge_Design_Project_ENG.pdf</a></p>
<p><a href="/downloads/Solidworks_Motion_Instructor_Guide_2010_ENG.pdf">Solidworks_Motion_Instructor_Guide_2010_ENG.pdf</a></p>
<p><a href="/downloads/Solidworks_Flow_Simulation_Instructor_Guide_2010_ENG.pdf">Solidworks_Flow_Simulation_Instructor_Guide_2010_ENG.pdf</a></p>
<p><a href="/downloads/Solidworks_CO2_Car_Project_Workbook_2010_ENG.pdf">Solidworks_CO2_Car_Project_Workbook_2010_ENG.pdf</a></p>
<p><a href="/downloads/Solidworks_CSWPAdvancedSheetMetalSampleExam.pdf">Solidworks_CSWPAdvancedSheetMetalSampleExam.pdf</a></p>
<p><a href="/downloads/Solidworks_DRWT Sample Exam.pdf">Solidworks_DRWT Sample Exam.pdf</a></p>
<p><a href="/downloads/Solidworks_Sample CSWP-SURF Advanced Surfacing Certification Exam.pdf">Solidworks_Sample CSWP-SURF Advanced Surfacing Certification Exam.pdf</a></p>
<p><a href="/downloads/Solidworks_CSWP-WLDM Sample Exam.pdf">Solidworks_CSWP-WLDM Sample Exam.pdf</a></p>
<p><a href="/downloads/Solidworks_CSWP-FEA Sample Exam 2011.pdf">Solidworks_CSWP-FEA Sample Exam 2011.pdf</a></p>
<p>downloads 目錄中 Solidworks_Tutorial 子目錄中的 pdf 教學檔案</p><h3>SW API</h3>
<p><a href="/downloads/INTEGRATION OF MODELING IN SOLIDWORKS AND MATLAB SIMULINK ENVIRONMENTS.pdf">INTEGRATION OF MODELING IN SOLIDWORKS AND MATLAB/SIMULINK ENVIRONMENTS.pdf</a></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import win32com.client
import pythoncom
swYearLastDigit = 6
sw = win32com.client.Dispatch("SldWorks.Application.%d" % (25+(swYearLastDigit-2)))  # e.g. 24 is SW2016,  25 is SW2017

model = sw.ActiveDoc
modelExt = model.Extension
selMgr = model.SelectionManager
featureMgr = model.FeatureManager
sketchMgr = model.SketchManager
eqMgr = model.GetEquationMgr

print("Equation 1 is: " + eqMgr.Equation(1))
eqMgr.Equation(1, "\"myVar\" = 2017")
print("Equation 1 is now: " + eqMgr.Equation(1))</pre>
<p></p><h2>Solid Edge</h2>
<p><a href="https://www.plm.automation.siemens.com/plmapp/education/solid-edge/en_us/free-software/student">https://www.plm.automation.siemens.com/plmapp/education/solid-edge/en_us/free-software/student</a></p>
<h2>NX</h2>
<p><a href="https://link.springer.com/book/10.1007/978-3-319-03862-9">Space Modeling with SolidWorks and NX.pdf</a></p>
<p><a href="https://docs.plm.automation.siemens.com/docs/nx/12.0.1/en_US/release_notes.pdf">https://docs.plm.automation.siemens.com/docs/nx/12.0.1/en_US/release_notes.pdf</a></p>
<p><a href="https://docs.plm.automation.siemens.com/tdoc/nx/12/nx_help/">https://docs.plm.automation.siemens.com/tdoc/nx/12/nx_help/</a></p>
<p><a href="/downloads/NX-12-for-Engineering-Design.pdf">NX12 for engineering design.pdf</a></p>
<p><a href="/downloads/parametric_modeling_with_nx12.pdf">parametric_modeling_with_nx12.pdf</a></p>
<p><a href="/downloads/nxopen_getting_started_v12.pdf">nxopen_getting_started_v12.pdf</a></p>
<p>NXOpen Python Guide:</p>
<p><a href="https://docs.plm.automation.siemens.com/data_services/resources/nx/12/nx_api/custom/en_US/nxopen_python_ref/index.html">https://docs.plm.automation.siemens.com/data_services/resources/nx/12/nx_api/custom/en_US/nxopen_python_ref/index.html</a></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import math
import NXOpen
import NXOpen.UF

def BoundingBox() : 

    theSession  = NXOpen.Session.GetSession()
    theUFSession = NXOpen.UF.UFSession.GetUFSession()
    workPart = theSession.Parts.Work
    
    size = theSession.ListingWindow
    size.Open()
    size.WriteLine("Bounding Boxes:")

    NULLTAG = 0

    all_bodies = workPart.Bodies
    bounding_Box_Coords = []

    for body in all_bodies:
        bounding_Box_Coords = theUFSession.ModlGeneral.AskBoundingBox(body.Tag) 

        size.WriteLine(str(bounding_Box_Coords[0]) + "  ")
        size.WriteLine(str(bounding_Box_Coords[1]) + "  ")
        size.WriteLine(str(bounding_Box_Coords[2]) + "  ")
        size.WriteLine(str(bounding_Box_Coords[3]) + "  ")
        size.WriteLine(str(bounding_Box_Coords[4]) + "  ")
        size.WriteLine(str(bounding_Box_Coords[5]))
        size.WriteLine("  ")

    
if __name__ == '__main__':
    BoundingBox()</pre>
<p><a href="/downloads/nx12_python_setup.pdf">nx12_python_setup</a></p><h3>NX3</h3>
<p><span>登入 @gm 電子郵箱, 就可以</span><a href="https://drive.google.com/file/d/1UvjzhHPzNvUWPhxl8Cz5Ef4k3L5WJkAy/view?usp=sharing">下載 NX3_portable.7z</a><span>, 解開壓縮檔放入隨身碟, 並且連上網路擷取授權認證後, 就可以使用.</span></p>
<p><a href="/downloads/UG-NX3-Tutorial.pdf">UG-NX3-Tutorial.pdf</a></p>
<p><a href="/downloads/UG-NX_Drafting.pdf">UG-NX_Drafting.pdf</a></p>
<p><a href="/downloads/nx2_UGOPEN_API.pdf">nx2_UGOPEN_API.pdf</a></p>
<p><a href="/downloads/MoldWizard_handbook .pdf">MoldWizard_handbook .pdf</a></p>
<p><a href="/downloads/Knowledge-Fusion.pdf">Knowledge-Fusion.pdf</a></p>
<p><a href="/downloads/6539345-Knowledge-Fusion.pdf">6539345-Knowledge-Fusion.pdf</a></p>
<p><a href="/downloads/gears.pdf">gears.pdf</a></p>
<p><a href="/downloads/Gear.zip">Gear.zip</a> (UGOPEN example)</p>
<p><a href="/downloads/UG_WAVE_ref.7z">UG_WAVE_ref.7z</a></p>
<p><a href="/downloads/NX3_samples.7z">NX3_samples.7z</a></p>
<p><a href="/downloads/3d_UG_NX6_Intro-2010.pdf">UG_NX6_Intro-2010.pdf</a></p>
<p><a href="/downloads/1_CADCAECAM_Review.pdf">CADCAECAM_Review.pdf</a></p>
<p><a href="/downloads/UG_NX6_Buttons.pdf">UG_NX6_Buttons.pdf</a></p>
<p></p>
<h3>NX12</h3>
<p>登入 @gm 電子郵箱, 可以<a href="https://drive.google.com/file/d/1fEZtGVCXp2vtILUZZ8vTTdtYHsbBpf7j/view?usp=sharing">下載 NX 12.0.2 安裝光碟</a> (Windows 64 位元), <a href="https://drive.google.com/file/d/1bDM1U6m2XtfR45b6jFRrcXJLEvxLmh-u/view?usp=sharing">下載 Linux NX12.0.2 安裝光碟</a>, 或者<a href="https://drive.google.com/file/d/1UyDUGc2ytn-EVHCw-bNqanV6Jw11yvUg/view?usp=sharing">下載 NX12.0.2 虛擬主機板本</a>, 或者<a href="https://drive.google.com/file/d/1Ul025kwP3I1SC0aD1YEzZRcL0ZzIlO1p/view?usp=sharing">下載 NX12 可攜版本</a>.</p>
<p>可否利用 NX12 執行 <a href="https://link.springer.com/book/10.1007/978-3-319-23359-8">Computer Aided Virtual Manufacturing Using Creo Parametric - Easy to Learn Step by Step Guide.pdf</a> 中的所有步驟?</p>
<p><a href="/downloads/How to Speed up Your NX.pdf">How to Speed up Your NX.pdf</a></p>
<p><a href="/downloads/NX12.0.2_release_notes.pdf">NX12.0.2_release_notes.pdf</a> (<a href="/downloads/FlexNet 2015 License Administration Guide.pdf">FlexNet 2015 License Administration Guide.pdf</a>)</p>
<p style="padding-left: 30px;">With the creation of the central runtime directory, there are two different locations for these files (nxbin and ugii), so the concept of UGII_ROOT_DIR is obsoleted. Use the UGII_BASE_DIR variable instead when you write custom application code and scripts</p>
<p style="padding-left: 30px;">The minimum recommended amount of memory to run native NX is 8GB</p>
<p style="padding-left: 30px;">SuSE Linux Enterprise Server/Desktop 12<br/>Red Hat Enterprise Linux Server/Desktop 7</p>
<p style="padding-left: 30px;">IPv6 Support:</p>
<ol>
<li style="padding-left: 30px;">In license and options files, FlexNet Publisher supports only the site-local form of the IPv6 address (those<br/>prefixed with FEC0). (請注意: Virtualbox 的 Host only 網路 IPv4/IPv6 位址從控制台中的 VirtualBox Host-Only Network 設定中取得, 另外當採純 IPv4 建置認證與 client 電腦之後, 可以再透過 <a href="https://www.softether.org/">https://www.softether.org/</a> 建構 VPN 環境, 讓 client 可以從外部網段取得所需套件認證)</li>
<li style="padding-left: 30px;">While IPv6 address can be used in license or options files, the best-practice recommended is to use<br/>hostname or IPv4 address.</li>
<li style="padding-left: 30px;">If IPv6 address is used in the license or options file, then the FNP_IP_PRIORITY environment variable will<br/>need to be set (FNP_IP_PRIORITY=6).</li>
<li style="padding-left: 30px;">A mix of IPv4 and IPv6 addresses in the license and/or options file is not supported.</li>
</ol>
<h4>FlexNet Publisher</h4>
<p><a href="https://en.wikipedia.org/wiki/FlexNet_Publisher">https://en.wikipedia.org/wiki/FlexNet_Publisher</a></p>
<p style="padding-left: 30px;"><a href="/downloads/FlexNet Publisher v11.15.0.0 for Windows 64-bit.zip">FlexNet Publisher v11.15.0.0 for Windows 64-bit.zip</a></p>
<p style="padding-left: 30px;"><a href="/downloads/FlexNet Publisher 2018 R4.pdf">FlexNet Publisher 2018 R4.pdf</a> (Version 11.16.2)</p>
<p style="padding-left: 30px;"><a href="/downloads/FlexNet Publisher v11.15.0.0 for Linux 64-bit.tgz">FlexNet Publisher v11.15.0.0 for Linux 64-bit.tgz</a></p>
<p style="padding-left: 30px;"><a href="https://developer.arm.com/tools-and-software/software-development-tools/license-management/downloads">https://developer.arm.com/tools-and-software/software-development-tools/license-management/downloads#</a></p>
<p style="padding-left: 30px;"><a href="https://helpnet.flexerasoftware.com/eol/flexnet-publisher.htm">https://helpnet.flexerasoftware.com/eol/flexnet-publisher.htm</a></p>
<p><a href="/downloads/Siemens PLM Licensing User Guide.pdf">Siemens PLM Licensing User Guide.pdf</a></p>
<p><a href="/downloads/NX Installation Guide for Linux and Mac OS X.pdf">NX Installation Guide for Linux and Mac OS X.pdf</a></p>
<p><a href="/downloads/NX-12-for-Engineering-Design.pdf">NX-12-for-Engineering-Design.pdf</a></p>
<p>Journaling: <a href="http://www.nxjournaling.com/content/beginning-journaling-using-nx-journal">http://www.nxjournaling.com/content/beginning-journaling-using-nx-journal</a></p>
<p><a href="/downloads/nxopen_getting_started_v12.pdf">nxopen_getting_started_v12.pdf</a></p>
<p><a href="/downloads/SNAP_Getting_Started_v12.pdf">SNAP_Getting_Started_v12.pdf</a></p>
<p><a href="/downloads/NX Nastran 12 - Release Guide.pdf">NX Nastran 12 - Release Guide.pdf</a></p>
<p><a href="/downloads/NX12_NASTRAN_get_start.pdf">NX12_NASTRAN_get_start.pdf</a></p>
<p><a href="/downloads/NX Nastran 12 - Quick Reference Guide.pdf">NX Nastran 12 - Quick Reference Guide.pdf</a></p>
<p><a href="/downloads/NX Nastran 12 - Advanced Nonlinear Theory and Modeling Guide.pdf">NX Nastran 12 - Advanced Nonlinear Theory and Modeling Guide.pdf</a></p>
<h2>Bond Graphs</h2>
<p><a href="https://github.com/mdecourse/BondGraphTools">https://github.com/mdecourse/BondGraphTools</a></p>
<p></p>
<h1>Tasks</h1>
<h4>Task1</h4>
<p style="padding-left: 30px;">參數式繪圖軟體 Solvespace 編譯、零組件繪圖與應用.</p>
<h4>Task2</h4>
<p style="padding-left: 30px;">MCAD 套件安裝與設定, 零組件繪圖、轉檔與 CAE 工程分析.</p>
<h4>Task3</h4>
<p style="padding-left: 30px;"><span>Rover 零組件轉入<a href="http://www.coppeliarobotics.com/"><span> </span>V-rep</a><span> </span>與<span> </span><a href="https://cyberbotics.com/">Webots</a><span> </span>執行機電控制系統設計.</span></p>
<h4>Project</h4>
<p style="padding-left: 30px;"><span>機電資整合分組專案執行.</span></p>
<p></p>
<h4><span style="background-color: #ffff99;"></span></h4><h2>分組名單</h2>
<h4>cad 2a 分組結果</h4>
<p>====================<br/> 第 1 組成員:<br/> <a href="https://github.com/s40523120/cad2019">40523120 倉儲</a> | <a href="https://s40523120.github.io/cad2019">40523120 網站</a><br/> <a href="https://github.com/s40723102/cad2019">40723102 倉儲</a> | <a href="https://s40723102.github.io/cad2019">40723102 網站</a><br/> <a href="https://github.com/s40723110/cad2019">40723110 倉儲</a> | <a href="https://s40723110.github.io/cad2019">40723110 網站</a><br/> <a href="https://github.com/s40723112/cad2019">40723112 倉儲</a> | <a href="https://s40723112.github.io/cad2019">40723112 網站</a><br/> <a href="https://github.com/s40723115/cad2019">40723115 倉儲</a> | <a href="https://s40723115.github.io/cad2019">40723115 網站</a><br/> <a href="https://github.com/s40723120/cad2019">40723120 倉儲</a> | <a href="https://s40723120.github.io/cad2019">40723120 網站</a><br/> <a href="https://github.com/s40723127/cad2019">40723127 倉儲</a> | <a href="https://s40723127.github.io/cad2019">40723127 網站</a><br/> <a href="https://github.com/s40723136/cad2019">40723136 倉儲</a> | <a href="https://s40723136.github.io/cad2019">40723136 網站</a><br/> <a href="https://github.com/s40723140/cad2019">40723140 倉儲</a> | <a href="https://s40723140.github.io/cad2019">40723140 網站</a><br/> <a href="https://github.com/s40723143/cad2019">40723143 倉儲</a> | <a href="https://s40723143.github.io/cad2019">40723143 網站</a><br/> <a href="https://github.com/s40723146/cad2019">40723146 倉儲</a> | <a href="https://s40723146.github.io/cad2019">40723146 網站</a><br/> <a href="https://github.com/s40723148/cad2019">40723148 倉儲</a> | <a href="https://s40723148.github.io/cad2019">40723148 網站</a><br/> ====================<br/> 第 2 組成員:<br/> <a href="https://github.com/s40523148/cad2019">40523148 倉儲</a> | <a href="https://s40523148.github.io/cad2019">40523148 網站</a><br/> <a href="https://github.com/s40523241/cad2019">40523241 倉儲</a> | <a href="https://s40523241.github.io/cad2019">40523241 網站</a><br/> <a href="https://github.com/s40723118/cad2019">40723118 倉儲</a> | <a href="https://s40723118.github.io/cad2019">40723118 網站</a><br/> <a href="https://github.com/s40723129/cad2019">40723129 倉儲</a> | <a href="https://s40723129.github.io/cad2019">40723129 網站</a><br/> <a href="https://github.com/s40723132/cad2019">40723132 倉儲</a> | <a href="https://s40723132.github.io/cad2019">40723132 網站</a><br/> <a href="https://github.com/s40723135/cad2019">40723135 倉儲</a> | <a href="https://s40723135.github.io/cad2019">40723135 網站</a><br/> <a href="https://github.com/s40723138/cad2019">40723138 倉儲</a> | <a href="https://s40723138.github.io/cad2019">40723138 網站</a><br/> <a href="https://github.com/s40723139/cad2019">40723139 倉儲</a> | <a href="https://s40723139.github.io/cad2019">40723139 網站</a><br/> <a href="https://github.com/s40723141/cad2019">40723141 倉儲</a> | <a href="https://s40723141.github.io/cad2019">40723141 網站</a><br/> <a href="https://github.com/s40723144/cad2019">40723144 倉儲</a> | <a href="https://s40723144.github.io/cad2019">40723144 網站</a><br/> <a href="https://github.com/s40723145/cad2019">40723145 倉儲</a> | <a href="https://s40723145.github.io/cad2019">40723145 網站</a><br/> <a href="https://github.com/40723153/cad2019">40723153 倉儲</a> | <a href="https://40723153.github.io/cad2019">40723153 網站</a><br/> ====================<br/> 第 3 組成員:<br/><a href="https://github.com/40423208/cad2019">40423208 倉儲</a> | <a href="https://40423208.github.io/cad2019">40423208 網站</a><br/><a href="https://github.com/s40523142/cad2019">40523142 倉儲</a> | <a href="https://s40523142.github.io/cad2019">40523142 網站</a><br/> <a href="https://github.com/s40723104/cad2019">40723104 倉儲</a> | <a href="https://s40723104.github.io/cad2019">40723104 網站</a><br/> <a href="https://github.com/s40723106/cad2019">40723106 倉儲</a> | <a href="https://s40723106.github.io/cad2019">40723106 網站</a><br/> <a href="https://github.com/s40723108/cad2019">40723108 倉儲</a> | <a href="https://s40723108.github.io/cad2019">40723108 網站</a><br/> <a href="https://github.com/s40723111/cad2019">40723111 倉儲</a> | <a href="https://s40723111.github.io/cad2019">40723111 網站</a><br/> <a href="https://github.com/s40723121/cad2019">40723121 倉儲</a> | <a href="https://s40723121.github.io/cad2019">40723121 網站</a><br/> <a href="https://github.com/s40723123/cad2019">40723123 倉儲</a> | <a href="https://s40723123.github.io/cad2019">40723123 網站</a><br/> <a href="https://github.com/s40723126/cad2019">40723126 倉儲</a> | <a href="https://s40723126.github.io/cad2019">40723126 網站</a><br/> <a href="https://github.com/s40723128/cad2019">40723128 倉儲</a> | <a href="https://s40723128.github.io/cad2019">40723128 網站</a><br/> <a href="https://github.com/s40723130/cad2019">40723130 倉儲</a> | <a href="https://s40723130.github.io/cad2019">40723130 網站</a><br/> <a href="https://github.com/s40723133/cad2019">40723133 倉儲</a> | <a href="https://s40723133.github.io/cad2019">40723133 網站</a><br/> ====================<br/> 第 4 組成員:<br/> <a href="https://github.com/s40423218/cad2019">40423218 倉儲</a> | <a href="https://s40423218.github.io/cad2019">40423218 網站</a><br/> <a href="https://github.com/s40623123/cad2019">40623123 倉儲</a> | <a href="https://s40623123.github.io/cad2019">40623123 網站</a><br/> <a href="https://github.com/s40623143/cad2019">40623143 倉儲</a> | <a href="https://s40623143.github.io/cad2019">40623143 網站</a><br/> <a href="https://github.com/s40723134/cad2019">40723134 倉儲</a> | <a href="https://s40723134.github.io/cad2019">40723134 網站</a><br/> <a href="https://github.com/s40723137/cad2019">40723137 倉儲</a> | <a href="https://s40723137.github.io/cad2019">40723137 網站</a><br/> <a href="https://github.com/s40723142/cad2019">40723142 倉儲</a> | <a href="https://s40723142.github.io/cad2019">40723142 網站</a><br/> <a href="https://github.com/s40723147/cad2019">40723147 倉儲</a> | <a href="https://s40723147.github.io/cad2019">40723147 網站</a><br/> <a href="https://github.com/s40723149/cad2019">40723149 倉儲</a> | <a href="https://s40723149.github.io/cad2019">40723149 網站</a><br/> <a href="https://github.com/s40723150/cad2019">40723150 倉儲</a> | <a href="https://s40723150.github.io/cad2019">40723150 網站</a><br/> <a href="https://github.com/s40723151/cad2019">40723151 倉儲</a> | <a href="https://s40723151.github.io/cad2019">40723151 網站</a><br/> <a href="https://github.com/s40723154/cad2019">40723154 倉儲</a> | <a href="https://s40723154.github.io/cad2019">40723154 網站</a><br/> ====================<br/> 第 5 組成員:<br/> <a href="https://github.com/s40523113/cad2019">40523113 倉儲</a> | <a href="https://s40523113.github.io/cad2019">40523113 網站</a><br/> <a href="https://github.com/s40623252/cad2019">40623252 倉儲</a> | <a href="https://s40623252.github.io/cad2019">40623252 網站</a><br/> <a href="https://github.com/s40723101/cad2019">40723101 倉儲</a> | <a href="https://s40723101.github.io/cad2019">40723101 網站</a><br/> <a href="https://github.com/s40723103/cad2019">40723103 倉儲</a> | <a href="https://s40723103.github.io/cad2019">40723103 網站</a><br/> <a href="https://github.com/s40723107/cad2019">40723107 倉儲</a> | <a href="https://s40723107.github.io/cad2019">40723107 網站</a><br/> <a href="https://github.com/s40723114/cad2019">40723114 倉儲</a> | <a href="https://s40723114.github.io/cad2019">40723114 網站</a><br/> <a href="https://github.com/s40723119/cad2019">40723119 倉儲</a> | <a href="https://s40723119.github.io/cad2019">40723119 網站</a><br/> <a href="https://github.com/s40723122/cad2019">40723122 倉儲</a> | <a href="https://s40723122.github.io/cad2019">40723122 網站</a><br/> <a href="https://github.com/s40723124/cad2019">40723124 倉儲</a> | <a href="https://s40723124.github.io/cad2019">40723124 網站</a><br/> <a href="https://github.com/s40723125/cad2019">40723125 倉儲</a> | <a href="https://s40723125.github.io/cad2019">40723125 網站</a><br/> <a href="https://github.com/s40723152/cad2019">40723152 倉儲</a> | <a href="https://s40723152.github.io/cad2019">40723152 網站</a><br/> <a href="https://github.com/s40723155/cad2019">40723155 倉儲</a> | <a href="https://s40723155.github.io/cad2019">40723155 網站</a></p>
<p>[[40523120, 40723102, 40723110, 40723112, 40723115, 40723120, 40723127, 40723136, 40723140, 40723143, 40723146, 40723148], [40523148, 40523241, 40723118, 40723129, 40723132, 40723135, 40723138, 40723139, 40723141, 40723144, 40723145, 40723153], [40423208, 40523142, 40723104, 40723106, 40723108, 40723111, 40723121, 40723123, 40723126, 40723128, 40723130, 40723133], [40423218, 40623123, 40623143, 40723134, 40723137, 40723142, 40723147, 40723149, 40723150, 40723151, 40723154], [40523113, <span>40623252, </span>40723101, 40723103, 40723107, 40723114, 40723119, 40723122, 40723124, 40723125, 40723152, 40723155]]</p>
<p><a href="http://mde.tw/dartpad/?id=69c0bc82210ce46f0220d40903a76a43">排序程式</a></p>
<h4>cad 2b 分組結果</h4>
<p>====================<br/> 第 1 組成員:<br/> <a href="https://github.com/s40723212/cad2019">40723212 倉儲</a> | <a href="https://s40723212.github.io/cad2019">40723212 網站</a><br/> <a href="https://github.com/s40723222/cad2019">40723222 倉儲</a> | <a href="https://s40723222.github.io/cad2019">40723222 網站</a><br/> <a href="https://github.com/s40723223/cad2019">40723223 倉儲</a> | <a href="https://s40723223.github.io/cad2019">40723223 網站</a><br/> <a href="https://github.com/s40723225/cad2019">40723225 倉儲</a> | <a href="https://s40723225.github.io/cad2019">40723225 網站</a><br/> <a href="https://github.com/s40723227/cad2019">40723227 倉儲</a> | <a href="https://s40723227.github.io/cad2019">40723227 網站</a><br/> <a href="https://github.com/s40723230/cad2019">40723230 倉儲</a> | <a href="https://s40723230.github.io/cad2019">40723230 網站</a><br/> <a href="https://github.com/s40723234/cad2019">40723234 倉儲</a> | <a href="https://s40723234.github.io/cad2019">40723234 網站</a><br/> <a href="https://github.com/s40723244/cad2019">40723244 倉儲</a> | <a href="https://s40723244.github.io/cad2019">40723244 網站</a><br/> <a href="https://github.com/s40723249/cad2019">40723249 倉儲</a> | <a href="https://s40723249.github.io/cad2019">40723249 網站</a><br/> <a href="https://github.com/s40732331/cad2019">40732331 倉儲</a> | <a href="https://s40732331.github.io/cad2019">40732331 網站</a><br/> ====================<br/> 第 2 組成員:<br/> <a href="https://github.com/s40723205/cad2019">40723205 倉儲</a> | <a href="https://s40723205.github.io/cad2019">40723205 網站</a><br/> <a href="https://github.com/s40723221/cad2019">40723221 倉儲</a> | <a href="https://s40723221.github.io/cad2019">40723221 網站</a><br/> <a href="https://github.com/s40723224/cad2019">40723224 倉儲</a> | <a href="https://s40723224.github.io/cad2019">40723224 網站</a><br/> <a href="https://github.com/s40723228/cad2019">40723228 倉儲</a> | <a href="https://s40723228.github.io/cad2019">40723228 網站</a><br/> <a href="https://github.com/s40723229/cad2019">40723229 倉儲</a> | <a href="https://s40723229.github.io/cad2019">40723229 網站</a><br/> <a href="https://github.com/s40723235/cad2019">40723235 倉儲</a> | <a href="https://s40723235.github.io/cad2019">40723235 網站</a><br/> <a href="https://github.com/s40723240/cad2019">40723240 倉儲</a> | <a href="https://s40723240.github.io/cad2019">40723240 網站</a><br/> <a href="https://github.com/s40723246/cad2019">40723246 倉儲</a> | <a href="https://s40723246.github.io/cad2019">40723246 網站</a><br/> <a href="https://github.com/s40723247/cad2019">40723247 倉儲</a> | <a href="https://s40723247.github.io/cad2019">40723247 網站</a><br/> <a href="https://github.com/s40723250/cad2019">40723250 倉儲</a> | <a href="https://s40723250.github.io/cad2019">40723250 網站</a><br/> ====================<br/> 第 3 組成員:<br/> <a href="https://github.com/s40723203/cad2019">40723203 倉儲</a> | <a href="https://s40723203.github.io/cad2019">40723203 網站</a><br/> <a href="https://github.com/s40723206/cad2019">40723206 倉儲</a> | <a href="https://s40723206.github.io/cad2019">40723206 網站</a><br/> <a href="https://github.com/s40723208/cad2019">40723208 倉儲</a> | <a href="https://s40723208.github.io/cad2019">40723208 網站</a><br/> <a href="https://github.com/s40723209/cad2019">40723209 倉儲</a> | <a href="https://s40723209.github.io/cad2019">40723209 網站</a><br/> <a href="https://github.com/s40723214/cad2019">40723214 倉儲</a> | <a href="https://s40723214.github.io/cad2019">40723214 網站</a><br/> <a href="https://github.com/s40723233/cad2019">40723233 倉儲</a> | <a href="https://s40723233.github.io/cad2019">40723233 網站</a><br/> <a href="https://github.com/s40723238/cad2019">40723238 倉儲</a> | <a href="https://s40723238.github.io/cad2019">40723238 網站</a><br/> <a href="https://github.com/s40723239/cad2019">40723239 倉儲</a> | <a href="https://s40723239.github.io/cad2019">40723239 網站</a><br/> <a href="https://github.com/s40723241/cad2019">40723241 倉儲</a> | <a href="https://s40723241.github.io/cad2019">40723241 網站</a><br/> <a href="https://github.com/s40739214/cad2019">40739214 倉儲</a> | <a href="https://s40739214.github.io/cad2019">40739214 網站</a><br/> ====================<br/> 第 4 組成員:<br/> <a href="https://github.com/s40723201/cad2019">40723201 倉儲</a> | <a href="https://s40723201.github.io/cad2019">40723201 網站</a><br/> <a href="https://github.com/s40723204/cad2019">40723204 倉儲</a> | <a href="https://s40723204.github.io/cad2019">40723204 網站</a><br/> <a href="https://github.com/s40723213/cad2019">40723213 倉儲</a> | <a href="https://s40723213.github.io/cad2019">40723213 網站</a><br/> <a href="https://github.com/s40723215/cad2019">40723215 倉儲</a> | <a href="https://s40723215.github.io/cad2019">40723215 網站</a><br/> <a href="https://github.com/s40723218/cad2019">40723218 倉儲</a> | <a href="https://s40723218.github.io/cad2019">40723218 網站</a><br/> <a href="https://github.com/s40723219/cad2019">40723219 倉儲</a> | <a href="https://s40723219.github.io/cad2019">40723219 網站</a><br/> <a href="https://github.com/s40723237/cad2019">40723237 倉儲</a> | <a href="https://s40723237.github.io/cad2019">40723237 網站</a><br/> <a href="https://github.com/s40723242/cad2019">40723242 倉儲</a> | <a href="https://s40723242.github.io/cad2019">40723242 網站</a><br/> <a href="https://github.com/s40723243/cad2019">40723243 倉儲</a> | <a href="https://s40723243.github.io/cad2019">40723243 網站</a><br/> <a href="https://github.com/s40723245/cad2019">40723245 倉儲</a> | <a href="https://s40723245.github.io/cad2019">40723245 網站</a><br/> ====================<br/> 第 5 組成員:<br/> <a href="https://github.com/40523252/cad2019">40523252 倉儲</a> | <a href="https://40523252.github.io/cad2019">40523252 網站</a><br/> <a href="https://github.com/s40723207/cad2019">40723207 倉儲</a> | <a href="https://s40723207.github.io/cad2019">40723207 網站</a><br/> <a href="https://github.com/s40723210/cad2019">40723210 倉儲</a> | <a href="https://s40723210.github.io/cad2019">40723210 網站</a><br/> <a href="https://github.com/s40723216/cad2019">40723216 倉儲</a> | <a href="https://s40723216.github.io/cad2019">40723216 網站</a><br/> <a href="https://github.com/s40723226/cad2019">40723226 倉儲</a> | <a href="https://s40723226.github.io/cad2019">40723226 網站</a><br/> <a href="https://github.com/s40723232/cad2019">40723232 倉儲</a> | <a href="https://s40723232.github.io/cad2019">40723232 網站</a><br/> <a href="https://github.com/s40723236/cad2019">40723236 倉儲</a> | <a href="https://s40723236.github.io/cad2019">40723236 網站</a><br/> <a href="https://github.com/s40732319/cad2019">40732319 倉儲</a> | <a href="https://s40732319.github.io/cad2019">40732319 網站</a></p>
<p><br/> [[40723212, 40723222, 40723223, 40723225, 40723227, 40723230, 40723234, 40723244, 40723249, 40732331], [40723205, 40723221, 40723224, 40723228, 40723229, 40723235, 40723240, 40723246, 40723247, 40723250], [40723203, 40723206, 40723208, 40723209, 40723214, 40723233, 40723238, 40723239, 40723241, 40739214], [40723201, 40723204, 40723213, 40723215, 40723218, 40723219, 40723237, 40723242, 40723243, 40723245], [40523252, 40723207, 40723210, 40723216, 40723226, 40723232, 40723236, 40732319]]</p><h2>Task1</h2>
<p>參數式繪圖軟體 Solvespace 編譯、零組件繪圖與應用.</p>
<p style="padding-left: 30px;">利用 <a href="https://drive.google.com/file/d/1fxMdqdCoCL__O1IpZ-Sv-A_4-c77Wx4E/view?usp=sharing">2019Fall可攜套件.7z</a><span> 學習如何完成 <a href="https://github.com/solvespace/solvespace">https://github.com/solvespace/solvespace</a> 原始碼的編譯, 並透過 <a href="http://solvespace.com/">http://solvespace.com</a> 學習如何建立 <a href="https://github.com/mdecourse/mocad/files/3583773/web_vrep2.zip">web_rep2.zip</a> 中所需的行走車.</span></p>
<p style="padding-left: 30px;"><span>其中必須將所建立的零組件轉入 <a href="https://drive.google.com/file/d/1cZFSsLEoGOBYojzKzFEf4YH2l--pbS-9/view?usp=sharing">V-rep 3.6.1 rev 4.7z</a><span> 進行運動組立後, 以 Lua 或 Python 進行控制.</span></span></p>
<p style="padding-left: 30px;"><span><span>網際 V-rep 模型控制: <a href="https://github.com/mdecourse/mocad/files/3583773/web_vrep2.zip">web_vrep2.zip</a> (<a href="/downloads/web_vrep2.zip">local</a>)</span></span></p>
<p><span><span><img alt="" height="285" src="/images/vrep_two_wheeler.png" width="530"/></span></span></p>
<p><span><span>app.py</span></span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from flask import Flask, render_template, redirect
from vrep_linefollower import VrepLineFollower

line_follower = VrepLineFollower()

app = Flask(__name__)

@app.route("/")
def index():
  return render_template('controls.html')

@app.route('/do/&lt;direction&gt;')
def do(direction):
  global line_follower
  line_follower.to_direction(direction)
  return redirect('/')


if __name__ == '__main__':
  app.run(host='127.0.0.1')
</pre>
<p>vrep_linefollower.py</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import vrep

class VrepLineFollower:
  def __init__(self):
    vrep.simxFinish(-1) # just in case, close all opened connections
    self.clientID = vrep.simxStart('127.0.0.1', 19997, True, True, 5000, 5)

    self.wheelRadius = 0.027
    self.linearVelocityLeft  = 0.1
    self.linearVelocityRight = 0.1

    # vectors [left, right]
    self.direction_v = {
     'up':    [ 0.01,  0.01],
     'down':  [-0.01, -0.01],
     'left':  [-0.01,  0.01],
     'right': [ 0.01, -0.01]
    }

    res, self.leftJointDynamic  = vrep.simxGetObjectHandle(self.clientID, "DynamicLeftJoint",  vrep.simx_opmode_oneshot_wait)
    res, self.rightJointDynamic = vrep.simxGetObjectHandle(self.clientID, "DynamicRightJoint", vrep.simx_opmode_oneshot_wait)

  # direction = 'up' | 'down' | 'left' | 'right'
  def to_direction(self, direction):
    direction_vector = self.direction_v[direction]
    self.linearVelocityLeft  += direction_vector[0]
    self.linearVelocityRight += direction_vector[1]
    self.set_motors()

  # private
  def set_motors(self):
    t_left  = self.linearVelocityLeft  / self.wheelRadius
    t_right = self.linearVelocityRight / self.wheelRadius
    vrep.simxSetJointTargetVelocity(self.clientID, self.leftJointDynamic,  t_left,  vrep.simx_opmode_oneshot_wait)
    vrep.simxSetJointTargetVelocity(self.clientID, self.rightJointDynamic, t_right, vrep.simx_opmode_oneshot_wait)

</pre>
<p></p><h3>Solvespace 編譯</h3>
<h4>分組作業:</h4>
<p style="padding-left: 30px;">請各組組員分別完成 Solvespace 編譯流程後, 建立一個帶有字幕說明的導引影片, 上傳至 Youtube 並內嵌至各分組網站中.</p>
<h4>下載可攜程式系統:</h4>
<p style="padding-left: 30px;"><a href="https://drive.google.com/file/d/1fxMdqdCoCL__O1IpZ-Sv-A_4-c77Wx4E/view?usp=sharing">2019Fall可攜套件.7z</a></p>
<h4>參考資料:</h4>
<p style="padding-left: 30px;"><a href="https://2019wcm.blogspot.com/2019/03/msys2-solvespace.html">https://2019wcm.blogspot.com/2019/03/msys2-solvespace.html</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/solvespace/solvespace">https://github.com/solvespace/solvespace</a></p>
<h4>編譯步驟:</h4>
<p>先將 Y:\portablegit\bin\sh.exe 改名為 sh_rename_for_solvespace.exe (透過 MSYS2 執行 shell 指令, 而非 portablegit 中的 sh.exe)</p>
<p>git version 查驗 git 版本</p>
<p>git 2.13 版本以上, 可以使用下列 git clone <span>--recurse-submodules 取得所有子模組資料</span></p>
<p style="padding-left: 30px;">git clone --recurse-submodules https://github.com/solvespace/solvespace.git solvespace</p>
<p>上述指令同:</p>
<p style="padding-left: 30px;">git clone <span><a href="https://github.com/solvespace/solvespace.git">https://github.com/solvespace/solvespace.git</a> </span></p>
<p style="padding-left: 30px;"><span>cd solvespace</span></p>
<p style="padding-left: 30px;"><span>git submodule init</span></p>
<p style="padding-left: 30px;"><span>git submodule update</span></p>
<p>edit Y:\tmp\solvespace\extlib\angle\CMakeLists.txt comment out line 713 and 714</p>
<p>#list(APPEND ANGLE_DEFINITIONS<br/>#"-DANGLE_PRELOADED_D3DCOMPILER_MODULE_NAMES={ \"d3dcompiler_47.dll\", \"d3dcompiler_46.dll\", \"d3dcompiler_43.dll\" }")<br/>endif()</p>
<p>接著需要手動進行 libpng.dll.a 的編譯, 並改名為 libpng_static.a, 並放到編譯系統的 lib 目錄中 (即隨身系統的 msys64\mingw64\lib 目錄):</p>
<p>cd solvespace</p>
<p>cd extlib</p>
<p>cd libpng</p>
<p>mkdir build</p>
<p>cd build</p>
<p>cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release<br/>mingw32-make</p>
<p>(mingw32-make -Wl,-static)</p>
<p>rename libpng.dll.a to libpng_static.a and copy to Y:\msys64\mingw64\lib</p>
<p>接著回到 solvespace 原始碼目錄, 建立 build 目錄後進入 build 目錄, 執行:</p>
<p><span>cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release</span><br/><span>mingw32-make</span></p>
<p><span>編譯完成後, 可以在 build\bin 目錄中建立 solvespace.exe, 配合相關 dll 檔案後, 即可執行.</span></p>
<p><span><a href="https://drive.google.com/open?id=1GYB2i5ESpPTrySMU9EUmN80bRcAe2CZL">下載 Solvesapce.exe 所需的 dlls</a> (登入 @gm 後下載)</span></p>
<p><span><a href="https://drive.google.com/open?id=1TCvPaqG7-m_pGV4mNlwUBwc1lGqteCJq">下載官方使用 Visual Studio 編譯的 Solvespace.exe</a> (登入 @gm 後下載)</span></p>
<p><a href="https://drive.google.com/open?id=16bLBcVUXWW_nQ1ki-Mtsox1DsSI-2gIj"><span>下載 Solvespace </span>986da7d 版本</a></p>
<p><a href="https://drive.google.com/open?id=18R3erVkzKdvJmQ-ni7YzSb_izwGUkkeo">下載 Solvespace 22e4011 版本</a></p>
<h4>Solvespace C++ 程式延伸</h4>
<p>位於 exposed 目錄中有一個範例 CDemo.c</p>
<pre class="brush:cpp;auto-links:false;toolbar:false" contenteditable="false">/*-----------------------------------------------------------------------------
 * Some sample code for slvs.dll. We draw some geometric entities, provide
 * initial guesses for their positions, and then constrain them. The solver
 * calculates their new positions, in order to satisfy the constraints.
 *
 * Copyright 2008-2013 Jonathan Westhues.
 *---------------------------------------------------------------------------*/
#ifdef WIN32
#   include &lt;windows.h&gt;
#endif
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;

#include &lt;slvs.h&gt;

static Slvs_System sys;

static void *CheckMalloc(size_t n)
{
    void *r = malloc(n);
    if(!r) {
        printf("out of memory!\n");
        exit(-1);
    }
    return r;
}

/*-----------------------------------------------------------------------------
 * An example of a constraint in 3d. We create a single group, with some
 * entities and constraints.
 *---------------------------------------------------------------------------*/
void Example3d()
{
    /* This will contain a single group, which will arbitrarily number 1. */
    Slvs_hGroup g = 1;

    /* A point, initially at (x y z) = (10 10 10) */
    sys.param[sys.params++] = Slvs_MakeParam(1, g, 10.0);
    sys.param[sys.params++] = Slvs_MakeParam(2, g, 10.0);
    sys.param[sys.params++] = Slvs_MakeParam(3, g, 10.0);
    sys.entity[sys.entities++] = Slvs_MakePoint3d(101, g, 1, 2, 3);
    /* and a second point at (20 20 20) */
    sys.param[sys.params++] = Slvs_MakeParam(4, g, 20.0);
    sys.param[sys.params++] = Slvs_MakeParam(5, g, 20.0);
    sys.param[sys.params++] = Slvs_MakeParam(6, g, 20.0);
    sys.entity[sys.entities++] = Slvs_MakePoint3d(102, g, 4, 5, 6);
    /* and a line segment connecting them. */
    sys.entity[sys.entities++] = Slvs_MakeLineSegment(200, g,
                                        SLVS_FREE_IN_3D, 101, 102);

    /* The distance between the points should be 30.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            1, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            SLVS_FREE_IN_3D,
                                            30.0,
                                            101, 102, 0, 0);

    /* Let's tell the solver to keep the second point as close to constant
     * as possible, instead moving the first point. */
    sys.dragged[0] = 4;
    sys.dragged[1] = 5;
    sys.dragged[2] = 6;

    /* Now that we have written our system, we solve. */
    Slvs_Solve(&amp;sys, g);

    if(sys.result == SLVS_RESULT_OKAY) {
        printf("okay; now at (%.3f %.3f %.3f)\n"
               "             (%.3f %.3f %.3f)\n",
                sys.param[0].val, sys.param[1].val, sys.param[2].val,
                sys.param[3].val, sys.param[4].val, sys.param[5].val);
        printf("%d DOF\n", sys.dof);
    } else {
        printf("solve failed");
    }
}

/*-----------------------------------------------------------------------------
 * An example of a constraint in 2d. In our first group, we create a workplane
 * along the reference frame's xy plane. In a second group, we create some
 * entities in that group and dimension them.
 *---------------------------------------------------------------------------*/
void Example2d()
{
    Slvs_hGroup g;
    double qw, qx, qy, qz;

    g = 1;
    /* First, we create our workplane. Its origin corresponds to the origin
     * of our base frame (x y z) = (0 0 0) */
    sys.param[sys.params++] = Slvs_MakeParam(1, g, 0.0);
    sys.param[sys.params++] = Slvs_MakeParam(2, g, 0.0);
    sys.param[sys.params++] = Slvs_MakeParam(3, g, 0.0);
    sys.entity[sys.entities++] = Slvs_MakePoint3d(101, g, 1, 2, 3);
    /* and it is parallel to the xy plane, so it has basis vectors (1 0 0)
     * and (0 1 0). */
    Slvs_MakeQuaternion(1, 0, 0,
                        0, 1, 0, &amp;qw, &amp;qx, &amp;qy, &amp;qz);
    sys.param[sys.params++] = Slvs_MakeParam(4, g, qw);
    sys.param[sys.params++] = Slvs_MakeParam(5, g, qx);
    sys.param[sys.params++] = Slvs_MakeParam(6, g, qy);
    sys.param[sys.params++] = Slvs_MakeParam(7, g, qz);
    sys.entity[sys.entities++] = Slvs_MakeNormal3d(102, g, 4, 5, 6, 7);

    sys.entity[sys.entities++] = Slvs_MakeWorkplane(200, g, 101, 102);

    /* Now create a second group. We'll solve group 2, while leaving group 1
     * constant; so the workplane that we've created will be locked down,
     * and the solver can't move it. */
    g = 2;
    /* These points are represented by their coordinates (u v) within the
     * workplane, so they need only two parameters each. */
    sys.param[sys.params++] = Slvs_MakeParam(11, g, 10.0);
    sys.param[sys.params++] = Slvs_MakeParam(12, g, 20.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(301, g, 200, 11, 12);

    sys.param[sys.params++] = Slvs_MakeParam(13, g, 20.0);
    sys.param[sys.params++] = Slvs_MakeParam(14, g, 10.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(302, g, 200, 13, 14);

    /* And we create a line segment with those endpoints. */
    sys.entity[sys.entities++] = Slvs_MakeLineSegment(400, g,
                                        200, 301, 302);

    /* Now three more points. */
    sys.param[sys.params++] = Slvs_MakeParam(15, g, 100.0);
    sys.param[sys.params++] = Slvs_MakeParam(16, g, 120.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(303, g, 200, 15, 16);

    sys.param[sys.params++] = Slvs_MakeParam(17, g, 120.0);
    sys.param[sys.params++] = Slvs_MakeParam(18, g, 110.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(304, g, 200, 17, 18);

    sys.param[sys.params++] = Slvs_MakeParam(19, g, 115.0);
    sys.param[sys.params++] = Slvs_MakeParam(20, g, 115.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(305, g, 200, 19, 20);

    /* And arc, centered at point 303, starting at point 304, ending at
     * point 305. */
    sys.entity[sys.entities++] = Slvs_MakeArcOfCircle(401, g, 200, 102,
                                    303, 304, 305);

    /* Now one more point, and a distance */
    sys.param[sys.params++] = Slvs_MakeParam(21, g, 200.0);
    sys.param[sys.params++] = Slvs_MakeParam(22, g, 200.0);
    sys.entity[sys.entities++] = Slvs_MakePoint2d(306, g, 200, 21, 22);

    sys.param[sys.params++] = Slvs_MakeParam(23, g, 30.0);
    sys.entity[sys.entities++] = Slvs_MakeDistance(307, g, 200, 23);

    /* And a complete circle, centered at point 306 with radius equal to
     * distance 307. The normal is 102, the same as our workplane. */
    sys.entity[sys.entities++] = Slvs_MakeCircle(402, g, 200,
                                    306, 102, 307);


    /* The length of our line segment is 30.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            1, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            30.0,
                                            301, 302, 0, 0);

    /* And the distance from our line segment to the origin is 10.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            2, g,
                                            SLVS_C_PT_LINE_DISTANCE,
                                            200,
                                            10.0,
                                            101, 0, 400, 0);
    /* And the line segment is vertical. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            3, g,
                                            SLVS_C_VERTICAL,
                                            200,
                                            0.0,
                                            0, 0, 400, 0);
    /* And the distance from one endpoint to the origin is 15.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            4, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            15.0,
                                            301, 101, 0, 0);
#if 0
    /* And same for the other endpoint; so if you add this constraint then
     * the sketch is overconstrained and will signal an error. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            5, g,
                                            SLVS_C_PT_PT_DISTANCE,
                                            200,
                                            18.0,
                                            302, 101, 0, 0);
#endif /* 0 */

    /* The arc and the circle have equal radius. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            6, g,
                                            SLVS_C_EQUAL_RADIUS,
                                            200,
                                            0.0,
                                            0, 0, 401, 402);
    /* The arc has radius 17.0 units. */
    sys.constraint[sys.constraints++] = Slvs_MakeConstraint(
                                            7, g,
                                            SLVS_C_DIAMETER,
                                            200,
                                            17.0*2,
                                            0, 0, 401, 0);

    /* If the solver fails, then ask it to report which constraints caused
     * the problem. */
    sys.calculateFaileds = 1;

    /* And solve. */
    Slvs_Solve(&amp;sys, g);

    if(sys.result == SLVS_RESULT_OKAY) {
        printf("solved okay\n");
        printf("line from (%.3f %.3f) to (%.3f %.3f)\n",
                sys.param[7].val, sys.param[8].val,
                sys.param[9].val, sys.param[10].val);

        printf("arc center (%.3f %.3f) start (%.3f %.3f) finish (%.3f %.3f)\n",
                sys.param[11].val, sys.param[12].val,
                sys.param[13].val, sys.param[14].val,
                sys.param[15].val, sys.param[16].val);

        printf("circle center (%.3f %.3f) radius %.3f\n",
                sys.param[17].val, sys.param[18].val,
                sys.param[19].val);
        printf("%d DOF\n", sys.dof);
    } else {
        int i;
        printf("solve failed: problematic constraints are:");
        for(i = 0; i &lt; sys.faileds; i++) {
            printf(" %d", sys.failed[i]);
        }
        printf("\n");
        if(sys.result == SLVS_RESULT_INCONSISTENT) {
            printf("system inconsistent\n");
        } else {
            printf("system nonconvergent\n");
        }
    }
}

int main()
{
    sys.param      = CheckMalloc(50*sizeof(sys.param[0]));
    sys.entity     = CheckMalloc(50*sizeof(sys.entity[0]));
    sys.constraint = CheckMalloc(50*sizeof(sys.constraint[0]));

    sys.failed  = CheckMalloc(50*sizeof(sys.failed[0]));
    sys.faileds = 50;

    /*Example3d();*/
    for(;;) {
        Example2d();
        sys.params = sys.constraints = sys.entities = 0;
        break;
    }
    return 0;
}

</pre>
<p>編譯 CDemo.c 流程:</p>
<p>首先將 solvespace/include/slvs.h 複製到 Y:\msys64\mingw64\include</p>
<p>接著將先前 build 目錄中的 libslvs.dll 複製到 Y:\msys64\mingw64\lib</p>
<p>然後在 solvespace\exposed\ 目錄中建立 build 目錄, 然後以指令模式進入此一 build 目錄後, 執行:</p>
<p><span>cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release</span><br/><span>mingw32-make</span></p>
<p><span>就可以完成 CDemo.exe 的編譯, 必須配合 libslvs.dll 與 libwinpthread-1.dll 執行.</span></p>
<p><span>設計原理:</span></p>
<p style="padding-left: 30px;"><a href="https://github.com/solvespace/solvespace/commit/67139236fc0b63e06eaa1efa8fe0022df5612bd2">Solvespace 首次提交到 Github</a></p>
<p style="padding-left: 30px;"><a href="http://solvespace.com/forum.pl?action=viewthread&amp;parent=1893&amp;tt=1493369400">來源</a>, <a href="/downloads/Watertight Trimmed NURBS.pdf">Watertight Trimmed NURBS.pdf</a></p>
<p style="padding-left: 30px;"><span>SolveSpace represents curves and surfaces in a form equivalent to NURBS, by their rational polynomial parametric equations. That can represent a lot of geometry exactly, but not everything (for example, not the general intersection curve of two cylinders). When no exact representation of that form exists, SolveSpace approximates. This is the same approach that commercial libraries (Parasolid, Solids++, etc.) take.</span></p>
<p style="padding-left: 30px;"><span>There's just a lot of cases, and a lot of work to test that you've covered them all. As far as I know, the highest-quality commercial libraries get their robustness mostly from exhaustive enumeration of special cases, or trying multiple differently-broken algorithms until something works, and less from anything that's mathematically interesting in isolation.</span></p>
<p style="padding-left: 30px;"><span>A trimming curve is typically a degree-three NURBS curve defined in the parameter domain of a NURBS surface. The image of such a trimming curve on a bicubic patch (i.e., the curve on the bicubic patch in R3 that the trimming curve maps to) is degree ≤ 18 and algebraic genus zero. However, a generic intersection curve of two bicubic surfaces is degree 324 in R3 and algebraic genus 433. Hence, intersection curves can only be approximated by parametric trimming curves.</span></p>
<p><span></span></p><h3>Solvespace 操作</h3>
<h4>分組作業:</h4>
<p style="padding-left: 30px;">請各組在了解如何利用 Solvespace 執行零組件繪圖後, 以協同模式製作一個帶有中文說明字幕的 Solvespace 零組件操作導引影片, 並上傳至 Youtube 且內嵌至各分組網站.</p>
<p><a href="/downloads/SolveSpace - Learning Guide.pdf">Solvespace Learning Guide.pdf</a></p>
<p><a href="https://www.youtube.com/watch?v=1Em_XESnqUM&amp;list=PLEvJVXu3VfGMSOdpA0jrGRzoM7NlNOl5s">https://www.youtube.com/watch?v=1Em_XESnqUM&amp;list=PLEvJVXu3VfGMSOdpA0jrGRzoM7NlNOl5s</a></p>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/1Em_XESnqUM" width="560"></iframe></p>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/cZzn9Z2j2cQ" width="560"></iframe></p>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/13qKQ9BHXCM" width="560"></iframe> <iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/62AUqGLomfI" width="560"></iframe> <iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/7HtF2MBwO-o" width="560"></iframe> <iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/X9byxcHuins" width="560"></iframe> <iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/3Sw4YHZ9DzQ" width="560"></iframe> <iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/d5KxO-ZkKpY" width="560"></iframe> <iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/oAJIKC24g5Y" width="560"></iframe> <iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/19XLvZtN27w" width="560"></iframe> <iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/mvJuwv-1Qic" width="560"></iframe> <iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/XTHkXNTtrZs" width="560"></iframe> <iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/dr1xAhgsm8w" width="560"></iframe> <iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/U6-eAfch-So" width="560"></iframe></p><h3>機構設計與模擬</h3>
<h4>參考資料:</h4>
<p style="padding-left: 30px;">2000 - <a href="/downloads/The A-Design Invention Machine.pdf">The A-Design Invention Machine.pdf</a></p>
<p style="padding-left: 30px;">2001 - <a href="/downloads/OPTIMAL.SYNTHESIS.OF.PLANAR.FIVE-LINK.MECHANISMS.FOR.THE.PRODUCTION.OF.NONLINEAR.MECHANICAL.ADVANTAGE.pdf">OPTIMAL.SYNTHESIS.OF.PLANAR.FIVE-LINK.MECHANISMS.FOR.THE.PRODUCTION.OF.NONLINEAR.MECHANICAL.ADVANTAGE.pdf</a></p>
<p style="padding-left: 30px;">2008 - <a href="/downloads/computer-aided.mechanism.design-now.and.the.future.pdf">computer-aided.mechanism.design-now.and.the.future.pdf</a></p>
<p style="padding-left: 30px;">2010 - <a href="/downloads/A graph grammar scheme for representing and evaluating planar mechanisms.pdf">A graph grammar scheme for representing and evaluating planar mechanisms.pdf</a></p>
<p style="padding-left: 30px;">2011 - <a href="https://github.com/mdecourse/pmks_firefox">https://github.com/mdecourse/pmks_firefox</a></p>
<p style="padding-left: 30px;">2011 -  <a href="/downloads/2011-_Computer-Based_design_synthesis_research-_An_overview.pdf">Computer-Based_design_synthesis_research-_An_overview.pdf</a></p>
<p style="padding-left: 30px;">2014 - <a href="/downloads/Automated design of planar mechanisms_2014.pdf">Automated design of planar mechanisms_2014.pdf</a></p>
<p style="padding-left: 30px;">2015 - <a href="/downloads/Automated Synthesis of Planar Mechanisms with Revolute Prismatic and Pin-In-Slot Joints.pdf">Automated Synthesis of Planar Mechanisms with Revolute Prismatic and Pin-In-Slot Joints.pdf</a></p>
<p style="padding-left: 30px;">2015 - <a href="/downloads/Automatic.Structural.Synthesis.of.Planar.Mechanisms.and.Its.Application.to.Creative.Design.pdf">Automatic.Structural.Synthesis.of.Planar.Mechanisms.and.Its.Application.to.Creative.Design.pdf</a></p>
<p style="padding-left: 30px;">2016 - <a href="https://dl.acm.org/citation.cfm?id=2985709">M.Sketch: Prototyping Tool for Linkage-Based Mechanism Design</a></p>
<p style="padding-left: 30px;">2016 - <a href="https://drive.google.com/drive/folders/1oDZwPXf49uj3tvBBINC0APO5JUvUA91I">M.Sketch</a> (登入 @gm 後下載)</p>
<p style="padding-left: 30px;">2018 - <a href="/downloads/Creative.mechanism.design.of.magnetic.gears.integrated.with.continuously.variable.transmissions.pdf">Creative.mechanism.design.of.magnetic.gears.integrated.with.continuously.variable.transmissions.pdf</a></p>
<p style="padding-left: 30px;">2019 - <a href="/downloads/PMKS_plus.pdf">PMKS_plus.pdf</a> (<a href="https://mde.tw/cad2019/downloads/pmksplus/">PMKS+</a>)</p><h3>GCS</h3>
<p>Solvespace 的 Geometric Constraint Solver 程式庫原始碼:</p>
<p>constraint.cpp:</p>
<p style="padding-left: 30px;">Implementation of the Constraint menu, to create new constraints in the sketch.</p>
<p>constrainteq.cpp</p>
<p style="padding-left: 30px;">Given a constraint, generate one or more equations in our symbolic algebra system to represent that constraint; also various geometric helper functions for that.</p>
<p>entity.cpp</p>
<p style="padding-left: 30px;">The implementation of our entities in the symbolic algebra system, methods to return a symbolic representation of the entity (line by its endpoints, circle by center and radius, etc.).</p>
<p>expr.cpp</p>
<p style="padding-left: 30px;">The symbolic algebra system used to write our constraint equations; routines to build expressions in software or from a user-provided string, and to compute the partial derivatives that we'll use when write our Jacobian matrix.</p>
<p>lib.cpp</p>
<p style="padding-left: 30px;">A library wrapper around SolveSpace, to permit someone to use its constraint solver without coupling their program too much to SolveSpace's internals.</p>
<p>system.cpp</p>
<p style="padding-left: 30px;">Once we've written our constraint equations in the symbolic algebra system, these routines linearize them, and solve by a modified Newton's method. This also contains the routines to detect non-convergence or inconsistency, and report diagnostics to the user.</p>
<p>透過 <a href="https://github.com/KmolYuan/Pyslvs-UI">https://github.com/KmolYuan/Pyslvs-UI</a> 取得 GCS 動態程式庫:</p>
<p style="padding-left: 30px;">git clone <a href="https://github.com/KmolYuan/Pyslvs-UI">https://github.com/KmolYuan/Pyslvs-UI</a>.git </p>
<p style="padding-left: 30px;">cd Pyslvs-UI</p>
<p style="padding-left: 30px;">git submodule update --init --recursive</p>
<p style="padding-left: 30px;">mingw32-make build-kernel</p><h2>Task2</h2>
<h4>分組作業:</h4>
<p style="padding-left: 30px;">請各組在實際安裝與操作 Inventor 2019、NX12、Solidworks 2017 Solidworks 2017 、Creo 6.0 與 Onshape 之後, 以協同模式製作一個帶有中文字幕的影片, 說明各套系統的安裝、認證設定與基本零組件繪圖功能後, 上傳至 Youtube 並內嵌至各分組網站中.</p>
<p style="padding-left: 30px;"><a href="/downloads/NX12.0.2_release_notes.pdf">NX12.0.2_release_notes.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/NX12_Sketching.pdf">NX12_Sketching.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/NX 12_CAD_新功能介紹.pdf">NX 12_CAD_新功能介紹.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/NX 12_CAM_新功能介紹.pdf">NX 12_CAM_新功能介紹.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/NX-12-for-Engineering-Design.pdf">NX 12 For Engineering Design.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/nx_flomcad_flotherm_macro.pdf">nx_flomcad_flotherm_macro.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/SIEMENS_PLM_SOFTWARE_polarion_today.pdf">SIEMENS_PLM_SOFTWARE_polarion_today.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/SIEMENS_AG_implementation_of_techpub_studio_at_siemens_pg.pdf">SIEMENS_AG_implementation_of_techpub_studio_at_siemens_pg.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/SIEMENS_PLM_delving_into_electro_mechanical_integration_for_nx_users.pdf">SIEMENS_PLM_delving_into_electro_mechanical_integration_for_nx_users.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/SIEMENS_PLM_mechatronics_concept_designer.pdf">SIEMENS_PLM_mechatronics_concept_designer.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/c01_NX_12.0_eval.pdf">c01_NX_12.0_eval.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/c15_NX_12.0_fdwd.pdf">c15_NX_12.0_fdwd.pdf</a></p>
<p>MCAD 套件安裝與設定, 零組件繪圖、轉檔與 CAE 工程分析.</p>
<p style="padding-left: 30px;">請所有組員根據 <a href="https://2019wcm.blogspot.com/2019/07/autodesk-inventor-professional.html">https://2019wcm.blogspot.com/2019/07/autodesk-inventor-professional.html</a> 中的說明, 在個人的桌上型電腦或筆電上安裝 AutoDesk Inventor Professional 2019. 並將詳細安裝與設定過程加以整理, 放入個人網頁中.</p>
<p style="padding-left: 30px;">參考電子書:</p>
<p style="padding-left: 60px;"><a href="https://link.springer.com/book/10.1007/978-1-4842-3225-5">Learn Autodesk Inventor 2018 Basics - 3D Modeling, 2D Graphics, and Assembly Design</a></p>
<p style="padding-left: 30px;">請每位組員<span>登入 @gm 電子郵箱,<span> </span></span><a href="https://drive.google.com/file/d/1fEZtGVCXp2vtILUZZ8vTTdtYHsbBpf7j/view?usp=sharing">下載 NX 12.0.2 安裝光碟</a><span>, 或者</span><a href="https://drive.google.com/file/d/1UyDUGc2ytn-EVHCw-bNqanV6Jw11yvUg/view?usp=sharing">下載 NX12.0.2 虛擬主機板本</a><span>, 或者</span><a href="https://drive.google.com/file/d/1Ul025kwP3I1SC0aD1YEzZRcL0ZzIlO1p/view?usp=sharing">下載 NX12 可攜版本</a><span>. 以便利用 NX12 執行下列專案的零組件設計繪圖與工程分析.</span></p>
<p style="padding-left: 30px;">請每位學員參考 <a href="https://github.com/nasa-jpl/open-source-rover">https://github.com/nasa-jpl/open-source-rover</a> (提供 Solidworks 零組件檔案) 與<span> </span><a href="https://github.com/mdecourse/Sawppy_Rover">https://github.com/mdecourse/Sawppy_Rover</a> (提供<span> </span><a href="https://cad.onshape.com/documents/0c757e42f113318abade702c/w/83a3818a1aef5d4234265d9c/e/0284daee1c8866acdbcf0b9d">Onshape 零組件檔案</a>) 中的 Rover 設計, 分別利用 <span>Inventor 2019 與 NX12 進行 Rover 零組件的設計與繪圖.</span></p>
<p style="padding-left: 30px;"><span>參考電子書:</span></p>
<p style="padding-left: 60px;"><a href="https://link.springer.com/book/10.1007/978-3-319-03862-9">2015 Space Modeling with SolidWorks and NX</a></p>
<p>登入 @gm 電子郵箱後, <a href="https://drive.google.com/file/d/1MtT6W0kNAEhNZkgm3oZvAp-kREhgFPgT/view?usp=sharing">下載上述 Inventor_nx_sw_onshape_ebooks.7z</a></p>
<p><span></span><span><img alt="" height="315" src="/images/sawppy_rover_onshape.png" width="560"/></span></p>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" data-mce-fragment="1" frameborder="0" height="315" src="https://www.youtube.com/embed/acANiRFg-qA" width="560"></iframe><br/><span></span></p><h2>Task3</h2>
<h4>分組作業:</h4>
<p style="padding-left: 30px;">請各組將 Task1 所完成的行走車, 轉入 Webots, 並設法利用 Python 程式驅動行走, 完成後, 以協同模式製作一個帶有中文字幕的流程教學導引影片, 上傳至 Youtube 並內嵌至各分組網站中.</p>
<p><span>Rover 零組件轉入<a href="http://www.coppeliarobotics.com/"> V-rep</a> 與 <a href="https://cyberbotics.com/">Webots</a> 執行機電控制系統設計</span></p>
<p style="padding-left: 30px;">Webots 範例: <a href="https://www.cyberbotics.com/doc/guide/sojourner">https://www.cyberbotics.com/doc/guide/sojourner</a></p>
<p style="padding-left: 30px;">參考資料:</p>
<p style="padding-left: 60px;">登入 @gm 電子郵箱後,</p>
<p style="padding-left: 90px;">下載 <a href="https://drive.google.com/file/d/1alczEGcvayA19SA6kdV38UeU-Y5vvZGx/view?usp=sharing">Webots_reference_pdfs.7z</a></p>
<p style="padding-left: 90px;">下載 <a href="https://drive.google.com/file/d/1NpIVSnVHUWUbXP30SgOiB61-bqWcsjNz/view?usp=sharing">Webots_2012_guide.pdf</a></p>
<p style="padding-left: 90px;">下載 <a href="https://drive.google.com/file/d/18MfpW65vZngRWKE42B69AsDs9aeyKhGZ/view?usp=sharing">Vrep_reference_pdfs.7z</a></p>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" data-mce-fragment="1" frameborder="0" height="315" src="https://www.youtube.com/embed/_9d_vukS0Qg" width="560"></iframe></p><h2>Project</h2>
<h4><span>機電資整合分組專案執行</span></h4>
<p style="padding-left: 30px;">請各組參考先前已完成之<span>多段式頂球機構與循環鋼球運動系統 (例如:<span> </span><a href="https://www.youtube.com/watch?v=Zc17Azvmx9M">1</a>,<span> </span><a href="https://www.youtube.com/watch?v=1WWKgAMN5LI">2</a>,<span> </span><a href="https://www.youtube.com/watch?v=ZAGrFV1jCdk">3</a>), 每組在 V-rep 或 Webots 中建立一個鋼球運動系統站, 並</span>結合 Task2 所完成的 Rover, 以執行各站鋼球搬運<span> </span><a href="https://en.wikipedia.org/wiki/Automated_storage_and_retrieval_system">AS/RS</a><span> </span>工作, 以組為單位, 完成結合機械設計、電子感測配置、電機驅動與程式控制的機電資整合專案.</p>
<p style="padding-left: 30px;">完成後請<span>將相關過程與心得整理在分組網站, 製作一個帶有中文字幕的說明影片, 上傳至 Youtube 並內嵌至各分組網站, 過程中請利用 Blogger 網誌紀錄各階段心得, 最後再利用 Reveal 於 Week 17 進行期末分組簡報.</span></p>
<h4>Reference</h4>
<p style="padding-left: 30px;">機電資整合設計報告參考: <a href="/downloads/Mechanical%20Design%20Report%20DARPA%20BOSS%20Program.pdf">Mechanical Design Report DARPA BOSS Program.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Robotics.pdf">Robotics.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Mars%20Exploration%20Rover%20Mobility%20Assembly%20Design%20Test%20and%20Performance.pdf">Mars Exploration Rover Mobility Assembly Design Test and Performance.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Lunar%20Rover%20Motion%20Planning%20and%20Commands.pdf">Lunar Rover Motion Planning and Commands.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/The%20Challenges%20of%20Designing%20the%20Rocker-Bogie%20Suspension%20for%20the%20Mars%20Exploration%20Rover.pdf">The Challenges of Designing the Rocker-Bogie Suspension for the Mars Exploration Rover.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/Kinematic%20State%20Estimation%20For%20A%20Mars%20Rover.pdf">Kinematic State Estimation For A Mars Rover.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/ATHLETE_Scene_1_After%20Resp%20Masks.ttt.7z">ATHLETE_Scene_1_After Resp Masks.ttt.7z</a><span> </span>(V-rep Scene)</p>
<p style="padding-left: 30px;"><a href="http://mde.tw/cadp2018/content/%E5%AF%A6%E7%BF%92%E6%93%8D%E4%BD%9C.html">http://mde.tw/cadp2018/content/%E5%AF%A6%E7%BF%92%E6%93%8D%E4%BD%9C.html</a></p><h1>Reference</h1>
<h4>機電資系統整合專案</h4>
<h4>Mechanism</h4>
<p style="padding-left: 30px;">Open Chain</p>
<p style="padding-left: 60px;"><a href="https://en.wikipedia.org/wiki/Pinball">Pinball Machine</a></p>
<p style="padding-left: 60px;">Fosball Table</p>
<p style="padding-left: 60px;"><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/PgnvZV5s13c" width="560"></iframe></p>
<p style="padding-left: 30px;">Closed Chain</p>
<p style="padding-left: 60px;"><a href="https://en.wikipedia.org/wiki/Leg_mechanism">Leg Mechanism</a></p>
<p style="padding-left: 90px;"><a href="https://github.com/Rhoban/Metabot">https://github.com/Rhoban/Metabot</a></p>
<p style="padding-left: 90px;"><a href="https://github.com/poppy-project/poppy-humanoid">https://github.com/poppy-project/poppy-humanoid</a></p>
<p style="padding-left: 60px;"><a href="/downloads/A NOVEL WALKER WITH MECHANICALLY ESTABLISHED WALKING and Standing Mechanism.pdf">A NOVEL WALKER WITH MECHANICALLY ESTABLISHED WALKING and Standing Mechanism.pdf</a></p>
<p style="padding-left: 60px;"><a href="/downloads/The Design and Optimization of a Crank-Based Leg Mechanism.pdf">The Design and Optimization of a Crank-Based Leg Mechanism.pdf</a></p>
<p style="padding-left: 60px;"><a href="/downloads/A_Bipedal_Mechanical_Walker_with_Balancing_Mechani.pdf">A_Bipedal_Mechanical_Walker_with_Balancing_Mechani.pdf</a></p>
<p style="padding-left: 60px;"><a href="/downloads/Adjustable Power Modulation for a leg mechanism suitable for running.pdf">Adjustable Power Modulation for a leg mechanism suitable for running.pdf</a></p>
<p style="padding-left: 60px;">Marble Machine</p>
<p style="padding-left: 60px;"><img alt="" height="360" src="/images/marble-machine.gif" width="640"/></p>
<p style="padding-left: 60px;"><a href="https://en.wikipedia.org/wiki/Claw_crane">Claw Crane</a></p>
<p><a href="https://en.wikipedia.org/wiki/3D_printing">3D Printing</a></p>
<p><a href="https://en.wikipedia.org/wiki/Elevator">Elevator</a></p>
<p><a href="https://en.wikipedia.org/wiki/Robot">Robots</a></p>
<p style="padding-left: 30px;"><a href="https://en.wikipedia.org/wiki/Delta_robot">Delta Robot</a></p>
<p style="padding-left: 30px;"><a href="https://en.wikipedia.org/wiki/Articulated_robot">Articulated Robot</a></p>
<p style="padding-left: 60px;"><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/D-bdLSx-AzE" width="560"></iframe></p>
<p style="padding-left: 60px;">(<a href="https://hackaday.io/project/3800-3d-printable-robot-arm">https://hackaday.io/project/3800-3d-printable-robot-arm</a>)</p>
<p style="padding-left: 60px;"><a href="https://hackaday.com/2017/01/17/3d-printed-strain-wave-gear-needs-your-help/">https://hackaday.com/2017/01/17/3d-printed-strain-wave-gear-needs-your-help/</a></p>
<p style="padding-left: 60px;"><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/AzreNQiTvQE" width="560"></iframe></p>
<p style="padding-left: 60px;"><a href="https://github.com/BCN3D/BCN3D-Moveo">https://github.com/BCN3D/BCN3D-Moveo</a></p>
<p style="padding-left: 60px;"><a href="/downloads/diy_printed_robot_arm_bom.txt">diy_printed_robot_arm_bom.txt</a> (<a href="https://onedrive.live.com/view.aspx?resid=F80A154B78F5EF19!140208&amp;ithint=file%2cxlsx&amp;lor=shortUrl">source</a>)</p>
<p style="padding-left: 30px;"><a href="https://en.wikipedia.org/wiki/Mobile_robot">Mobil Robot</a></p>
<p style="padding-left: 60px;"><a href="https://linorobot.org/">https://linorobot.org/</a></p>
<p style="padding-left: 60px;">Mars Rover (火星漫遊車)</p>
<p style="padding-left: 60px;">July 4, 1997 - <a href="https://en.wikipedia.org/wiki/Sojourner_(rover)">Sojourner Rover</a> 降落火星, 漫遊車長度為 65 公分, 重量 11.5 公斤, 原始設計目標漫遊 7 日, 實際運行 85 天, </p>
<p style="padding-left: 60px;">Jan., 2004 - <a href="https://en.wikipedia.org/wiki/Mars_Exploration_Rover">Spirit and Opportunity</a> 降落火星, 漫遊車尺寸為 L 1.6 m X W 2.3m X H 1.5m, 重量 180 公斤, 原始設計目標漫遊火星日 90 天, Spirit 實際運作了 6 年 2 個月, 而 Opportunity 則持續運作了 15 年 3 個月.</p>
<p style="padding-left: 60px;">Aug. 6, 2012 (UTC) - <a href="https://en.wikipedia.org/wiki/Curiosity_(rover)">Curiosity</a> 降落火星, 漫遊車尺寸為 L 2.9m X W 2.7m X H 2.2m, 重量為 899 公斤, 原始設計預計運作 2 年, 截至 July 15, 2019 仍持續運作中.</p>
<p style="padding-left: 60px;">Mars Rover 尺寸比較:</p>
<p style="padding-left: 60px;"><img alt="" height="303" src="/images/Mars_Rover_size_comparison.jpg" width="600"/></p>
<p style="padding-left: 60px;">前方為 65 公分的 <a href="https://en.wikipedia.org/wiki/Sojourner_(rover)">Sojourner</a>, 左側為 1.6m 長的 <a href="https://en.wikipedia.org/wiki/Spirit_(rover)">Spirit</a> 與 <a href="https://en.wikipedia.org/wiki/Opportunity_(rover)">Opportunity</a> 同尺寸漫遊車, 而右側為 2.9m 長的 <a href="https://en.wikipedia.org/wiki/Curiosity_(rover)">Curiosity</a>.</p>
<p style="padding-left: 60px;">下一輛漫遊車 (<a href="https://mars.nasa.gov/mars2020/">Mars 2020 計畫</a>) 預計在 2021 年 2 月 18 日降落火星, 漫遊車尺寸 L 3m X W 2.7m X H 2.2m, 重量 1050 公斤.</p>
<p style="padding-left: 30px;"><a href="https://en.wikipedia.org/wiki/Automated_guided_vehicle">Automatic Guided Vehicle</a></p>
<p style="padding-left: 30px;"><a href="https://en.wikipedia.org/wiki/Automated_storage_and_retrieval_system">AS/RS</a></p>
<p></p><h2>Ebooks</h2>
<p>本課程所採用的兩本電子書, 第一本主要用於 Solidworks 2017 與 NX 12 執行零組件繪圖時參考, 而第二本則說明電腦輔助繪圖與設計程式發展歷史,  其中牽涉到許多套件間的開發細節與背景, 這些資料主要用於參考用.</p>
<p>1) 2015- Space Modeling with SolidWorks and NX</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-3-319-03862-9">https://link.springer.com/book/10.1007/978-3-319-03862-9</a></p>
<p>2) 2008- The Engineering Design Revolution</p>
<p style="padding-left: 30px;"><a href="/downloads/cad_history.pdf">The Engineering Design Revolution</a> (a.k.a. cad_history.pdf)</p>
<h4>導讀:</h4>
<p style="padding-left: 30px;">第一本電子書標題的所謂 Space 指的是 modeling of objects in 3D space  中的三度空間, 因此標題可以翻為: Solidworks 與 NX (套件)的(三度)空間(零組件)模擬.</p>
<p style="padding-left: 30px;">有關 Solidworks 的開發緣起, 可以參考 <a href="/downloads/cad_history.pdf">The Engineering Design Revolution</a> 書中的第十八章.</p>
<p style="padding-left: 60px;">Solidworks 的前身是 2D 概念設計套件: DesignView, 由1983 年從 MIT 機械碩士畢業的 Jon Hirschtick 於 1987 年取得資金 (150 萬美金) 後著手開發, 公司名稱為 Premise. 一開始 DesignView 就設定在當時剛萌芽的 IBM 相容個人電腦上執行. 當時一套 DesignView 商業版定價 1895 美元. </p>
<p style="padding-left: 60px;">之後 Premise 被 ComputerVision 公司併購, 1993 年<span>Jon Hirschtick 離開 ComputerVision, 隔年一月起便著手與與 Bob Zuffante, Scott Harris, Constantine Dokos 與 Tommy Li 開發 Solidworks: 一套能夠在 PC 上運作的低價 CAD 套件.</span></p>
<p style="padding-left: 60px;">1994 年 8 月 PTC 公司草創時編號 3 號的 Michael Payne 離開 PTC, 加入開發 SolidWorks 的團隊. 期間參與投資者還包括日本的 Kubota 公司.</p>
<p style="padding-left: 60px;">1995 年 10 月 Solidworks 正式推出, 商業版定價每套 3995 美元.</p>
<p style="padding-left: 60px;">Solidworks 起始開發時採用 ACIS核心, 但正式發表前已經換為 Parasolid 核心, 1997 年 6 月法國達梭公司以 3 億美元併購 Solidworks.</p>
<p style="padding-left: 30px;">有關 <a href="https://en.wikipedia.org/wiki/Siemens_NX">NX</a> (Unigraphics) 的詳細開發緣起, 可以參考 <span> </span><a href="/downloads/cad_history.pdf">The Engineering Design Revolution</a><span> 書中的第十九章.</span></p>
<p style="padding-left: 60px;"><a href="https://en.wikipedia.org/wiki/Siemens_NX">NX</a> 套件的前身為 Unigraphics 早在 1973 年就啟動開發. 2001 年在 <a href="https://en.wikipedia.org/wiki/Electronic_Data_Systems">EDS</a> 旗下與 <a href="https://en.wikipedia.org/wiki/SDRC">SDRC</a> 合併後進行 Unigraphics, I-DEAS 與 SDRC 整合, 產品名稱為 <a href="https://en.wikipedia.org/wiki/Siemens_NX">NX</a>, 公司名稱為 <a href="https://en.wikipedia.org/wiki/UGS_Corp.">UGS</a>, 最終在 2007 年被德國 <a href="https://en.wikipedia.org/wiki/Siemens">Siemens</a> 以 35 億美元併購.</p>
<p style="padding-left: 30px;"><span><a href="https://link.springer.com/book/10.1007/978-3-319-03862-9">2015- Space Modeling with SolidWorks and NX</a> 電子書中的第一章提到在三度空間建立零組件模型的主題包含:</span></p>
<p style="padding-left: 60px;"><span>Role and meaning of modelling for engineering</span></p>
<p style="padding-left: 60px;"><span>Making a sketch and extrude</span></p>
<p style="padding-left: 60px;"><span>Making a sketch and revolve</span></p>
<p style="padding-left: 60px;"><span>Auxiliary shapes of modelling Fillet, chamfer</span></p>
<p style="padding-left: 60px;"><span>Assessment—combined models</span></p>
<p style="padding-left: 60px;"><span>Complex shapes—sweep, loft</span></p>
<p style="padding-left: 60px;"><span>Welded structures</span></p>
<p style="padding-left: 60px;"><span>Sheet-metal products</span></p>
<p style="padding-left: 60px;"><span>Measuring a physical model, digitising, parameterisation</span></p>
<p style="padding-left: 60px;"><span>Assessment—physical models</span></p>
<p style="padding-left: 60px;"><span>Assemblies of structures with models—bottom-up technique</span></p>
<p style="padding-left: 60px;"><span>Assemblies of structures with models—top-down technique</span></p>
<p style="padding-left: 60px;"><span>Documentation—assembly drawing</span></p>
<p style="padding-left: 60px;"><span>Documentation—working drawing</span></p>
<p style="padding-left: 60px;"><span>Assessment—examples as finished units Seminar work.</span></p>
<p><span><img alt="" height="370" src="/images/research_inno_loop_activities.png" width="600"/></span></p>
<p style="padding-left: 60px;"><span></span><img alt="" height="363" src="/images/system_engr_loop_app_research_loop.png" width="600"/></p>
<p><span><img alt="" height="592" src="/images/graphics_repr_R_and_D.png" width="600"/></span></p>
<p><img alt="" height="456" src="/images/golden_loop_R_and_D.png" width="600"/></p>
<p style="padding-left: 30px;">第一章第一節提到有關電腦教室的相關配置規劃. 以及產品開發流程:</p>
<p style="padding-left: 60px;">innovative loop (創新迴圈)</p>
<p style="padding-left: 90px;">The innovative loop is of key importance for recognizing a problem and placing it in space. In the innovation loop we specify the task, the requirements and the wishes that play a part in defining a problem or a technological process</p>
<p style="padding-left: 60px;">System engineering loop (系統工程迴圈)</p>
<p style="padding-left: 90px;">The system-engineering loop places an expected result (innovation, a high-quality product)—vital for the materialization of a product logically into space and time.</p>
<p style="padding-left: 60px;">Application research loop (應用研究迴圈)</p>
<p style="padding-left: 90px;">The application research loop is important in order to define the parameters that provide an optimum choice of function in the material, the conceptual and the user’s environment.</p>
<p style="padding-left: 60px;">Golden loop</p>
<p style="padding-left: 90px;">The golden loop in the development process defines a product in all its details, supplements fundamental researches for all key parameters that define the details and quality materialization of a product.</p><h2>Planar Linkage</h2>
<p><a href="/downloads/linkages.pdf">linkages.pdf</a></p>
<h4>平面機構表示法</h4>
<p style="padding-left: 30px;">2010 年類似鍵結圖 (<a href="https://en.wikipedia.org/wiki/Bond_graph">Bond Graph</a>) 的平面機構表示法:</p>
<p style="padding-left: 60px;"><a href="/downloads/A%20graph%20grammar%20scheme%20for%20representing%20and%20evaluating%20planar%20mechanisms.pdf">A graph grammar scheme for representing and evaluating planar mechanisms.pdf</a><span> (</span><a href="https://repositories.lib.utexas.edu/handle/2152/ETD-UT-2010-05-1393">source</a><span>)</span></p>
<p style="padding-left: 30px;">2019 年 <a href="https://github.com/KmolYuan/Pyslvs-UI">https://github.com/KmolYuan/Pyslvs-UI</a> 採用  <a href="https://github.com/lark-parser/lark">https://github.com/lark-parser/lark</a> 表示平面機構組成</p>
<p style="padding-left: 30px;"><a href="/downloads/PetitParser.pdf">PetitParser.pdf</a> (<a href="http://kevmoo.github.io/PetitParserDart/petitparser.html">http://kevmoo.github.io/PetitParserDart/petitparser.html</a>, <a href="https://github.com/petitparser/dart-petitparser">https://github.com/petitparser/dart-petitparser</a>, <a href="https://github.com/moosetechnology/PetitParser">https://github.com/moosetechnology/PetitParser</a>, <a href="https://github.com/kursjan/petitparser2">https://github.com/kursjan/petitparser2</a>)</p>
<p style="padding-left: 30px;"><a href="/downloads/PetitParser應用.pdf">PetitParser應用.pdf</a> (<a href="https://github.com/freewind/SharkDart">https://github.com/freewind/SharkDart</a>, <a href="http://freewind.in/posts/2336-write-template-engine-yourself-1-principle/">1</a>, <a href="http://freewind.in/posts/2354-write-template-engine-yourself-2-design-syntax/">2</a>, <a href="http://freewind.in/posts/2383-write-template-engine-yourself-3-design-tags/">3</a>, <a href="http://freewind.in/posts/2391-write-template-engine-yourself-4-@@-parse-expressions/">4</a>, <a href="http://freewind.in/posts/2402-write-template-engine-yourself-5-parse-tag-structure/">5</a>, <a href="http://freewind.in/posts/2406-write-template-engine-yourself-6-syntax-tree-and-compiler/">6</a>, <a href="http://freewind.in/posts/2418-write-template-engine-yourself-7-custom-tags/">7</a>, <a href="http://freewind.in/posts/2422-write-template-engine-yourself-8-use-it-in-project-end/">8</a>)</p>
<p style="padding-left: 30px;"><a href="/downloads/PMKS_plus.pdf">pmks_plus.pdf</a> (<a href="http://mde.tw/cad2019/downloads/pmksplus/">http://mde.tw/cad2019/downloads/pmksplus/</a>)</p>
<p style="padding-left: 30px;">pmks_firefox: <a href="https://github.com/mdecourse/pmks_firefox">https://github.com/mdecourse/pmks_firefox</a></p>
<p style="padding-left: 30px;"><a href="https://drive.google.com/open?id=1J-vfDXa5Y84cphT_HI3XL4U6_JQ3gsya">M.Sketch.7z</a> (登入 @gm 後下載)</p>
<p><a href="/downloads/Modeling linkages using linkR v1.1.pdf">Modeling linkages using linkR v1.1.pdf</a></p>
<p><a href="https://github.com/KmolYuan/Pyslvs-UI">https://github.com/KmolYuan/Pyslvs-UI</a></p>
<p><a href="https://github.com/mdecourse/Stagger">https://github.com/mdecourse/Stagger</a></p>
<p><a href="/downloads/Computational Design of Mechanical Characters.pdf">Computational Design of Linkage-Based Characters.pdf</a></p>
<p><a href="/downloads/Computational Design and Motion Control for Characters in the Real World.pdf">Computational Design and Motion Control for Characters in the Real World.pdf</a></p>
<p><a href="/downloads/Computational Design of Linkage-Based Characters.pdf">Computational Design of Mechanical Characters.pdf</a></p>
<p><a href="/downloads/Computational Design of Wind-up Toys.pdf">Computational Design of Wind-up Toys.pdf</a></p>
<p>Design of Linkages</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-1-4419-7892-9">https://link.springer.com/book/10.1007/978-1-4419-7892-9</a></p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/b98861">https://link.springer.com/book/10.1007/b98861</a></p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/content/pdf/10.1007%2F978-3-642-38448-6.pdf">https://link.springer.com/content/pdf/10.1007%2F978-3-642-38448-6.pdf</a></p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-3-319-32922-2">https://link.springer.com/book/10.1007/978-3-319-32922-2</a></p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-90-481-9689-0">https://link.springer.com/book/10.1007/978-90-481-9689-0</a></p>
<p style="padding-left: 30px;"><a href="/downloads/A graph grammar scheme for representing and evaluating planar mechanisms.pdf">A graph grammar scheme for representing and evaluating planar mechanisms.pdf</a> (<a href="https://repositories.lib.utexas.edu/handle/2152/ETD-UT-2010-05-1393">source</a>)</p>
<p style="padding-left: 30px;"><a href="/downloads/Automated design of planar mechanisms_2014.pdf">Automated design of planar mechanisms_2014.pdf</a> (<a href="https://repositories.lib.utexas.edu/handle/2152/24806">source</a>)</p>
<p style="padding-left: 30px;"><a href="/downloads/Automated Synthesis of Planar Mechanisms with Revolute Prismatic and Pin-In-Slot Joints.pdf">Automated Synthesis of Planar Mechanisms with Revolute Prismatic and Pin-In-Slot Joints.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/The A-Design Invention Machine.pdf">The A-Design Invention Machine.pdf</a></p>
<p>Deep Learning</p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-3-319-99223-5">https://link.springer.com/book/10.1007/978-3-319-99223-5</a></p>
<p style="padding-left: 30px;"><a href="https://link.springer.com/book/10.1007/978-3-030-11479-4">https://link.springer.com/book/10.1007/978-3-030-11479-4</a></p><h3>Design of Machinary</h3>
<p>Kinematics - the study of motion without regard to forces</p>
<p>Kinetics - the study of forces on systems in motion</p>
<p>Mechanism -</p>
<p style="padding-left: 30px;">a device that transforms motion to some desirable pattern and typically develops very low forces and transmits little power.</p>
<p style="padding-left: 30px;">a means of transmitting, controlling or constraining relative movement</p>
<p style="padding-left: 30px;">a system of elements arranged to transmit motion in a predetermined fashion.</p>
<p>Machine - contains mechanisms that are designed to provide significant forces and transmit significant power.</p>
<p>The number of pairs of links or the number of instantaneous centres is the number of combinations of n links taken two at a time. Mathematically, number of instantaneous centres, n(n-1)/2.</p>
<p>The Aronhold Kennedy’s theorem states that if three bodies move relatively to each other, they have three instantaneous centres and lie on a straight line.</p>
<p>Fixed instantaneous centres remain in the same place for all configurations of the mechanism.</p><h3>Graph Grammar</h3>
<h4>2010</h4>
<p><a href="/downloads/A graph grammar scheme for representing and evaluating planar mechanisms.pdf">A graph grammar scheme for representing and evaluating planar mechanisms.pdf</a><span> (</span><a href="https://repositories.lib.utexas.edu/handle/2152/ETD-UT-2010-05-1393">source</a><span>)</span></p>
<p><span>Abstract</span></p>
<p><span>There are different phases in any design activity, one of them being <span style="background-color: #ffff00;">concept generation</span>.</span></p>
<p><span>Research in <span style="background-color: #ffff00;">automating the conceptual design process in planar mechanisms</span> is always challenging due to the existence of many different elements and their endless combinations. </span></p>
<p><span>There may be instances where designers arrive at a concept without considering all the alternatives. Computational synthesis aims to arrive at a design by considering the entire space of valid designs. </span></p>
<p><span>Different researchers have adopted various methods to automate the design process that includes existence of similar graph grammar approaches. But few methods replicate the way humans’ design. </span></p>
<p><span>An attempt is being made in the thesis in this direction and as a first step, we focus on <span style="background-color: #ffff00;">representing and evaluating planar mechanisms designed using graph grammars</span>. Graph grammars have been used to represent planar mechanisms but there are disadvantages in the methods currently available. This is due to the lack of information in understanding the details of a mechanism represented by the graph since the graphs do not include information about the type of joints and components such as revolute links, prismatic blocks, gears and cams. </span></p>
<p><span>In order to overcome drawbacks in the existing methods, a novel representation scheme has been developed. In this method, <span style="background-color: #ffff00;">labels and x, y position information in the nodes are used to represent the different mechanism types</span>. <span style="background-color: #ccffcc;">A set of sixteen grammar rules that construct different mechanisms from the basic seed is developed</span>, which implicitly represents a tree of candidate solutions. </span></p>
<p><span>The scheme is tested to determine its capability in capturing the entire set of feasible planar mechanisms of one degree of freedom including Stephenson and double butterfly linkages. In addition to the representation, another important consideration is the need for an accurate and generalized evaluator for kinematic analysis of mechanisms which, given the lack of information, may not be possible with current design automation schemes. </span></p>
<p><span>The approach employed for analysis is purely kinematic and hence <span style="background-color: #ffff00;">the instantaneous center of rotation method is employed</span> in this research. <span style="background-color: #ccffcc;">The velocities of pivots and links are obtained using the instant center method</span>. <span style="background-color: #ffff00;">Once velocities are determined, the vector polygon approach is used to obtain accelerations and geometrical intersection to determine positions of pivots</span>. </span></p>
<p><span><span style="background-color: #ffff00;">The graph grammar based analysis module is implemented in an existing object-oriented grammar framework</span> and the results have found this to be superior to or equivalent to existing commercial packages such as Working Model and SAM for topologies consisting of four-bar loop chain with single degree of freedom.</span></p>
<p><span>Chapter 1</span></p>
<p><span>A design process is comprised of various activities such as gathering user requirements, generating concepts, analyzing properties of those concepts, building prototype and finally testing and refining to get the final outcome. In all the aforementioned activities, each of which are equally important, the concept generation phase is one that brings out the unique feature of the design. A concept may refer to the form (physical design) or the technology used in the functioning of the product. The concept generation process is generally a manual and time-consuming process. Different researchers have attempted computerization of the concept generation process in various domains including the design of planar mechanisms</span></p>
<p><span>Reference:</span></p>
<p><a href="https://www.sciencedirect.com/science/article/pii/S0094114X07001942">Optimum exact/approximate point synthesis of planar mechanisms</a></p>
<p><a href="https://link.springer.com/article/10.1007/s10107-005-0586-3">Design of planar articulated mechanisms using branch and bound</a></p>
<h4>Chebychev–Grübler–Kutzbach criterion</h4>
<p></p>
<p><a href="/downloads/The correction to Grubler criterion for calculating the Degrees of Freedoms of Mechanisms.pdf">The correction to Grubler criterion for calculating the Degrees of Freedoms of Mechanisms.pdf</a></p><h3>PMKS</h3>
<p><span><a href="http://project.mde.tw/blog/planar-mechanism-kinematic-simulator-tuo-pu-fa-jian-jie.html">http://project.mde.tw/blog/planar-mechanism-kinematic-simulator-tuo-pu-fa-jian-jie.html</a></span></p>
<p><span><a href="https://github.com/mdecourse/pmks_firefox">https://github.com/mdecourse/pmks_firefox</a></span></p>
<p><span><a href="http://designengrlab.github.io/GraphSynth/">http://designengrlab.github.io/GraphSynth/</a></span></p>
<p><span><a href="https://github.com/IDEALLab/design-data-list">https://github.com/IDEALLab/design-data-list</a></span></p>
<p><span>從</span></p>
<p><span><a href="https://github.com/mdecourse/pmks_firefox/blob/master/PKMS_source_codes/PlanarMechanismSimulator/PlanarMechanismKinematicSimulator.csproj">https://github.com/mdecourse/pmks_firefox/blob/master/PKMS_source_codes/PlanarMechanismSimulator/PlanarMechanismKinematicSimulator.csproj</a></span></p>
<p><span>可以發現, PMKS 編譯時必須導入 OOOT_Functions\LineSearch\Objective Function Constraint Classes\Interfaces.cs</span></p>
<p>先根據</p>
<p><a href="https://github.com/mdecourse/pmks_firefox/blob/master/PKMS_source_codes/PlanarMechanismSimulator/OOOT_Functions/OptMethods/abstractOptMethod.cs">https://github.com/mdecourse/pmks_firefox/blob/master/PKMS_source_codes/PlanarMechanismSimulator/OOOT_Functions/OptMethods/abstractOptMethod.cs</a></p>
<p>中將數值分析解題分為六大類:</p>
<p>IOptFunction<br/>    IInequality<br/>    IEquality<br/>    IObjectiveFunction<br/>IDependentAnalysis<br/>abstractLineSearch<br/>abstractSearchDirection<br/>abstractMeritFunction<br/>abstractConvergence</p>
<p>其中主要運算則導向</p>
<p>inequality, equality, objectiveFunction, abstractLineSearch 以及abstractSearchDirection 等運算方法.</p>
<p><span>而各點計算位置, 速度與加速度的程式碼, 位於:</span></p>
<p><span><a href="https://github.com/mdecourse/pmks_firefox/blob/master/PKMS_source_codes/PlanarMechanismSimulator/Simulator%20Classes/PlanarMechanismSimulator.Numerical.cs">https://github.com/mdecourse/pmks_firefox/blob/master/PKMS_source_codes/PlanarMechanismSimulator/Simulator%20Classes/PlanarMechanismSimulator.Numerical.cs</a></span></p>
<p><span>平面機構任一時間點的位置計算:</span></p>
<pre class="brush:csharp;auto-links:false;toolbar:false" contenteditable="false">        static double FindPositionatTime(double tau, double deltaTime, double posPrevious, double posNext, double vPrevious,
               double vNext, double aPrevious, double aNext)
        {
            var tauSquared = tau * tau;
            var tauCubed = tau * tauSquared;
            var tauToThe4th = tau * tauCubed;
            var tauToThe5th = tau * tauToThe4th;
            var deltaTimeSquared = deltaTime * deltaTime;
            var deltaTimeCubed = deltaTime * deltaTimeSquared;
            return posPrevious + vPrevious * tau + aPrevious * tauSquared / 2
                   + tauCubed * (10 * (posNext - posPrevious) / deltaTimeSquared - 6 * vPrevious / deltaTime - 4 * vNext / deltaTime
                   - 1.5 * aPrevious + aNext / 2) / deltaTime
                   + tauToThe4th * (15 * (posPrevious - posNext) / deltaTimeSquared + 8 * vPrevious / deltaTime + 7 * vNext / deltaTime
                   + 1.5 * aPrevious - aNext) / deltaTimeSquared
                   + tauToThe5th * (6 * (posPrevious - posNext) / deltaTimeSquared + 3 * (vPrevious + vNext) / deltaTime + 0.5 * (aPrevious - aNext))
                   / deltaTimeCubed;
        }</pre>
<p>各點的速度計算:</p>
<pre class="brush:csharp;auto-links:false;toolbar:false" contenteditable="false">        static double FindVelocityatTime(double tau, double deltaTime, double vPrevious, double vNext, double aPrevious, double aNext)
        {
            if (deltaTime == 0.0) return vPrevious;
            var tauSquared = tau * tau;
            var tauCubed = tau * tauSquared;
            var deltaTimeSquared = deltaTime * deltaTime;
            var deltaTimeCubed = deltaTime * deltaTimeSquared;
            return vPrevious
                   + (vPrevious - vNext) * (2 * tauCubed / deltaTimeCubed - 3 * tauSquared / deltaTimeSquared)
                   + aNext * (tauCubed / deltaTimeSquared - tauSquared / deltaTime)
                   + aPrevious * (tauCubed / deltaTimeSquared - 2 * tauSquared / deltaTime + tau);
        }</pre>
<p>各點的加速度計算:</p>
<pre class="brush:csharp;auto-links:false;toolbar:false" contenteditable="false">        static double FindAccelerationatTime(double tau, double deltaTime, double aPrevious, double aNext)
        {
            if (deltaTime == 0.0) return aPrevious;
            return aPrevious + (aNext - aPrevious) * tau / deltaTime;
        }</pre>
<p>利用 Dart 執行矩陣運算:</p>
<p style="padding-left: 30px;"><a href="http://mde.tw/c16278af1d23579b5f5d5dca5b7e090e">http://mde.tw/c16278af1d23579b5f5d5dca5b7e090e</a></p><h2>CAD2CAE</h2>
<p>1 <span style="color: #ffffff;"><a href="https://drive.google.com/file/d/1G6vY3PZd3gkLF2H82rBKLnE3RyM3NRUs/view?usp=sharing" style="color: #ffffff;">autodesk_inventor_tutorial.7z</a></span></p>
<p><img alt="" src="/images/autodesk_inventor_1.png" width="600"/></p>
<p>Solvespace: <a href="/downloads/cad2cae_1_solvespace.slvs">cad2cae_1_solvespace.slvs</a></p>
<p>FreeCAD:</p>
<p>NX12:</p>
<p>Solidworks:</p>
<p>Inventor:</p>
<p>Onshape:</p>
<p>2</p>
<p><img alt="" src="/images/autodesk_inventor_2.png" width="600"/></p>
<p>3</p>
<p><img alt="" src="/images/autodesk_inventor_3.png" width="600"/></p>
<p>4</p>
<p><img alt="" src="/images/autodesk_inventor_4.png" width="600"/></p>
<p>5</p>
<p><img alt="" src="/images/autodesk_inventor_5.png" width="600"/></p>
<p>6</p>
<p><img alt="" src="/images/autodesk_inventor_6.png" width="600"/></p>
<p>7</p>
<p><img alt="" src="/images/autodesk_inventor_7.png" width="600"/></p>
<p>8</p>
<p><img alt="" src="/images/autodesk_inventor_8.png" width="600"/></p>
<p>9</p>
<p><img alt="" src="/images/autodesk_inventor_9.png" width="600"/></p>
<p>10</p>
<p><img alt="" src="/images/autodesk_inventor_10.png" width="600"/></p>
<p>11</p>
<p><img alt="" src="/images/autodesk_inventor_11.png" width="600"/></p>
<p>12</p>
<p><img alt="" src="/images/autodesk_inventor_12.png" width="600"/></p>
<p>13</p>
<p><img alt="" src="/images/autodesk_inventor_13.png" width="600"/></p>
<p>14</p>
<p><img alt="" src="/images/autodesk_inventor_14.png" width="600"/></p>
<p>15</p>
<p><img alt="" src="/images/autodesk_inventor_15.png" width="600"/></p>
<p>16</p>
<p><img alt="" src="/images/autodesk_inventor_16.png" width="600"/></p>
<p>17</p>
<p><img alt="" src="/images/autodesk_inventor_17.png" width="600"/></p>
<p>18</p>
<p><img alt="" src="/images/autodesk_inventor_18.png" width="600"/></p>